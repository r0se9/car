// --------------------------------------
//
//    _  _ _/ .  _  _/ /_ _  _  _
//   /_|/_ / /|//_  / / //_ /_// /_/
//   https://activetheory.net    _/
//
// --------------------------------------
//   12/11/23 9:39a
// --------------------------------------

"undefined" == typeof console &&
  ((window.console = {}),
  (console.log =
    console.error =
    console.info =
    console.debug =
    console.warn =
    console.trace =
      function () {})),
  (window.performance =
    window.performance && window.performance.now ? window.performance : Date),
  (Date.now =
    Date.now ||
    function () {
      return +new Date();
    }),
  window.requestAnimationFrame ||
    (window.requestAnimationFrame =
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      (function () {
        const start = Date.now();
        return function (callback) {
          window.setTimeout(() => callback(Date.now() - start), 1e3 / 60);
        };
      })()),
  (window.defer = window.requestAnimationFrame),
  (window.clearTimeout = (function () {
    const _clearTimeout = window.clearTimeout;
    return function (ref) {
      return window.Timer
        ? Timer.__clearTimeout(ref) || _clearTimeout(ref)
        : _clearTimeout(ref);
    };
  })()),
  (window.requestIdleCallback = (function () {
    const _requestIdleCallback = window.requestIdleCallback;
    return function (callback, max) {
      return _requestIdleCallback
        ? _requestIdleCallback(callback, max ? { timeout: max } : null)
        : defer(() => {
            callback({ didTimeout: !1 });
          }, 0);
    };
  })()),
  (window.onIdle = window.requestIdleCallback),
  "undefined" == typeof Float32Array && (Float32Array = Array),
  (Math.sign = function (x) {
    return 0 == (x = +x) || isNaN(x) ? Number(x) : x > 0 ? 1 : -1;
  }),
  (Math._round = Math.round),
  (Math.round = function (value, precision = 0) {
    let p = Math.pow(10, precision);
    return Math._round(value * p) / p;
  }),
  (Math._random = Math.random),
  (Math.rand = Math.random =
    function (min, max, precision = 0) {
      return void 0 === min
        ? Math._random()
        : min === max
        ? min
        : ((min = min || 0),
          (max = max || 1),
          0 == precision
            ? Math.floor(Math._random() * (max + 1 - min) + min)
            : Math.round(min + Math._random() * (max - min), precision));
    }),
  (Math.degrees = function (radians) {
    return radians * (180 / Math.PI);
  }),
  (Math.radians = function (degrees) {
    return degrees * (Math.PI / 180);
  }),
  (Math.clamp = function (value, min = 0, max = 1) {
    return Math.min(Math.max(value, Math.min(min, max)), Math.max(min, max));
  }),
  (Math.map = Math.range =
    function (value, oldMin = -1, oldMax = 1, newMin = 0, newMax = 1, isClamp) {
      const newValue =
        ((value - oldMin) * (newMax - newMin)) / (oldMax - oldMin) + newMin;
      return isClamp
        ? Math.clamp(
            newValue,
            Math.min(newMin, newMax),
            Math.max(newMin, newMax)
          )
        : newValue;
    }),
  (Math.mix = function (a, b, alpha) {
    return a * (1 - alpha) + b * alpha;
  }),
  (Math.step = function (edge, value) {
    return value < edge ? 0 : 1;
  }),
  (Math.smoothStep = function (min, max, value) {
    const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
    return x * x * (3 - 2 * x);
  }),
  (Math.fract = function (value) {
    return value - Math.floor(value);
  }),
  (Math.mod = function (value, n) {
    return ((value % n) + n) % n;
  }),
  (Array.prototype.shuffle = function () {
    let temp,
      r,
      i = this.length - 1;
    for (; i > 0; )
      (r = Math.random(0, i, 0)),
        (temp = this[(i -= 1)]),
        (this[i] = this[r]),
        (this[r] = temp);
    return this;
  }),
  (Array.storeRandom = function (arr) {
    arr.randomStore = [];
  }),
  (Array.prototype.random = function (range) {
    let value = Math.random(0, this.length - 1);
    if (
      (arguments.length && !this.randomStore && Array.storeRandom(this),
      !this.randomStore)
    )
      return this[value];
    if ((range > this.length - 1 && (range = this.length), range > 1)) {
      for (; ~this.randomStore.indexOf(value); )
        (value += 1) > this.length - 1 && (value = 0);
      this.randomStore.push(value),
        this.randomStore.length >= range && this.randomStore.shift();
    }
    return this[value];
  }),
  (Array.prototype.remove = function (element) {
    if (!this.indexOf) return;
    const index = this.indexOf(element);
    return ~index ? this.splice(index, 1) : void 0;
  }),
  (Array.prototype.last = function () {
    return this[this.length - 1];
  }),
  (window.Promise = window.Promise || {}),
  (Promise.create = function () {
    const promise = new Promise((resolve, reject) => {
      (this.temp_resolve = resolve), (this.temp_reject = reject);
    });
    return (
      (promise.resolve = this.temp_resolve),
      (promise.reject = this.temp_reject),
      delete this.temp_resolve,
      delete this.temp_reject,
      promise
    );
  }),
  (Promise.catchAll = function (array) {
    let promises = [];
    return (
      array.forEach((promise) => {
        let p = Promise.create();
        promises.push(p),
          promise.then((d) => p.resolve(d)).catch((e) => p.reject(e));
      }),
      Promise.all(promises)
    );
  }),
  (String.prototype.includes = function (str) {
    if (!Array.isArray(str)) return !!~this.indexOf(str);
    for (let i = str.length - 1; i >= 0; i--)
      if (~this.indexOf(str[i])) return !0;
    return !1;
  }),
  (String.prototype.equals = function (str) {
    let compare = String(this);
    if (!Array.isArray(str)) return str === compare;
    for (let i = str.length - 1; i >= 0; i--) if (str[i] === compare) return !0;
    return !1;
  }),
  (String.prototype.strpos = function (str) {
    return (
      console.warn("strpos deprecated: use .includes()"), this.includes(str)
    );
  }),
  (String.prototype.clip = function (num, end = "") {
    return this.length > num
      ? this.slice(0, Math.max(0, num - end.length)).trim() + end
      : this.slice();
  }),
  (String.prototype.capitalize = function () {
    return this.charAt(0).toUpperCase() + this.slice(1);
  }),
  (String.prototype.replaceAll = function (find, replace) {
    return this.split(find).join(replace);
  }),
  (String.prototype.replaceAt = function (index, replacement) {
    return (
      this.substr(0, index) +
      replacement +
      this.substr(index + replacement.length)
    );
  }),
  (!window.fetch || (window.nativeHydra && !window.AURA)) &&
    (window.fetch = function (url, options) {
      function response() {
        let header,
          keys = [],
          all = [],
          headers = {};
        return (
          request
            .getAllResponseHeaders()
            .replace(/^(.*?):\s*([\s\S]*?)$/gm, (m, key, value) => {
              keys.push((key = key.toLowerCase())),
                all.push([key, value]),
                (header = headers[key]),
                (headers[key] = header ? `${header},${value}` : value);
            }),
          {
            ok: 1 == ((request.status / 200) | 0),
            status: request.status,
            statusText: request.statusText,
            url: request.responseURL,
            clone: response,
            text: () => Promise.resolve(request.responseText),
            json: () => Promise.resolve(request.responseText).then(JSON.parse),
            xml: () => Promise.resolve(request.responseXML),
            blob: () => Promise.resolve(new Blob([request.response])),
            headers: {
              keys: () => keys,
              entries: () => all,
              get: (n) => headers[n.toLowerCase()],
              has: (n) => n.toLowerCase() in headers,
            },
          }
        );
      }
      options = options || {};
      const promise = Promise.create(),
        request = new XMLHttpRequest();
      request.open(options.method || "get", url);
      for (let i in options.headers)
        request.setRequestHeader(i, options.headers[i]);
      return (
        (request.onload = () => {
          promise.resolve(response());
        }),
        (request.onerror = promise.reject),
        request.send(options.body),
        promise
      );
    }),
  (window.get = function (url, options = { credentials: "same-origin" }) {
    let promise = Promise.create();
    return (
      (options.method = "GET"),
      fetch(url, options)
        .then(function handleResponse(e) {
          if (!e.ok) return promise.reject(e);
          e.text().then((text) => {
            if (text.charAt(0).includes(["[", "{"]))
              try {
                promise.resolve(JSON.parse(text));
              } catch (err) {
                promise.resolve(text);
              }
            else promise.resolve(text);
          });
        })
        .catch(promise.reject),
      promise
    );
  }),
  (window.post = function (url, body, options = {}) {
    let promise = Promise.create();
    return (
      (options.method = "POST"),
      body && (options.body = JSON.stringify(body)),
      fetch(url, options)
        .then(function handleResponse(e) {
          if (!e.ok) return promise.reject(e);
          e.text().then((text) => {
            if (text.charAt(0).includes(["[", "{"]))
              try {
                promise.resolve(JSON.parse(text));
              } catch (err) {
                promise.resolve(text);
              }
            else promise.resolve(text);
          });
        })
        .catch(promise.reject),
      promise
    );
  }),
  (window.Class = function (_class, _type, _static) {
    const _this = this || window,
      _name = _class.name || _class.toString().match(/function ?([^\(]+)/)[1];
    "function" == typeof _type && ((_static = _type), (_type = null)),
      (_type = (_type || "").toLowerCase())
        ? "static" == _type
          ? (_this[_name] = new _class())
          : "singleton" == _type &&
            ((_this[_name] = _class),
            (function () {
              let _instance;
              _this[_name].instance = function (a, b, c) {
                return (
                  _instance || (_instance = new _class(a, b, c)), _instance
                );
              };
            })(),
            _static && _static())
        : ((_this[_name] = _class), _static && _static()),
      this && this !== window && (this[_name]._namespace = this.__namespace);
  }),
  (window.Inherit = function (child, parent) {
    const args = [].slice.call(arguments, 2);
    parent.apply(child, args);
    const save = {};
    for (let method in child) save[method] = child[method];
    defer(() => {
      for (let method in child)
        if (save[method] && child[method] !== save[method]) {
          if ("destroy" == method && child.destroy && !child.__element)
            throw (
              "Do not override destroy directly, use onDestroy :: " +
              child.constructor.toString()
            );
          child["_" + method] = save[method];
        }
    });
  }),
  (window.Namespace = function (obj) {
    "string" == typeof obj
      ? window[obj] || (window[obj] = { Class: Class, __namespace: obj })
      : ((obj.Class = Class),
        (obj.__namespace =
          obj.constructor.name ||
          obj.constructor.toString().match(/function ([^\(]+)/)[1]));
  }),
  (window.Global = {}),
  (window.THREAD = !1),
  Class(function Hydra() {
    function initLoad() {
      return document && window
        ? window._NODE_
          ? setTimeout(loaded, 1)
          : window._AURA_
          ? window.Main
            ? setTimeout(loaded, 1)
            : setTimeout(initLoad, 1)
          : void window.addEventListener("load", loaded, !1)
        : setTimeout(initLoad, 1);
    }
    function loaded() {
      window.removeEventListener("load", loaded, !1),
        (_this.LOCAL =
          !window._BUILT_ &&
          (location.hostname.indexOf("local") > -1 ||
            "10" == location.hostname.split(".")[0] ||
            "192" == location.hostname.split(".")[0]) &&
          "" == location.port),
        _callbacks.forEach((cb) => cb()),
        (_callbacks = null),
        _readyPromise.resolve(),
        window.Main &&
          _readyPromise.then(() => (Hydra.Main = new window.Main()));
    }
    const _this = this,
      _readyPromise = Promise.create();
    var _base,
      _callbacks = [];
    (this.HASH = window.location.hash.slice(1)),
      (this.LOCAL =
        !window._BUILT_ &&
        (location.hostname.indexOf("local") > -1 ||
          "10" == location.hostname.split(".")[0] ||
          "192" == location.hostname.split(".")[0]) &&
        "" == location.port),
      initLoad(),
      (this.__triggerReady = function () {
        loaded();
      }),
      (this.ready = function (callback) {
        if (!callback) return _readyPromise;
        _callbacks ? _callbacks.push(callback) : callback();
      }),
      (this.absolutePath = function (path) {
        if (window.AURA) return path;
        let base = _base;
        if (void 0 === base)
          try {
            if (document.getElementsByTagName("base").length > 0) {
              var a = document.createElement("a");
              (a.href = document.getElementsByTagName("base")[0].href),
                (base = a.pathname),
                (_base = base);
            }
          } catch (e) {
            _base = null;
          }
        let pathname = base || location.pathname;
        pathname.includes("/index.html") &&
          (pathname = pathname.replace("/index.html", ""));
        let port = Number(location.port) > 1e3 ? `:${location.port}` : "";
        return path.includes("http")
          ? path
          : (location.protocol.length ? location.protocol + "//" : "") +
              (location.hostname + port + pathname + "/" + path).replace(
                "//",
                "/"
              );
      });
  }, "Static"),
  Class(function Utils() {
    var _queries = {};
    (this.query = function (key) {
      if (void 0 !== _queries[key]) return _queries[key];
      const str = decodeURI(
        window.location.search.replace(
          new RegExp(
            "^(?:.*[&\\?]" +
              encodeURI(key).replace(/[\.\+\*]/g, "\\$&") +
              "(?:\\=([^&]*))?)?.*$",
            "i"
          ),
          "$1"
        )
      );
      return "0" == str
        ? ((_queries[key] = 0), 0)
        : str.length && "false" != str
        ? ((_queries[key] = str), str)
        : ((_queries[key] = location.search.includes(key)), _queries[key]);
    }),
      (this.getConstructorName = function (obj) {
        return obj
          ? obj.constructor.name ||
              obj.constructor.toString().match(/function ([^\(]+)/)[1]
          : obj;
      }),
      (this.nullObject = function (object) {
        if (object.destroy || object.div)
          for (var key in object)
            void 0 !== object[key] && (object[key] = null);
        return null;
      }),
      (this.cloneObject = function (obj) {
        return JSON.parse(JSON.stringify(obj));
      }),
      (this.headsTails = function (n0, n1) {
        return Math.random(0, 1) ? n1 : n0;
      }),
      (this.mergeObject = function () {
        for (var obj = {}, i = 0; i < arguments.length; i++) {
          var o = arguments[i];
          for (var key in o) obj[key] = o[key];
        }
        return obj;
      }),
      (this.timestamp = function () {
        return (Date.now() + Math.random(0, 99999, 0)).toString();
      }),
      (this.randomColor = function () {
        var color = "#" + Math.floor(16777215 * Math.random()).toString(16);
        return color.length < 7 && (color = this.randomColor()), color;
      }),
      (this.numberWithCommas = function (num) {
        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      }),
      (this.padInt = function (num, digits, isLimit) {
        isLimit && (num = Math.min(num, Math.pow(10, digits) - 1));
        let str = Math.floor(num).toString();
        return (
          Math.pow(10, Math.max(0, digits - str.length))
            .toString()
            .slice(1) + str
        );
      }),
      (this.copyToClipboard = function (string) {
        try {
          var el = document.createElement("textarea"),
            range = document.createRange();
          (el.contentEditable = !0),
            (el.readOnly = !0),
            (el.value = string),
            document.body.appendChild(el),
            el.select(),
            range.selectNodeContents(el);
          var s = window.getSelection();
          return (
            s.removeAllRanges(),
            s.addRange(range),
            el.setSelectionRange(0, string.length),
            document.execCommand("copy"),
            document.body.removeChild(el),
            !0
          );
        } catch (e) {
          return !1;
        }
      });
  }, "Static"),
  Class(function Render() {
    function render() {
      let tsl = performance.now(),
        delta = tsl - _last;
      (delta = Math.min(_skipLimit, delta)),
        (_last = tsl),
        (_this.TIME = tsl),
        (_this.DELTA = delta);
      for (let i = _render.length - 1; i >= 0; i--) {
        var callback = _render[i];
        if (callback)
          if (callback.fps) {
            if (tsl - callback.last < 1e3 / callback.fps) continue;
            callback(++callback.frame), (callback.last = tsl);
          } else callback(tsl, delta);
        else _render.remove(callback);
      }
      for (let i = _drawFrame.length - 1; i > -1; i--)
        _drawFrame[i](tsl, delta);
      _this.drawFrame && _this.drawFrame(tsl, delta),
        THREAD || _this.isPaused || rAF(render);
    }
    const _this = this,
      _render = [],
      _drawFrame = [];
    let _last = performance.now(),
      _skipLimit = 200;
    var rAF = requestAnimationFrame;
    THREAD || rAF(render),
      (this.start = function (callback, fps) {
        fps &&
          ((callback.fps = fps),
          (callback.last = -1 / 0),
          (callback.frame = -1)),
          ~_render.indexOf(callback) || _render.unshift(callback);
      }),
      (this.stop = function (callback) {
        _render.remove(callback);
      }),
      (this.tick = function () {
        THREAD && ((this.TIME = performance.now()), render(this.TIME));
      }),
      (this.Worker = function (_callback, _budget = 4) {
        function loop() {
          for (; _elapsed < _budget; ) {
            if (_scope.dead) return;
            const start = performance.now();
            _callback && _callback(), (_elapsed += performance.now() - start);
          }
          _elapsed = 0;
        }
        Inherit(this, Component);
        let _scope = this,
          _elapsed = 0;
        this.startRender(loop),
          (this.stop = function () {
            (this.dead = !0), this.stopRender(loop);
          }),
          (this.pause = function () {
            this.stopRender(loop);
          }),
          (this.resume = function () {
            this.startRender(loop);
          });
      }),
      (this.pause = function () {
        _this.isPaused = !0;
      }),
      (this.resume = function () {
        _this.isPaused && ((_this.isPaused = !1), rAF(render));
      }),
      (this.useRAF = function (raf) {
        (rAF = raf)(render);
      }),
      (this.onDrawFrame = function (cb) {
        _drawFrame.push(cb);
      });
  }, "Static"),
  Class(function Timer() {
    function loop(t, delta) {
      for (let i = _discard.length - 1; i >= 0; i--) {
        let obj = _discard[i];
        (obj.callback = null), _callbacks.remove(obj);
      }
      _discard.length && (_discard.length = 0);
      for (let i = _callbacks.length - 1; i >= 0; i--) {
        let obj = _callbacks[i];
        obj
          ? (obj.current += delta) >= obj.time &&
            (obj.callback && obj.callback.apply(this, obj.args),
            _discard.push(obj))
          : _callbacks.remove(obj);
      }
    }
    function find(ref) {
      for (let i = _callbacks.length - 1; i > -1; i--)
        if (_callbacks[i].ref == ref) return _callbacks[i];
    }
    const _this = this,
      _callbacks = [],
      _discard = [];
    Render.start(loop),
      (this.__clearTimeout = function (ref) {
        const obj = find(ref);
        return !!obj && ((obj.callback = null), _callbacks.remove(obj), !0);
      }),
      (this.create = function (callback, time) {
        if (window._NODE_) return setTimeout(callback, time);
        const obj = {
          time: Math.max(1, time || 1),
          current: 0,
          ref: Utils.timestamp(),
          callback: callback,
          args: [].slice.call(arguments, 2),
        };
        return _callbacks.unshift(obj), obj.ref;
      }),
      (window.defer = this.defer =
        function (callback) {
          if (!callback) {
            let promise = Promise.create();
            return _this.create(promise.resolve, 1), promise;
          }
          _this.create(callback, 1);
        });
  }, "static"),
  Class(
    function Events() {
      this.events = {};
      const _e = {},
        _linked = [];
      let _emitter;
      (this.events.sub = function (obj, evt, callback) {
        if (
          ("object" != typeof obj &&
            ((callback = evt), (evt = obj), (obj = null)),
          !obj)
        )
          return (
            Events.emitter._addEvent(
              evt,
              callback.resolve ? callback.resolve : callback,
              this
            ),
            callback
          );
        let emitter = obj.events.emitter();
        return (
          emitter._addEvent(
            evt,
            callback.resolve ? callback.resolve : callback,
            this
          ),
          emitter._saveLink(this),
          _linked.push(emitter),
          callback
        );
      }),
        (this.events.unsub = function (obj, evt, callback) {
          if (
            ("object" != typeof obj &&
              ((callback = evt), (evt = obj), (obj = null)),
            !obj)
          )
            return Events.emitter._removeEvent(
              evt,
              callback.resolve ? callback.resolve : callback
            );
          obj.events
            .emitter()
            ._removeEvent(evt, callback.resolve ? callback.resolve : callback);
        }),
        (this.events.fire = function (evt, obj, isLocalOnly) {
          ((obj = obj || _e).target = this),
            Events.emitter._check(evt),
            (_emitter && _emitter._fireEvent(evt, obj)) ||
              isLocalOnly ||
              Events.emitter._fireEvent(evt, obj);
        }),
        (this.events.bubble = function (obj, evt) {
          let _this = this;
          _this.sub(obj, evt, (e) => _this.fire(evt, e));
        }),
        (this.events.destroy = function () {
          return (
            Events.emitter._destroyEvents(this),
            _linked &&
              _linked.forEach((emitter) => emitter._destroyEvents(this)),
            _emitter &&
              _emitter.links &&
              _emitter.links.forEach(
                (obj) => obj.events && obj.events._unlink(_emitter)
              ),
            null
          );
        }),
        (this.events.emitter = function () {
          return (
            _emitter || (_emitter = Events.emitter.createLocalEmitter()),
            _emitter
          );
        }),
        (this.events._unlink = function (emitter) {
          _linked.remove(emitter);
        });
    },
    () => {
      function Emitter() {
        const prototype = Emitter.prototype;
        (this.events = []),
          void 0 === prototype._check &&
            ((prototype._check = function (evt) {
              if (void 0 === evt) throw "Undefined event";
            }),
            (prototype._addEvent = function (evt, callback, object) {
              this._check(evt),
                this.events.push({
                  evt: evt,
                  object: object,
                  callback: callback,
                });
            }),
            (prototype._removeEvent = function (eventString, callback) {
              this._check(eventString);
              let _this = this,
                marked = !1;
              for (let i = this.events.length - 1; i >= 0; i--)
                this.events[i].evt == eventString &&
                  this.events[i].callback == callback &&
                  ((this.events[i].markedForDeletion = !0), (marked = !0));
              marked && defer(() => _this._sweepEvents());
            }),
            (prototype._sweepEvents = function () {
              for (let i = 0; i < this.events.length; i++)
                this.events[i].markedForDeletion &&
                  this.events.remove(this.events[i]);
            }),
            (prototype._fireEvent = function (eventString, obj) {
              this._check && this._check(eventString), (obj = obj || _e);
              let called = !1;
              for (let i = 0; i < this.events.length; i++) {
                let evt = this.events[i];
                evt.evt != eventString ||
                  evt.markedForDeletion ||
                  (evt.callback(obj), (called = !0));
              }
              return called;
            }),
            (prototype._destroyEvents = function (object) {
              for (var i = this.events.length - 1; i >= 0; i--)
                this.events[i].object == object &&
                  (this.events.splice(i, 1)[0] = null);
            }),
            (prototype._saveLink = function (obj) {
              this.links || (this.links = []),
                ~this.links.indexOf(obj) || this.links.push(obj);
            }),
            (prototype.createLocalEmitter = function () {
              return new Emitter();
            }));
      }
      (Events.emitter = new Emitter()),
        (Events.broadcast = Events.emitter._fireEvent),
        (Events.VISIBILITY = "hydra_visibility"),
        (Events.HASH_UPDATE = "hydra_hash_update"),
        (Events.COMPLETE = "hydra_complete"),
        (Events.PROGRESS = "hydra_progress"),
        (Events.UPDATE = "hydra_update"),
        (Events.LOADED = "hydra_loaded"),
        (Events.END = "hydra_end"),
        (Events.FAIL = "hydra_fail"),
        (Events.SELECT = "hydra_select"),
        (Events.ERROR = "hydra_error"),
        (Events.READY = "hydra_ready"),
        (Events.RESIZE = "hydra_resize"),
        (Events.CLICK = "hydra_click"),
        (Events.HOVER = "hydra_hover"),
        (Events.MESSAGE = "hydra_message"),
        (Events.ORIENTATION = "orientation"),
        (Events.BACKGROUND = "background"),
        (Events.BACK = "hydra_back"),
        (Events.PREVIOUS = "hydra_previous"),
        (Events.NEXT = "hydra_next"),
        (Events.RELOAD = "hydra_reload"),
        (Events.FULLSCREEN = "hydra_fullscreen");
      const _e = {};
      Hydra.ready(() => {
        function updateStage() {
          (Stage.width =
            document.body.clientWidth ||
            document.documentElement.offsetWidth ||
            window.innerWidth),
            (Stage.height =
              document.body.clientHeight ||
              document.documentElement.offsetHeight ||
              window.innerHeight);
        }
        !(function () {
          function onfocus() {
            "focus" != _last &&
              Events.emitter._fireEvent(Events.VISIBILITY, { type: "focus" }),
              (_last = "focus");
          }
          function onblur() {
            "blur" != _last &&
              Events.emitter._fireEvent(Events.VISIBILITY, { type: "blur" }),
              (_last = "blur");
          }
          let _last,
            _lastTime = performance.now();
          Timer.create(function addVisibilityHandler() {
            let hidden, eventName;
            if (
              ([
                ["msHidden", "msvisibilitychange"],
                ["webkitHidden", "webkitvisibilitychange"],
                ["hidden", "visibilitychange"],
              ].forEach((d) => {
                void 0 !== document[d[0]] &&
                  ((hidden = d[0]), (eventName = d[1]));
              }),
              !eventName)
            ) {
              const root = "ie" == Device.browser ? document : window;
              return (root.onfocus = onfocus), void (root.onblur = onblur);
            }
            document.addEventListener(eventName, () => {
              const time = performance.now();
              time - _lastTime > 10 &&
                (!1 === document[hidden] ? onfocus() : onblur()),
                (_lastTime = time);
            });
          }, 250);
        })(),
          (window.Stage = window.Stage || {}),
          updateStage(),
          window.addEventListener("resize", function () {
            updateStage(), Events.emitter._fireEvent(Events.RESIZE);
          }),
          (window.onorientationchange = window.onresize),
          defer(window.onresize);
      });
    }
  ),
  Class(function Device() {
    var _this = this;
    (this.agent = navigator.userAgent.toLowerCase()),
      (this.detect = function (match) {
        return this.agent.includes(match);
      }),
      (this.touchCapable = !!("ontouchstart" in window)),
      (this.pixelRatio = window.devicePixelRatio),
      (this.system = {}),
      (this.system.retina = window.devicePixelRatio > 1),
      (this.system.webworker = void 0 !== window.Worker),
      window._NODE_ ||
        (this.system.geolocation = void 0 !== navigator.geolocation),
      window._NODE_ ||
        (this.system.pushstate = void 0 !== window.history.pushState),
      (this.system.webcam = !!(
        navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia ||
        navigator.msGetUserMedia
      )),
      (this.system.language =
        window.navigator.userLanguage || window.navigator.language),
      (this.system.webaudio = void 0 !== window.AudioContext),
      (this.system.xr = navigator.getVRDisplays || navigator.xr),
      (this.system.exokit = _this.detect("exokit"));
    try {
      this.system.localStorage = void 0 !== window.localStorage;
    } catch (e) {
      this.system.localStorage = !1;
    }
    (this.system.fullscreen =
      document.fullscreenEnabled ||
      document.webkitFullscreenEnabled ||
      document.mozFullScreenEnabled ||
      document.msFullscreenEnabled),
      (this.system.os =
        _this.detect(["exokit"]) && "linux" == navigator.platform
          ? "magicleap"
          : _this.detect(["ipad", "iphone"])
          ? "ios"
          : _this.detect(["android", "kindle"])
          ? "android"
          : _this.detect(["blackberry"])
          ? "blackberry"
          : _this.detect(["mac os"])
          ? "mac"
          : _this.detect(["windows", "iemobile"])
          ? "windows"
          : _this.detect(["linux"])
          ? "linux"
          : "unknown"),
      (this.system.version = (function () {
        try {
          if ("ios" == _this.system.os) {
            var num = _this.agent.split("os ")[1].split("_"),
              main = num[0],
              sub = num[1].split(" ")[0];
            return Number(main + "." + sub);
          }
          if ("android" == _this.system.os) {
            var version = _this.agent.split("android ")[1].split(";")[0];
            return (
              version.length > 3 && (version = version.slice(0, -2)),
              "." == version.charAt(version.length - 1) &&
                (version = version.slice(0, -1)),
              Number(version)
            );
          }
          if ("windows" == _this.system.os)
            return _this.agent.includes("rv:11")
              ? 11
              : Number(_this.agent.split("windows phone ")[1].split(";")[0]);
        } catch (e) {}
        return -1;
      })()),
      (this.system.browser =
        "ios" == _this.system.os
          ? _this.detect(["twitter", "fbios"])
            ? "social"
            : _this.detect(["crios"])
            ? "chrome"
            : _this.detect(["safari"])
            ? "safari"
            : "unknown"
          : "android" == _this.system.os
          ? _this.detect(["twitter", "fb", "facebook"])
            ? "social"
            : _this.detect(["chrome"])
            ? "chrome"
            : _this.detect(["firefox"])
            ? "firefox"
            : "browser"
          : _this.detect(["msie"])
          ? "ie"
          : _this.detect(["trident"]) && _this.detect(["rv:"])
          ? "ie"
          : _this.detect(["windows"]) && _this.detect(["edge"])
          ? "ie"
          : _this.detect(["chrome"])
          ? "chrome"
          : _this.detect(["safari"])
          ? "safari"
          : _this.detect(["firefox"])
          ? "firefox"
          : "unknown"),
      (this.system.browserVersion = (function () {
        try {
          if ("chrome" == _this.system.browser)
            return Number(_this.agent.split("chrome/")[1].split(".")[0]);
          if ("firefox" == _this.system.browser)
            return Number(_this.agent.split("firefox/")[1].split(".")[0]);
          if ("safari" == _this.system.browser)
            return Number(
              _this.agent.split("version/")[1].split(".")[0].split(".")[0]
            );
          if ("ie" == _this.system.browser)
            return _this.detect(["msie"])
              ? Number(_this.agent.split("msie ")[1].split(".")[0])
              : _this.detect(["rv:"])
              ? Number(_this.agent.split("rv:")[1].split(".")[0])
              : Number(_this.agent.split("edge/")[1].split(".")[0]);
        } catch (e) {
          return -1;
        }
      })()),
      (this.mobile =
        !(
          window._NODE_ ||
          !("ontouchstart" in window || "onpointerdown" in window) ||
          !this.detect([
            "ios",
            "iphone",
            "ipad",
            "windows phone",
            "android",
            "blackberry",
          ])
        ) && {}),
      this.mobile &&
        this.detect(["windows"]) &&
        !this.detect(["touch"]) &&
        (this.mobile = !1),
      this.mobile &&
        ((this.mobile.tablet =
          Math.max(
            window.screen ? screen.width : window.innerWidth,
            window.screen ? screen.height : window.innerHeight
          ) > 1e3),
        (this.mobile.phone = !this.mobile.tablet),
        (this.mobile.pwa =
          !(
            !window.matchMedia ||
            !window.matchMedia("(display-mode: standalone)").matches
          ) || !!window.navigator.standalone),
        Hydra.ready(() => {
          _this.mobile.native =
            !(!Mobile.NativeCore || !Mobile.NativeCore.active) ||
            !!window._AURA_;
        })),
      (this.media = {}),
      (this.media.audio =
        !!document.createElement("audio").canPlayType &&
        (_this.detect(["firefox", "opera"]) ? "ogg" : "mp3")),
      (this.media.video = (function () {
        var vid = document.createElement("video");
        return (
          !!vid.canPlayType && (vid.canPlayType("video/webm;") ? "webm" : "mp4")
        );
      })()),
      (this.media.webrtc = !!(
        window.webkitRTCPeerConnection ||
        window.mozRTCPeerConnection ||
        window.msRTCPeerConnection ||
        window.oRTCPeerConnection ||
        window.RTCPeerConnection
      )),
      (this.graphics = {}),
      (this.graphics.webgl = (function () {
        let DISABLED = !1;
        Object.defineProperty(_this.graphics, "webgl", {
          get: () => {
            if (DISABLED) return !1;
            if (_this.graphics._webglContext)
              return _this.graphics._webglContext;
            if ("magicleap" == _this.system.os) {
              let output = {};
              return (
                (output.gpu = "tegra x1"),
                (output.renderer = "webgl 2"),
                (output.detect = function () {
                  return !1;
                }),
                (_this.graphics._webglContext = output),
                output
              );
            }
            try {
              const names = ["webgl2", "webgl", "experimental-webgl"],
                canvas = document.createElement("canvas");
              let gl;
              for (
                let i = 0;
                i < names.length && !(gl = canvas.getContext(names[i]));
                i++
              );
              let info = gl.getExtension("WEBGL_debug_renderer_info"),
                output = {};
              if (info) {
                let gpu = info.UNMASKED_RENDERER_WEBGL;
                output.gpu = gl.getParameter(gpu).toLowerCase();
              }
              return (
                (output.renderer = gl.getParameter(gl.RENDERER).toLowerCase()),
                (output.version = gl.getParameter(gl.VERSION).toLowerCase()),
                (output.glsl = gl
                  .getParameter(gl.SHADING_LANGUAGE_VERSION)
                  .toLowerCase()),
                (output.extensions = gl.getSupportedExtensions()),
                (output.webgl2 = output.version.includes([
                  "webgl 2",
                  "webgl2",
                ])),
                (output.canvas = canvas),
                (output.context = gl),
                (output.detect = function (matches) {
                  if (output.gpu && output.gpu.toLowerCase().includes(matches))
                    return !0;
                  if (
                    output.version &&
                    output.version.toLowerCase().includes(matches)
                  )
                    return !0;
                  for (let i = 0; i < output.extensions.length; i++)
                    if (output.extensions[i].toLowerCase().includes(matches))
                      return !0;
                  return !1;
                }),
                (_this.graphics._webglContext = output),
                output
              );
            } catch (e) {
              return !1;
            }
          },
          set: (v) => {
            !1 === v && (DISABLED = !0);
          },
        });
      })()),
      (this.graphics.canvas = !!document.createElement("canvas").getContext);
    const checkForStyle = (function () {
      let _tagDiv;
      return function (prop) {
        const vendors = ["Khtml", "ms", "O", "Moz", "Webkit"];
        if (prop in (_tagDiv = _tagDiv || document.createElement("div")).style)
          return !0;
        prop = prop.replace(/^[a-z]/, (val) => val.toUpperCase());
        for (let i = vendors.length - 1; i >= 0; i--)
          if (vendors[i] + prop in _tagDiv.style) return !0;
        return !1;
      };
    })();
    (this.styles = {}),
      (this.styles.filter = checkForStyle("filter")),
      (this.styles.blendMode = checkForStyle("mix-blend-mode")),
      (this.tween = {}),
      (this.tween.transition = checkForStyle("transition")),
      (this.tween.css2d = checkForStyle("transform")),
      (this.tween.css3d = checkForStyle("perspective"));
  }, "Static"),
  Class(function Component() {
    function defineSetter(_this, prop) {
      (_setters[prop] = {}),
        Object.defineProperty(_this, prop, {
          set: function (v) {
            _setters[prop] &&
              _setters[prop].s &&
              _setters[prop].s.call(_this, v),
              (v = null);
          },
          get: function () {
            if (_setters[prop] && _setters[prop].g)
              return _setters[prop].g.apply(_this);
          },
        });
    }
    Inherit(this, Events);
    const _this = this,
      _setters = {},
      _flags = {},
      _timers = [],
      _loops = [];
    (this.classes = {}),
      (this.findParent = function (type) {
        let p = _this.parent;
        for (; p; ) {
          if (
            (p._cachedName || (p._cachedName = Utils.getConstructorName(p)),
            p._cachedName == type)
          )
            return p;
          p = p.parent;
        }
      }),
      (this.set = function (prop, callback) {
        _setters[prop] || defineSetter(this, prop),
          (_setters[prop].s = callback);
      }),
      (this.get = function (prop, callback) {
        _setters[prop] || defineSetter(this, prop),
          (_setters[prop].g = callback);
      }),
      (this.initClass = function (clss) {
        if (!clss) throw "unable to locate class";
        const args = [].slice.call(arguments, 1),
          child = Object.create(clss.prototype);
        if (((child.parent = this), clss.apply(child, args), child.destroy)) {
          const id = Utils.timestamp();
          (this.classes[id] = child), (this.classes[id].__id = id);
        }
        if (child.element) {
          const last = arguments[arguments.length - 1];
          Array.isArray(last) &&
          1 == last.length &&
          last[0] instanceof HydraObject
            ? last[0].add(child.element)
            : this.element && null !== last && this.element.add(child.element);
        }
        if (child.group) {
          const last = arguments[arguments.length - 1];
          this.group && null !== last && this.group.add(child.group);
        }
        return child;
      }),
      (this.delayedCall = function (callback, time) {
        const args = [].slice.call(arguments, 2),
          timer = Timer.create(() => {
            _this && _this.destroy && callback && callback.apply(this, args);
          }, time);
        return (
          _timers.push(timer), _timers.length > 50 && _timers.shift(), timer
        );
      }),
      (this.clearTimers = function () {
        for (let i = _timers.length - 1; i >= 0; i--) clearTimeout(_timers[i]);
        _timers.length = 0;
      }),
      (this.startRender = function (callback, fps) {
        for (let i = 0; i < _loops.length; i++)
          if (_loops[i].callback == callback) return;
        let flagInvisible = (_) => {
            _this._invisible ||
              ((_this._invisible = !0),
              _this.onInvisible && _this.onInvisible());
          },
          loop = (a, b, c, d) => {
            let p = _this;
            for (; p; ) {
              if (!1 === p.visible) return flagInvisible();
              if (p.group && !1 === p.group.visible) return flagInvisible();
              p = p.parent;
            }
            !1 !== _this._invisible &&
              ((_this._invisible = !1), _this.onVisible && _this.onVisible()),
              callback(a, b, c, d);
          };
        _loops.push({ callback: callback, loop: loop }),
          Render.start(loop, fps);
      }),
      (this.onResize = function (callback) {
        callback(), this.events.sub(Events.RESIZE, callback);
      }),
      (this.stopRender = function (callback) {
        for (let i = 0; i < _loops.length; i++)
          _loops[i].callback == callback &&
            (Render.stop(_loops[i].loop), _loops.splice(i, 1));
      }),
      (this.clearRenders = function () {
        for (let i = 0; i < _loops.length; i++) Render.stop(_loops[i].loop);
        _loops.length = 0;
      }),
      (this.wait = function (object, key, callback) {
        const promise = Promise.create();
        if (
          ("string" == typeof object &&
            ((callback = key), (key = object), (object = _this)),
          "number" == typeof object && !key)
        )
          return _this.delayedCall(promise.resolve, object), promise;
        if ("function" == typeof object && "function" != typeof callback) {
          let _object = object;
          (object = key), (key = callback), (callback = _object);
        }
        if (((callback = callback || promise.resolve), object[key])) callback();
        else {
          Render.start(test);
          function test() {
            if (!object) return Render.stop(test);
            object[key] && (callback(), Render.stop(test));
          }
        }
        return promise;
      }),
      (this.flag = function (name, value, time) {
        if (void 0 === value) return _flags[name];
        (_flags[name] = value),
          time &&
            (clearTimeout(_flags[name + "_timer"]),
            (_flags[name + "_timer"] = this.delayedCall(() => {
              _flags[name] = !_flags[name];
            }, time)));
      }),
      (this.destroy = function () {
        this.removeDispatch && this.removeDispatch(),
          this.onDestroy && this.onDestroy();
        for (let id in this.classes) {
          var clss = this.classes[id];
          clss && clss.destroy && clss.destroy();
        }
        return (
          (this.classes = null),
          this.clearRenders && this.clearRenders(),
          this.clearTimers && this.clearTimers(),
          this.events && (this.events = this.events.destroy()),
          this.parent &&
            this.parent.__destroyChild &&
            this.parent.__destroyChild(this.__id),
          Utils.nullObject(this)
        );
      }),
      (this.__destroyChild = function (name) {
        delete this.classes[name];
      });
  }),
  Class(function Model() {
    Inherit(this, Component), Namespace(this);
    const _this = this,
      _storage = {};
    let _data = 0,
      _triggered = 0;
    (this.push = function (name, val) {
      _storage[name] = val;
    }),
      (this.pull = function (name) {
        return _storage[name];
      }),
      (this.waitForData = this.promiseData =
        function (num = 1) {
          _data += num;
        }),
      (this.fulfillData = this.resolveData =
        function () {
          ++_triggered == _data && (_this.dataReady = !0);
        }),
      (this.ready = function (callback) {
        let promise = Promise.create();
        return (
          callback && promise.then(callback),
          _this.wait(_this, "dataReady").then(promise.resolve),
          promise
        );
      }),
      (this.initWithData = function (data) {
        _this.STATIC_DATA = data;
        for (var key in _this) {
          var model = _this[key],
            init = !1;
          for (var i in data)
            i.toLowerCase().replace(/-/g, "") == key.toLowerCase() &&
              ((init = !0), model.init && model.init(data[i]));
          !init && model.init && model.init();
        }
        _this.init && _this.init(data);
      }),
      (this.loadData = function (url, callback) {
        let promise = Promise.create();
        callback || (callback = promise.resolve);
        var _this = this;
        return (
          get(url + "?" + Utils.timestamp()).then((d) => {
            defer(() => {
              _this.initWithData(d), callback(d);
            });
          }),
          promise
        );
      });
  }),
  Class(function Modules() {
    function exec() {
      for (let m in _modules)
        for (let key in _modules[m]) {
          let module = _modules[m][key];
          module._ready || ((module._ready = !0), module.exec && module.exec());
        }
    }
    function requireModule(root, path) {
      let module = _modules[root];
      if (!module) throw `Module ${root} not found`;
      return (
        (module = module[path])._ready ||
          ((module._ready = !0), module.exec && module.exec()),
        module
      );
    }
    const _modules = {},
      _constructors = {};
    defer(exec),
      (this.Module = function (module) {
        let m = new module(),
          name = module
            .toString()
            .slice(0, 100)
            .match(/function ([^\(]+)/);
        name
          ? ((m._ready = !0),
            (name = name[1]),
            (_modules[name] = { index: m }),
            (_constructors[name] = module))
          : (_modules[m.module] || (_modules[m.module] = {}),
            (_modules[m.module][m.path] = m));
      }),
      (this.require = function (path) {
        let root;
        return (
          path.includes("/")
            ? ((root = path.split("/")[0]),
              (path = path.replace(root + "/", "")))
            : ((root = path), (path = "index")),
          requireModule(root, path).exports
        );
      }),
      (this.getConstructor = function (name) {
        return _constructors[name];
      }),
      (window.Module = this.Module),
      window._NODE_ ||
        ((window.requireNative = window.require),
        (window.require = this.require));
  }, "Static"),
  Class(function LinkedList() {
    var prototype = LinkedList.prototype;
    (this.length = 0),
      (this.first = null),
      (this.last = null),
      (this.current = null),
      (this.prev = null),
      void 0 === prototype.push &&
        ((prototype.push = function (obj) {
          this.first
            ? ((obj.__next = this.first),
              (obj.__prev = this.last),
              (this.last.__next = obj),
              (this.last = obj))
            : ((this.first = obj),
              (this.last = obj),
              (obj.__prev = obj),
              (obj.__next = obj)),
            this.length++;
        }),
        (prototype.remove = function (obj) {
          obj &&
            obj.__next &&
            (this.length <= 1
              ? this.empty()
              : (obj == this.first
                  ? ((this.first = obj.__next),
                    (this.last.__next = this.first),
                    (this.first.__prev = this.last))
                  : obj == this.last
                  ? ((this.last = obj.__prev),
                    (this.last.__next = this.first),
                    (this.first.__prev = this.last))
                  : ((obj.__prev.__next = obj.__next),
                    (obj.__next.__prev = obj.__prev)),
                this.length--),
            (obj.__prev = null),
            (obj.__next = null));
        }),
        (prototype.empty = function () {
          (this.first = null),
            (this.last = null),
            (this.current = null),
            (this.prev = null),
            (this.length = 0);
        }),
        (prototype.start = function () {
          return (
            (this.current = this.first),
            (this.prev = this.current),
            this.current
          );
        }),
        (prototype.next = function () {
          if (
            this.current &&
            ((this.current = this.current.__next),
            1 != this.length && this.prev.__next != this.first)
          )
            return (this.prev = this.current), this.current;
        }),
        (prototype.destroy = function () {
          return Utils.nullObject(this), null;
        }));
  }),
  Class(function ObjectPool(_type, _number = 10) {
    var _pool = [];
    (this.array = _pool),
      (function () {
        if (_type) for (var i = 0; i < _number; i++) _pool.push(new _type());
      })(),
      (this.get = function () {
        return _pool.shift() || (_type ? new _type() : null);
      }),
      (this.empty = function () {
        _pool.length = 0;
      }),
      (this.put = function (obj) {
        obj && _pool.push(obj);
      }),
      (this.insert = function (array) {
        void 0 === array.push && (array = [array]);
        for (var i = 0; i < array.length; i++) _pool.push(array[i]);
      }),
      (this.length = function () {
        return _pool.length;
      }),
      (this.randomize = function () {
        let array = _pool;
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }),
      (this.destroy = function () {
        for (let i = _pool.length - 1; i >= 0; i--)
          _pool[i].destroy && _pool[i].destroy();
        return (_pool = null);
      });
  }),
  Class(function Assets() {
    function parseResolution(path) {
      if (!window.ASSETS || !ASSETS.RES) return path;
      var res = ASSETS.RES[path],
        ratio = Math.min(Device.pixelRatio, 3);
      if (!res) return path;
      if (!res["x" + ratio]) return path;
      var split = path.split("/"),
        file = split[split.length - 1];
      return (
        (split = file.split(".")),
        path.replace(file, split[0] + "-" + ratio + "x." + split[1])
      );
    }
    function AssetList(arr) {
      return (arr.__proto__ = AssetList.prototype), arr;
    }
    const _this = this;
    (this.__loaded = []),
      (this.FLIPY = !0),
      (this.CDN = ""),
      (this.CORS = null),
      (this.IMAGES = {}),
      (this.SDF = {}),
      (this.JSON = {
        push: function (prop, value) {
          (this[prop] = value),
            Object.defineProperty(this, prop, {
              get: () => JSON.parse(JSON.stringify(value)),
            });
        },
      }),
      Object.defineProperty(this.JSON, "push", {
        enumerable: !1,
        writable: !0,
      }),
      (this.SVG = {}),
      (AssetList.prototype = new Array()),
      (AssetList.prototype.filter = function (items) {
        for (let i = this.length - 1; i >= 0; i--)
          this[i].includes(items) || this.splice(i, 1);
        return this;
      }),
      (AssetList.prototype.exclude = function (items) {
        for (let i = this.length - 1; i >= 0; i--)
          this[i].includes(items) && this.splice(i, 1);
        return this;
      }),
      (AssetList.prototype.prepend = function (prefix) {
        for (let i = this.length - 1; i >= 0; i--) this[i] = prefix + this[i];
        return this;
      }),
      (AssetList.prototype.append = function (suffix) {
        for (let i = this.length - 1; i >= 0; i--) this[i] = this[i] + suffix;
        return this;
      }),
      (this.list = function () {
        return (
          window.ASSETS || console.warn("ASSETS list not available"),
          new AssetList(window.ASSETS.slice(0) || [])
        );
      }),
      (this.getPath = function (path) {
        return ~path.indexOf("//")
          ? path
          : ((path = parseResolution(path)),
            this.CDN && !~path.indexOf(this.CDN) && (path = this.CDN + path),
            path);
      }),
      (this.loadImage = function (path, isStore) {
        var img = new Image();
        return (
          (img.crossOrigin = this.CORS),
          (img.src = _this.getPath(path)),
          (img.loadPromise = function () {
            let promise = Promise.create();
            return (img.onload = promise.resolve), promise;
          }),
          isStore && (this.IMAGES[path] = img),
          img
        );
      }),
      (this.decodeImage = function (path, params) {
        let promise = Promise.create(),
          img = _this.loadImage(path);
        return (img.onload = () => promise.resolve(img)), promise;
      });
  }, "static"),
  Class(
    function AssetLoader(_assets, _callback, ASSETS = Assets) {
      function init() {
        if (!_assets.length) return complete();
        for (let i = 0; i < AssetLoader.SPLIT; i++)
          _assets.length && loadAsset();
      }
      function loadAsset() {
        function loaded() {
          timeout && clearTimeout(timeout),
            increment(),
            _assets.length && loadAsset();
        }
        let path = _assets.splice(_assets.length - 1, 1)[0];
        const name = path.split("assets/").last().split(".")[0],
          ext = path.split(".").last().split("?")[0].toLowerCase();
        let timeout = Timer.create(timedOut, AssetLoader.TIMEOUT, path);
        if (!Assets.preventCache && ~Assets.__loaded.indexOf(path))
          return loaded();
        if (ext.includes(["jpg", "jpeg", "png", "gif"])) {
          let image = ASSETS.loadImage(path);
          return image.complete
            ? loaded()
            : ((image.onload = loaded), void (image.onerror = loaded));
        }
        if (window.AURA && window.AURA.import && "js" == ext)
          return AURA.import(path), void loaded();
        get(Assets.getPath(path), Assets.HEADERS)
          .then((data) => {
            Assets.__loaded.push(path),
              "json" == ext && ASSETS.JSON.push(name, data),
              "svg" == ext && (ASSETS.SVG[name] = data),
              "fnt" == ext && (ASSETS.SDF[name.split("/")[1]] = data),
              "js" == ext && window.eval(data),
              ext.includes(["fs", "vs", "glsl"]) &&
                window.Shaders &&
                Shaders.parse(data, path),
              loaded();
          })
          .catch((e) => {
            console.warn(e), loaded();
          });
      }
      function increment() {
        let percent = Math.max(
          _lastFiredPercent,
          Math.min(1, ++_loaded / _total)
        );
        _this.events.fire(Events.PROGRESS, { percent: percent }),
          (_lastFiredPercent = percent),
          _loaded >= _total && defer(complete);
      }
      function complete() {
        _this.completed ||
          ((_this.completed = !0),
          defer(() => {
            _callback && _callback(), _this.events.fire(Events.COMPLETE);
          }));
      }
      function timedOut(path) {
        console.warn("Asset timed out", path);
      }
      Inherit(this, Events);
      const _this = this;
      let _total = _assets.length,
        _loaded = 0,
        _lastFiredPercent = 0;
      !(function () {
        if (!Array.isArray(_assets))
          throw "AssetLoader requires array of assets to load";
        (_assets = _assets.slice(0).reverse()), init();
      })(),
        (this.loadModules = function () {
          if (!window._BUILT_ || window.AURA) return;
          this.add(1);
          let module = window._ES5_ ? "es5-modules" : "modules",
            s = document.createElement("script");
          return (
            (s.src = "assets/js/" + module + ".js?" + window._CACHE_),
            (s.async = !0),
            document.head.appendChild(s),
            AssetLoader.waitForLib("_MODULES_").then((_) => _this.trigger(1))
          );
        }),
        (this.add = function (num) {
          _total += num || 1;
        }),
        (this.trigger = function (num) {
          for (let i = 0; i < (num || 1); i++) increment();
        });
    },
    () => {
      (AssetLoader.SPLIT = 2),
        (AssetLoader.TIMEOUT = 5e3),
        (AssetLoader.loadAllAssets = function (callback) {
          let promise = Promise.create();
          return (
            callback || (callback = promise.resolve),
            (promise.loader = new AssetLoader(Assets.list(), () => {
              callback && callback(),
                promise.loader &&
                  promise.loader.destroy &&
                  (promise.loader = promise.loader.destroy());
            })),
            promise
          );
        }),
        (AssetLoader.loadAssets = function (list, callback) {
          let promise = Promise.create();
          return (
            callback || (callback = promise.resolve),
            (promise.loader = new AssetLoader(list, () => {
              callback && callback(),
                promise.loader &&
                  promise.loader.destroy &&
                  (promise.loader = promise.loader.destroy());
            })),
            promise
          );
        }),
        (AssetLoader.waitForLib = function (name, callback) {
          function check() {
            window[name] && (Render.stop(check), callback && callback());
          }
          let promise = Promise.create();
          return (
            callback || (callback = promise.resolve),
            Render.start(check),
            promise
          );
        }),
        (AssetLoader.waitForModules = function () {
          return AssetLoader.waitForLib(
            window._BUILT_ ? "_MODULES_" : "zUtils3D"
          );
        });
    }
  ),
  Hydra.ready(function () {
    (window.__window = $(window)),
      (window.__document = $(document)),
      (window.__body = $(document.getElementsByTagName("body")[0])),
      (window.Stage =
        window.Stage && window.Stage.style
          ? $(window.Stage)
          : __body.create("#Stage")),
      Stage.size("100%"),
      (Stage.__useFragment = !0),
      (Stage.width =
        document.body.clientWidth ||
        document.documentElement.offsetWidth ||
        window.innerWidth),
      (Stage.height =
        document.body.clientHeight ||
        document.documentElement.offsetHeight ||
        window.innerHeight);
  }),
  Class(function CSS() {
    function objToCSS(key) {
      var match = key.match(/[A-Z]/),
        camelIndex = match ? match.index : null;
      return (
        camelIndex &&
          (key =
            key.slice(0, camelIndex) +
            "-" +
            key.slice(camelIndex).toLowerCase()),
        key
      );
    }
    function cssToObj(key) {
      var match = key.match(/\-/),
        camelIndex = match ? match.index : null;
      if (camelIndex) {
        var start = key.slice(0, camelIndex),
          end = key.slice(camelIndex).slice(1),
          letter = end.charAt(0);
        (end = end.slice(1)),
          (key = start + (end = letter.toUpperCase() + end));
      }
      return key;
    }
    function setHTML() {
      (_obj.innerHTML = _style), (_needsUpdate = !1);
    }
    var _obj,
      _style,
      _needsUpdate,
      _this = this;
    Hydra.ready(function () {
      (_style = ""),
        ((_obj = document.createElement("style")).type = "text/css"),
        document.getElementsByTagName("head")[0].appendChild(_obj);
    }),
      (this._read = function () {
        return _style;
      }),
      (this._write = function (css) {
        (_style = css), _needsUpdate || ((_needsUpdate = !0), defer(setHTML));
      }),
      (this.style = function (selector, obj) {
        var s = selector + " {";
        for (var key in obj) {
          var prop = objToCSS(key),
            val = obj[key];
          "string" != typeof val && "opacity" != key && (val += "px"),
            (s += prop + ":" + val + "!important;");
        }
        (s += "}"), _this._write(_style + s);
      }),
      (this.get = function (selector, prop) {
        for (
          var values = new Object(),
            string = _obj.innerHTML.split(selector + " {"),
            i = 0;
          i < string.length;
          i++
        ) {
          var str = string[i];
          if (str.length) {
            var split = str.split("!important;");
            for (var j in split)
              if (split[j].includes(":")) {
                var fsplit = split[j].split(":");
                "px" == fsplit[1].slice(-2) &&
                  (fsplit[1] = Number(fsplit[1].slice(0, -2))),
                  (values[cssToObj(fsplit[0])] = fsplit[1]);
              }
          }
        }
        return prop ? values[prop] : values;
      }),
      (this.textSize = function ($obj) {
        var $clone = $obj.clone();
        $clone.css({
          position: "relative",
          cssFloat: "left",
          styleFloat: "left",
          marginTop: -99999,
          width: "",
          height: "",
        }),
          __body.addChild($clone);
        var width = $clone.div.offsetWidth,
          height = $clone.div.offsetHeight;
        return $clone.remove(), { width: width, height: height };
      }),
      (this.prefix = function (style) {
        return "" == _this.styles.vendor
          ? style.charAt(0).toLowerCase() + style.slice(1)
          : _this.styles.vendor + style;
      }),
      (this._toCSS = objToCSS);
  }, "Static"),
  Class(
    function HydraObject(_selector, _type, _exists, _useFragment) {
      (this._children = new LinkedList()),
        (this.__useFragment = _useFragment),
        this._initSelector(_selector, _type, _exists);
    },
    () => {
      var prototype = HydraObject.prototype;
      (prototype._initSelector = function (_selector, _type, _exists) {
        if (_selector && "string" != typeof _selector) this.div = _selector;
        else {
          var first = _selector ? _selector.charAt(0) : null,
            name = _selector ? _selector.slice(1) : null;
          if (
            ("." != first &&
              "#" != first &&
              ((name = _selector), (first = ".")),
            _exists)
          ) {
            if ("#" != first) throw "Hydra Selectors Require #ID";
            this.div = document.getElementById(name);
          } else
            (this._type = _type || "div"),
              "svg" == this._type
                ? ((this.div = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    this._type
                  )),
                  this.div.setAttributeNS(
                    "http://www.w3.org/2000/xmlns/",
                    "xmlns:xlink",
                    "http://www.w3.org/1999/xlink"
                  ))
                : ((this.div = document.createElement(this._type)),
                  first &&
                    ("#" == first
                      ? (this.div.id = name)
                      : (this.div.className = name)));
        }
        this.div.hydraObject = this;
      }),
        (prototype.add = function (child) {
          var div = this.div,
            _this = this,
            createFrag = function () {
              _this.__useFragment &&
                (_this._fragment ||
                  ((_this._fragment = document.createDocumentFragment()),
                  defer(function () {
                    if (!_this._fragment || !_this.div)
                      return (_this._fragment = null);
                    _this.div.appendChild(_this._fragment),
                      (_this._fragment = null);
                  })),
                (div = _this._fragment));
            };
          return (
            child.element && child.element instanceof HydraObject
              ? (createFrag(),
                div.appendChild(child.element.div),
                this._children.push(child.element),
                (child.element._parent = this),
                (child.element.div.parentNode = this.div))
              : child.div
              ? (createFrag(),
                div.appendChild(child.div),
                this._children.push(child),
                (child._parent = this),
                (child.div.parentNode = this.div))
              : child.nodeName &&
                (createFrag(),
                div.appendChild(child),
                (child.parentNode = this.div)),
            this
          );
        }),
        (prototype.clone = function () {
          return $(this.div.cloneNode(!0));
        }),
        (prototype.create = function (name, type) {
          var $obj = $(name, type);
          return this.add($obj), $obj;
        }),
        (prototype.empty = function () {
          for (var child = this._children.start(); child; )
            child && child.remove && child.remove(),
              (child = this._children.next());
          return (this.div.innerHTML = ""), this;
        }),
        (prototype.parent = function () {
          return this._parent;
        }),
        (prototype.children = function () {
          return this.div.children ? this.div.children : this.div.childNodes;
        }),
        (prototype.removeChild = function (object, keep) {
          try {
            object.div.parentNode.removeChild(object.div);
          } catch (e) {}
          keep || this._children.remove(object);
        }),
        (prototype.remove = prototype.destroy =
          function () {
            this.removed = !0;
            var parent = this._parent;
            parent &&
              !parent.removed &&
              parent.removeChild &&
              parent.removeChild(this, !0);
            for (var child = this._children.start(); child; )
              child && child.remove && child.remove(),
                (child = this._children.next());
            this._children.destroy(),
              (this.div.hydraObject = null),
              Utils.nullObject(this);
          }),
        (window.$ = function (selector, type, exists) {
          return new HydraObject(selector, type, exists);
        }),
        ($.fn = HydraObject.prototype);
    }
  ),
  ($.fn.text = function (text) {
    return void 0 !== text
      ? (this.__cacheText != text && (this.div.textContent = text),
        (this.__cacheText = text),
        this)
      : this.div.textContent;
  }),
  ($.fn.html = function (text, force) {
    return !text || text.includes("<") || force
      ? void 0 !== text
        ? ((this.div.innerHTML = text), this)
        : this.div.innerHTML
      : this.text(text);
  }),
  ($.fn.hide = function () {
    return (this.div.style.display = "none"), this;
  }),
  ($.fn.show = function () {
    return (this.div.style.display = ""), this;
  }),
  ($.fn.visible = function () {
    return (this.div.style.visibility = "visible"), this;
  }),
  ($.fn.invisible = function () {
    return (this.div.style.visibility = "hidden"), this;
  }),
  ($.fn.setZ = function (z) {
    return (this.div.style.zIndex = z), this;
  }),
  ($.fn.clearAlpha = function () {
    return (this.div.style.opacity = ""), this;
  }),
  ($.fn.size = function (w, h, noScale) {
    return (
      "string" == typeof w
        ? (void 0 === h ? (h = "100%") : "string" != typeof h && (h += "px"),
          (this.div.style.width = w),
          (this.div.style.height = h))
        : ((this.div.style.width = w + "px"),
          (this.div.style.height = h + "px"),
          noScale || (this.div.style.backgroundSize = w + "px " + h + "px")),
      (this.width = w),
      (this.height = h),
      this
    );
  }),
  ($.fn.mouseEnabled = function (bool) {
    return (this.div.style.pointerEvents = bool ? "auto" : "none"), this;
  }),
  ($.fn.fontStyle = function (family, size, color, style) {
    var font = {};
    return (
      family && (font.fontFamily = family),
      size && (font.fontSize = size),
      color && (font.color = color),
      style && (font.fontStyle = style),
      this.css(font),
      this
    );
  }),
  ($.fn.font = function (font) {
    return this.css("font", font), this;
  }),
  ($.fn.bg = function (src, x, y, repeat) {
    return src
      ? (src.includes(".") && (src = Assets.getPath(src)),
        src.includes(".")
          ? (this.div.style.backgroundImage = "url(" + src + ")")
          : (this.div.style.backgroundColor = src),
        void 0 !== x &&
          ((x = "number" == typeof x ? x + "px" : x),
          (y = "number" == typeof y ? y + "px" : y),
          (this.div.style.backgroundPosition = x + " " + y)),
        repeat &&
          ((this.div.style.backgroundSize = ""),
          (this.div.style.backgroundRepeat = repeat)),
        ("cover" != x && "contain" != x) ||
          ((this.div.style.backgroundSize = x),
          (this.div.style.backgroundPosition =
            void 0 !== y ? y + " " + repeat : "center")),
        this)
      : this;
  }),
  ($.fn.center = function (x, y, noPos) {
    var css = {};
    return (
      void 0 === x
        ? ((css.left = "50%"),
          (css.top = "50%"),
          (css.marginLeft = -this.width / 2),
          (css.marginTop = -this.height / 2))
        : (x && ((css.left = "50%"), (css.marginLeft = -this.width / 2)),
          y && ((css.top = "50%"), (css.marginTop = -this.height / 2))),
      noPos && (delete css.left, delete css.top),
      this.css(css),
      this
    );
  }),
  ($.fn.max = function (width, height) {
    let w, h;
    return (
      void 0 !== width &&
        ((w = "number" == typeof width ? width + "px" : width),
        (this.div.style.maxWidth = w)),
      void 0 !== height
        ? ((h = "number" == typeof height ? height + "px" : height),
          (this.div.style.maxHeight = h))
        : ((h = w), (this.div.style.maxHeight = h)),
      this
    );
  }),
  ($.fn.min = function (width, height) {
    let w, h;
    return (
      void 0 !== width &&
        ((w = "number" == typeof width ? width + "px" : width),
        (this.div.style.minWidth = w)),
      void 0 !== height
        ? ((h = "number" == typeof height ? height + "px" : height),
          (this.div.style.minHeight = h))
        : ((h = w), (this.div.style.minHeight = h)),
      this
    );
  }),
  ($.fn.flex = function (inline) {
    return (
      (this.div.style.display = inline ? "inline-flex" : "flex"),
      (this.div.style.justifyContent = "center"),
      (this.div.style.alignItems = "center"),
      this.div.classList.add("relative-children"),
      this
    );
  }),
  ($.fn.order = function (opts = {}) {
    let s = this.div.style;
    return (
      "none" === opts.flexWrap && (opts.flexWrap = "nowrap"),
      opts.direction && (s.flexDirection = opts.direction),
      opts.wrap && (s.flexWrap = opts.wrap),
      opts.order && (s.order = opts.order),
      this
    );
  }),
  ($.fn.align = function (opts = {}) {
    function flex(str, contentMode = !1) {
      return "start" === str
        ? "flex-start"
        : "end" === str
        ? "flex-end"
        : "between" === str
        ? contentMode
          ? "space-between"
          : "flex-between"
        : "around" === str
        ? contentMode
          ? "space-around"
          : "flex-around"
        : "none" === str
        ? "nowrap"
        : str;
    }
    let s = this.div.style;
    return (
      opts.justify && (s.justifyContent = flex(opts.justify)),
      opts.items && (s.alignItems = flex(opts.items)),
      opts.self && (s.alignSelf = flex(opts.self)),
      opts.content && (s.alignContent = flex(opts.content, !0)),
      this
    );
  }),
  ($.fn.flexibility = function (opts = {}) {
    let s = this.div.style;
    return (
      "undefined" !== opts.grow && (s.flexGrow = opts.grow),
      "undefined" !== opts.shrink && (s.flexGrow = opts.shrink),
      void 0 !== opts.basis &&
        (s.flexBasis =
          "number" == typeof opts.basis ? opts.basis + "px" : opts.basis),
      this
    );
  }),
  ($.fn.mask = function (arg) {
    let maskPrefix = "Moz" === CSS.styles.vendor ? "mask" : CSS.prefix("Mask");
    return (
      (this.div.style[maskPrefix] =
        (arg.includes(".") ? "url(" + arg + ")" : arg) + " no-repeat"),
      (this.div.style[maskPrefix + "Size"] = "contain"),
      this
    );
  }),
  ($.fn.blendMode = function (mode, bg) {
    return (
      bg
        ? (this.div.style["background-blend-mode"] = mode)
        : (this.div.style["mix-blend-mode"] = mode),
      this
    );
  }),
  ($.fn.css = function (obj, value) {
    if (("boolean" == typeof value && (value = null), "object" != typeof obj)) {
      if (value) return (this.div.style[obj] = value), this;
      var style = this.div.style[obj];
      if ("number" != typeof style) {
        if (!style) return !1;
        style.includes("px") && (style = Number(style.slice(0, -2))),
          "opacity" == obj &&
            (style = isNaN(Number(this.div.style.opacity))
              ? 1
              : Number(this.div.style.opacity));
      }
      return style || (style = 0), style;
    }
    TweenManager._clearCSSTween(this);
    for (var type in obj) {
      var val = obj[type];
      ("string" != typeof val && "number" != typeof val) ||
        ("string" != typeof val &&
          "opacity" != type &&
          "zIndex" != type &&
          (val += "px"),
        (this.div.style[type] = val));
    }
    return this;
  }),
  ($.fn.transform = function (props) {
    if (
      !(
        this.multiTween &&
        this.cssTweens &&
        this._cssTweens.length > 1 &&
        this.__transformTime &&
        Render.TIME - this.__transformTime < 15
      )
    ) {
      if (
        ((this.__transformTime = Render.TIME),
        TweenManager._clearCSSTween(this),
        Device.tween.css2d)
      ) {
        if (props)
          for (var key in props)
            "number" == typeof props[key] && (this[key] = props[key]);
        else props = this;
        var transformString = TweenManager._parseTransform(props);
        this.__transformCache != transformString &&
          ((this.div.style[CSS.styles.vendorTransform] = transformString),
          (this.__transformCache = transformString));
      }
      return this;
    }
  }),
  ($.fn.willChange = function (props) {
    if ("boolean" == typeof props) this._willChangeLock = !0 === props;
    else if (this._willChangeLock) return;
    var string = "string" == typeof props;
    (this._willChange && !string) || "null" == typeof props
      ? ((this._willChange = !1), (this.div.style["will-change"] = ""))
      : ((this._willChange = !0),
        (this.div.style["will-change"] = string
          ? props
          : CSS.transformProperty + ", opacity"));
  }),
  ($.fn.backfaceVisibility = function (visible) {
    this.div.style[CSS.prefix("BackfaceVisibility")] = visible
      ? "visible"
      : "hidden";
  }),
  ($.fn.enable3D = function (perspective, x, y) {
    return Device.tween.css3d
      ? ((this.div.style[CSS.prefix("TransformStyle")] = "preserve-3d"),
        perspective &&
          (this.div.style[CSS.prefix("Perspective")] = perspective + "px"),
        void 0 !== x &&
          ((x = "number" == typeof x ? x + "px" : x),
          (y = "number" == typeof y ? y + "px" : y),
          (this.div.style[CSS.prefix("PerspectiveOrigin")] = x + " " + y)),
        this)
      : this;
  }),
  ($.fn.disable3D = function () {
    return (
      (this.div.style[CSS.prefix("TransformStyle")] = ""),
      (this.div.style[CSS.prefix("Perspective")] = ""),
      this
    );
  }),
  ($.fn.transformPoint = function (x, y, z) {
    var origin = "";
    return (
      void 0 !== x && (origin += "number" == typeof x ? x + "px " : x + " "),
      void 0 !== y && (origin += "number" == typeof y ? y + "px " : y + " "),
      void 0 !== z && (origin += "number" == typeof z ? z + "px" : z),
      (this.div.style[CSS.prefix("TransformOrigin")] = origin),
      this
    );
  }),
  ($.fn.tween = function (props, time, ease, delay, callback, manual) {
    "boolean" == typeof delay
      ? ((manual = delay), (delay = 0), (callback = null))
      : "function" == typeof delay && ((callback = delay), (delay = 0)),
      "boolean" == typeof callback && ((manual = callback), (callback = null)),
      delay || (delay = 0);
    var usePromise = null;
    callback &&
      callback instanceof Promise &&
      ((usePromise = callback), (callback = callback.resolve));
    var tween = TweenManager._detectTween(
      this,
      props,
      time,
      ease,
      delay,
      callback,
      manual
    );
    return usePromise || tween;
  }),
  ($.fn.clearTransform = function () {
    return (
      "number" == typeof this.x && (this.x = 0),
      "number" == typeof this.y && (this.y = 0),
      "number" == typeof this.z && (this.z = 0),
      "number" == typeof this.scale && (this.scale = 1),
      "number" == typeof this.scaleX && (this.scaleX = 1),
      "number" == typeof this.scaleY && (this.scaleY = 1),
      "number" == typeof this.rotation && (this.rotation = 0),
      "number" == typeof this.rotationX && (this.rotationX = 0),
      "number" == typeof this.rotationY && (this.rotationY = 0),
      "number" == typeof this.rotationZ && (this.rotationZ = 0),
      "number" == typeof this.skewX && (this.skewX = 0),
      "number" == typeof this.skewY && (this.skewY = 0),
      (this.div.style[CSS.styles.vendorTransform] = ""),
      this
    );
  }),
  ($.fn.clearTween = function () {
    return (
      this._cssTween && this._cssTween.stop(),
      this._mathTween && this._mathTween.stop(),
      this
    );
  }),
  ($.fn.stopTween = function () {
    return (
      console.warn(".stopTween deprecated. use .clearTween instead"),
      this.clearTween()
    );
  }),
  ($.fn.keypress = function (callback) {
    this.div.onkeypress = function (e) {
      ((e = e || window.event).code = e.keyCode ? e.keyCode : e.charCode),
        callback && callback(e);
    };
  }),
  ($.fn.keydown = function (callback) {
    this.div.onkeydown = function (e) {
      ((e = e || window.event).code = e.keyCode), callback && callback(e);
    };
  }),
  ($.fn.keyup = function (callback) {
    this.div.onkeyup = function (e) {
      ((e = e || window.event).code = e.keyCode), callback && callback(e);
    };
  }),
  ($.fn.attr = function (attr, value) {
    if (attr && value)
      "" == value
        ? this.div.removeAttribute(attr)
        : this.div.setAttribute(attr, value);
    else if (attr) return this.div.getAttribute(attr);
    return this;
  }),
  ($.fn.val = function (value) {
    return void 0 === value ? this.div.value : ((this.div.value = value), this);
  }),
  ($.fn.change = function (callback) {
    var _this = this;
    "select" == this._type &&
      (this.div.onchange = function () {
        callback({ object: _this, value: _this.div.value || "" });
      });
  }),
  ($.fn.svgSymbol = function (id, width, height) {
    var config = SVG.getSymbolConfig(id),
      svgHTML =
        '<svg viewBox="0 0 ' +
        config.width +
        " " +
        config.height +
        '" width="' +
        width +
        '" height="' +
        height +
        '"><use xlink:href="#' +
        config.id +
        '" x="0" y="0" /></svg>';
    this.html(svgHTML, !0);
  }),
  ($.fn.overflowScroll = function (dir) {
    var x = !!dir.x,
      y = !!dir.y,
      overflow = {};
    ((!x && !y) || (x && y)) && (overflow.overflow = "auto"),
      !x &&
        y &&
        ((overflow.overflowY = "auto"), (overflow.overflowX = "hidden")),
      x &&
        !y &&
        ((overflow.overflowX = "auto"), (overflow.overflowY = "hidden")),
      Device.mobile &&
        ((overflow["-webkit-overflow-scrolling"] = "touch"),
        Mobile._addOverflowScroll(this)),
      this.css(overflow);
  }),
  ($.fn.removeOverflowScroll = function () {
    this.css({
      overflow: "hidden",
      overflowX: "",
      overflowY: "",
      "-webkit-overflow-scrolling": "",
    }),
      Device.mobile && Mobile._removeOverflowScroll(this);
  }),
  ($.fn.accessible = function (type = "label", tabIndex = -1) {
    switch ((tabIndex > -1 && this.attr("tabindex", tabIndex), type)) {
      case "label":
        this.attr("aria-label", this.div.textContent);
        break;
      case "hidden":
        this.attr("aria-hidden", !0);
    }
  }),
  ($.fn.tabIndex = function (tabIndex) {
    this.attr("tabindex", tabIndex);
  }),
  (function () {
    var windowsPointer = !!window.MSGesture,
      translateEvent = function (evt) {
        if (windowsPointer)
          switch (evt) {
            case "touchstart":
              return "pointerdown";
            case "touchmove":
              return "MSGestureChange";
            case "touchend":
              return "pointerup";
          }
        return evt;
      },
      convertTouchEvent = function (e) {
        var touchEvent = {};
        if (((touchEvent.x = 0), (touchEvent.y = 0), e.windowsPointer))
          return e;
        if (!e) return touchEvent;
        if (
          (e.touches || e.changedTouches
            ? e.touches.length
              ? ((touchEvent.x = e.touches[0].pageX),
                (touchEvent.y = e.touches[0].pageY))
              : ((touchEvent.x = e.changedTouches[0].pageX),
                (touchEvent.y = e.changedTouches[0].pageY))
            : ((touchEvent.x = e.pageX), (touchEvent.y = e.pageY)),
          Mobile.ScreenLock &&
            Mobile.ScreenLock.isActive &&
            Mobile.orientationSet &&
            Mobile.orientation !== Mobile.orientationSet)
        ) {
          if (90 == window.orientation || 0 === window.orientation) {
            var x = touchEvent.y;
            (touchEvent.y = touchEvent.x), (touchEvent.x = Stage.width - x);
          }
          if (-90 == window.orientation || 180 === window.orientation) {
            var y = touchEvent.x;
            (touchEvent.x = touchEvent.y), (touchEvent.y = Stage.height - y);
          }
        }
        return touchEvent;
      };
    ($.fn.click = function (callback) {
      var _this = this;
      return (
        this.div.addEventListener(
          translateEvent("click"),
          function click(e) {
            return (
              !!_this.div &&
              !Mouse._preventClicks &&
              ((e.object =
                "hit" == _this.div.className ? _this.parent() : _this),
              (e.action = "click"),
              e.pageX || ((e.pageX = e.clientX), (e.pageY = e.clientY)),
              callback && callback(e),
              void (Mouse.autoPreventClicks && Mouse.preventClicks()))
            );
          },
          !0
        ),
        (this.div.style.cursor = "pointer"),
        this
      );
    }),
      ($.fn.hover = function (callback) {
        function hover(e) {
          if (!_this.div) return !1;
          var time = performance.now(),
            original = e.toElement || e.relatedTarget;
          if (_time && time - _time < 5) return (_time = time), !1;
          switch (
            ((_time = time),
            (e.object = "hit" == _this.div.className ? _this.parent() : _this),
            e.type)
          ) {
            case "mouseout":
            case "mouseleave":
              e.action = "out";
              break;
            default:
              e.action = "over";
          }
          if (_over) {
            if (Mouse._preventClicks) return !1;
            if ("over" == e.action) return !1;
            if ("out" == e.action && isAChild(_this.div, original)) return !1;
            _over = !1;
          } else {
            if ("out" == e.action) return !1;
            _over = !0;
          }
          e.pageX || ((e.pageX = e.clientX), (e.pageY = e.clientY)),
            callback && callback(e);
        }
        function isAChild(div, object) {
          for (var len = div.children.length - 1, i = len; i > -1; i--)
            if (object == div.children[i]) return !0;
          for (i = len; i > -1; i--)
            if (isAChild(div.children[i], object)) return !0;
        }
        var _time,
          _this = this,
          _over = !1;
        return (
          this.div.addEventListener(translateEvent("mouseover"), hover, !0),
          this.div.addEventListener(translateEvent("mouseout"), hover, !0),
          this
        );
      }),
      ($.fn.press = function (callback) {
        function press(e) {
          if (!_this.div) return !1;
          switch (
            ((e.object = "hit" == _this.div.className ? _this.parent() : _this),
            e.type)
          ) {
            case "mousedown":
              e.action = "down";
              break;
            default:
              e.action = "up";
          }
          e.pageX || ((e.pageX = e.clientX), (e.pageY = e.clientY)),
            callback && callback(e);
        }
        var _this = this;
        return (
          this.div.addEventListener(translateEvent("mousedown"), press, !0),
          this.div.addEventListener(translateEvent("mouseup"), press, !0),
          this
        );
      }),
      ($.fn.bind = function (evt, callback) {
        function touchEvent(e) {
          windowsPointer &&
            target.msGesture &&
            "touchstart" == evt &&
            target.msGesture.addPointer(e.pointerId);
          var touch = convertTouchEvent(e);
          if (windowsPointer) {
            var windowsEvt = e;
            ((e = {}).x = Number(windowsEvt.pageX || windowsEvt.clientX)),
              (e.y = Number(windowsEvt.pageY || windowsEvt.clientY)),
              (e.target = windowsEvt.target),
              (e.currentTarget = windowsEvt.currentTarget),
              (e.path = []);
            for (var node = e.target; node; )
              e.path.push(node), (node = node.parentElement || null);
            e.windowsPointer = !0;
          } else (e.x = touch.x), (e.y = touch.y);
          for (var i = 0; i < _events.length; i++) {
            var ev = _events[i];
            ev.target == e.currentTarget && ev.callback(e);
          }
        }
        if (
          ((this._events = this._events || {}),
          windowsPointer && this == __window)
        )
          return Stage.bind(evt, callback);
        "touchstart" == evt
          ? Device.mobile ||
            (Device.touchCapable
              ? this.bind("mousedown", callback)
              : (evt = "mousedown"))
          : "touchmove" == evt
          ? (Device.mobile ||
              (Device.touchCapable
                ? this.bind("mousemove", callback)
                : (evt = "mousemove")),
            windowsPointer &&
              !this.div.msGesture &&
              ((this.div.msGesture = new MSGesture()),
              (this.div.msGesture.target = this.div)))
          : "touchend" == evt &&
            (Device.mobile ||
              (Device.touchCapable
                ? this.bind("mouseup", callback)
                : (evt = "mouseup"))),
          (this._events["bind_" + evt] = this._events["bind_" + evt] || []);
        var _events = this._events["bind_" + evt],
          e = {},
          target = this.div;
        return (
          (e.callback = callback),
          (e.target = this.div),
          _events.push(e),
          this._events["fn_" + evt] ||
            ((this._events["fn_" + evt] = touchEvent),
            this.div.addEventListener(translateEvent(evt), touchEvent, !0)),
          this
        );
      }),
      ($.fn.unbind = function (evt, callback) {
        if (
          ((this._events = this._events || {}),
          windowsPointer && this == __window)
        )
          return Stage.unbind(evt, callback);
        "touchstart" == evt
          ? Device.mobile ||
            (Device.touchCapable
              ? this.unbind("mousedown", callback)
              : (evt = "mousedown"))
          : "touchmove" == evt
          ? Device.mobile ||
            (Device.touchCapable
              ? this.unbind("mousemove", callback)
              : (evt = "mousemove"))
          : "touchend" == evt &&
            (Device.mobile ||
              (Device.touchCapable
                ? this.unbind("mouseup", callback)
                : (evt = "mouseup")));
        var _events = this._events["bind_" + evt];
        if (!_events) return this;
        for (var i = 0; i < _events.length; i++)
          _events[i].callback == callback && _events.splice(i, 1);
        return (
          this._events["fn_" + evt] &&
            !_events.length &&
            (this.div.removeEventListener(
              translateEvent(evt),
              this._events["fn_" + evt],
              !Device.mobile || { passive: !0 }
            ),
            (this._events["fn_" + evt] = null)),
          this
        );
      }),
      ($.fn.interact = function (
        overCallback,
        clickCallback,
        seoLink,
        seoText
      ) {
        function clicked(e) {
          clickCallback && Render.TIME - time > 100 && clickCallback(e),
            (time = Render.TIME);
        }
        this.hit ||
          ((this.hit = $(".hit", seoLink ? "a" : void 0)),
          this.hit.css({
            width: "100%",
            height: "100%",
            zIndex: 99999,
            top: 0,
            left: 0,
            position: "absolute",
          }),
          this.add(this.hit),
          seoLink &&
            (this.hit.attr("href", Hydra.absolutePath(seoLink)),
            this.hit.text(seoText || this.div.textContent),
            this.hit.css({ fontSize: 0 }),
            this.hit.accessible(),
            (this.hit.div.onfocus = (_) => overCallback({ action: "over" })),
            (this.hit.div.onblur = (_) => overCallback({ action: "out" })),
            (this.hit.div.onclick = (e) => {
              e.preventDefault(), clicked(e);
            })));
        let time = Render.TIME;
        Device.mobile
          ? this.hit.touchClick(overCallback, clicked).click(clicked)
          : this.hit.hover(overCallback).click(clicked);
      }),
      ($.fn.touchSwipe = function (callback, distance) {
        function touchMove(e) {
          if (!_this.div) return !1;
          if (_moving) {
            var touch = convertTouchEvent(e),
              dx = _startX - touch.x,
              dy = _startY - touch.y;
            (_move.direction = null),
              (_move.moving = null),
              (_move.x = null),
              (_move.y = null),
              (_move.evt = e),
              Math.abs(dx) >= _distance
                ? (touchEnd(), (_move.direction = dx > 0 ? "left" : "right"))
                : Math.abs(dy) >= _distance
                ? (touchEnd(), (_move.direction = dy > 0 ? "up" : "down"))
                : ((_move.moving = !0), (_move.x = dx), (_move.y = dy)),
              callback && callback(_move, e);
          }
        }
        function touchEnd(e) {
          if (!_this.div) return !1;
          (_startX = _startY = _moving = !1),
            _this.div.removeEventListener(
              translateEvent("touchmove"),
              touchMove
            );
        }
        if (!window.addEventListener) return this;
        var _startX,
          _startY,
          _this = this,
          _distance = distance || 75,
          _moving = !1,
          _move = {};
        return (
          Device.mobile &&
            (this.div.addEventListener(
              translateEvent("touchstart"),
              function touchStart(e) {
                var touch = convertTouchEvent(e);
                if (!_this.div) return !1;
                1 == e.touches.length &&
                  ((_startX = touch.x),
                  (_startY = touch.y),
                  (_moving = !0),
                  _this.div.addEventListener(
                    translateEvent("touchmove"),
                    touchMove,
                    { passive: !0 }
                  ));
              },
              { passive: !0 }
            ),
            this.div.addEventListener(translateEvent("touchend"), touchEnd, {
              passive: !0,
            }),
            this.div.addEventListener(translateEvent("touchcancel"), touchEnd, {
              passive: !0,
            })),
          this
        );
      }),
      ($.fn.touchClick = function (hover, click) {
        function setTouch(e) {
          var touch = convertTouchEvent(e);
          (e.touchX = touch.x),
            (e.touchY = touch.y),
            (_start.x = e.touchX),
            (_start.y = e.touchY);
        }
        if (!window.addEventListener) return this;
        var _time,
          _move,
          _this = this,
          _start = {};
        return (
          Device.mobile &&
            (this.div.addEventListener(
              translateEvent("touchstart"),
              function touchStart(e) {
                if (!_this.div) return !1;
                (_time = performance.now()),
                  (e.action = "over"),
                  (e.object =
                    "hit" == _this.div.className ? _this.parent() : _this),
                  setTouch(e),
                  hover && !_move && hover(e);
              },
              { passive: !0 }
            ),
            this.div.addEventListener(
              translateEvent("touchend"),
              function touchEnd(e) {
                if (!_this.div) return !1;
                var time = performance.now();
                if (
                  ((e.object =
                    "hit" == _this.div.className ? _this.parent() : _this),
                  setTouch(e),
                  _time && time - _time < 750)
                ) {
                  if (Mouse._preventClicks) return !1;
                  click &&
                    !_move &&
                    ((e.action = "click"),
                    click && !_move && click(e),
                    Mouse.autoPreventClicks && Mouse.preventClicks());
                }
                hover && ((e.action = "out"), Mouse._preventFire || hover(e)),
                  (_move = !1);
              },
              { passive: !0 }
            )),
          this
        );
      });
  })(),
  Class(function Element(type = "div") {
    Inherit(this, Component);
    var name = Utils.getConstructorName(this);
    (this.__element = !0),
      (this.element = $("." + name, type)),
      (this.element.__useFragment = !0),
      (this.destroy = function () {
        this.element &&
          this.element.remove &&
          (this.element = this.element.remove()),
          this._destroy && this._destroy();
      });
  }),
  Hydra.ready(() => {
    (TweenManager.Transforms = [
      "scale",
      "scaleX",
      "scaleY",
      "x",
      "y",
      "z",
      "rotation",
      "rotationX",
      "rotationY",
      "rotationZ",
      "skewX",
      "skewY",
      "perspective",
    ]),
      (TweenManager.CubicEases = [
        {
          name: "easeOutCubic",
          curve: "cubic-bezier(0.215, 0.610, 0.355, 1.000)",
        },
        {
          name: "easeOutQuad",
          curve: "cubic-bezier(0.250, 0.460, 0.450, 0.940)",
        },
        {
          name: "easeOutQuart",
          curve: "cubic-bezier(0.165, 0.840, 0.440, 1.000)",
        },
        {
          name: "easeOutQuint",
          curve: "cubic-bezier(0.230, 1.000, 0.320, 1.000)",
        },
        {
          name: "easeOutSine",
          curve: "cubic-bezier(0.390, 0.575, 0.565, 1.000)",
        },
        {
          name: "easeOutExpo",
          curve: "cubic-bezier(0.190, 1.000, 0.220, 1.000)",
        },
        {
          name: "easeOutCirc",
          curve: "cubic-bezier(0.075, 0.820, 0.165, 1.000)",
        },
        {
          name: "easeOutBack",
          curve: "cubic-bezier(0.175, 0.885, 0.320, 1.275)",
        },
        {
          name: "easeInCubic",
          curve: "cubic-bezier(0.550, 0.055, 0.675, 0.190)",
        },
        {
          name: "easeInQuad",
          curve: "cubic-bezier(0.550, 0.085, 0.680, 0.530)",
        },
        {
          name: "easeInQuart",
          curve: "cubic-bezier(0.895, 0.030, 0.685, 0.220)",
        },
        {
          name: "easeInQuint",
          curve: "cubic-bezier(0.755, 0.050, 0.855, 0.060)",
        },
        {
          name: "easeInSine",
          curve: "cubic-bezier(0.470, 0.000, 0.745, 0.715)",
        },
        {
          name: "easeInCirc",
          curve: "cubic-bezier(0.600, 0.040, 0.980, 0.335)",
        },
        {
          name: "easeInBack",
          curve: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
        },
        {
          name: "easeInOutCubic",
          curve: "cubic-bezier(0.645, 0.045, 0.355, 1.000)",
        },
        {
          name: "easeInOutQuad",
          curve: "cubic-bezier(0.455, 0.030, 0.515, 0.955)",
        },
        {
          name: "easeInOutQuart",
          curve: "cubic-bezier(0.770, 0.000, 0.175, 1.000)",
        },
        {
          name: "easeInOutQuint",
          curve: "cubic-bezier(0.860, 0.000, 0.070, 1.000)",
        },
        {
          name: "easeInOutSine",
          curve: "cubic-bezier(0.445, 0.050, 0.550, 0.950)",
        },
        {
          name: "easeInOutExpo",
          curve: "cubic-bezier(1.000, 0.000, 0.000, 1.000)",
        },
        {
          name: "easeInOutCirc",
          curve: "cubic-bezier(0.785, 0.135, 0.150, 0.860)",
        },
        {
          name: "easeInOutBack",
          curve: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
        },
        { name: "easeInOut", curve: "cubic-bezier(.42,0,.58,1)" },
        { name: "linear", curve: "linear" },
      ]),
      (TweenManager.useCSSTrans = function (props, ease, object) {
        return (
          !props.math &&
          ("string" != typeof ease || !ease.includes(["Elastic", "Bounce"])) &&
          !object.multiTween &&
          !TweenManager._inspectEase(ease).path &&
          !!Device.tween.transition
        );
      }),
      (TweenManager._detectTween = function (
        object,
        props,
        time,
        ease,
        delay,
        callback
      ) {
        return TweenManager.useCSSTrans(props, ease, object)
          ? new CSSTransition(object, props, time, ease, delay, callback)
          : new FrameTween(object, props, time, ease, delay, callback);
      }),
      (TweenManager._parseTransform = function (props) {
        var transforms = "",
          translate = "";
        if (
          (props.perspective > 0 &&
            (transforms += "perspective(" + props.perspective + "px)"),
          void 0 !== props.x || void 0 !== props.y || void 0 !== props.z)
        ) {
          var x = props.x || 0,
            y = props.y || 0,
            z = props.z || 0;
          (translate +=
            x +
            ("string" == typeof props.x &&
            (props.x.includes("%") ||
              props.x.includes("vw") ||
              props.x.includes("vh"))
              ? ""
              : "px") +
            ", "),
            (translate +=
              y +
              ("string" == typeof props.y &&
              (props.y.includes("%") ||
                props.y.includes("vw") ||
                props.y.includes("vh"))
                ? ""
                : "px")),
            Device.tween.css3d
              ? (transforms +=
                  "translate3d(" + (translate += ", " + z + "px") + ")")
              : (transforms += "translate(" + translate + ")");
        }
        return (
          void 0 !== props.scale
            ? (transforms += "scale(" + props.scale + ")")
            : (void 0 !== props.scaleX &&
                (transforms += "scaleX(" + props.scaleX + ")"),
              void 0 !== props.scaleY &&
                (transforms += "scaleY(" + props.scaleY + ")")),
          void 0 !== props.rotation &&
            (transforms += "rotate(" + props.rotation + "deg)"),
          void 0 !== props.rotationX &&
            (transforms += "rotateX(" + props.rotationX + "deg)"),
          void 0 !== props.rotationY &&
            (transforms += "rotateY(" + props.rotationY + "deg)"),
          void 0 !== props.rotationZ &&
            (transforms += "rotateZ(" + props.rotationZ + "deg)"),
          void 0 !== props.skewX &&
            (transforms += "skewX(" + props.skewX + "deg)"),
          void 0 !== props.skewY &&
            (transforms += "skewY(" + props.skewY + "deg)"),
          transforms
        );
      }),
      (TweenManager._clearCSSTween = function (obj) {
        obj &&
          !obj._cssTween &&
          obj.div._transition &&
          !obj.persistTween &&
          ((obj.div.style[CSS.styles.vendorTransition] = ""),
          (obj.div._transition = !1),
          (obj._cssTween = null));
      }),
      (TweenManager._isTransform = function (key) {
        return TweenManager.Transforms.indexOf(key) > -1;
      }),
      (TweenManager._getAllTransforms = function (object) {
        for (
          var obj = {}, i = TweenManager.Transforms.length - 1;
          i > -1;
          i--
        ) {
          var tf = TweenManager.Transforms[i],
            val = object[tf];
          0 !== val && "number" == typeof val && (obj[tf] = val);
        }
        return obj;
      });
    const prefix = (function () {
      let pre = "",
        dom = "";
      try {
        var styles = window.getComputedStyle(document.documentElement, "");
        return (
          (pre = (Array.prototype.slice
            .call(styles)
            .join("")
            .match(/-(moz|webkit|ms)-/) ||
            ("" === styles.OLink && ["", "o"]))[1]),
          (dom = "WebKit|Moz|MS|O".match(new RegExp("(" + pre + ")", "i"))[1]),
          {
            unprefixed:
              "ie" == Device.system.browser && !Device.detect("msie 9"),
            dom: dom,
            lowercase: pre,
            css: "-" + pre + "-",
            js:
              ("ie" == Device.system.browser ? pre[0] : pre[0].toUpperCase()) +
              pre.substr(1),
          }
        );
      } catch (e) {
        return { unprefixed: !0, dom: "", lowercase: "", css: "", js: "" };
      }
    })();
    (CSS.styles = {}),
      (CSS.styles.vendor = prefix.unprefixed ? "" : prefix.js),
      (CSS.styles.vendorTransition = CSS.styles.vendor.length
        ? CSS.styles.vendor + "Transition"
        : "transition"),
      (CSS.styles.vendorTransform = CSS.styles.vendor.length
        ? CSS.styles.vendor + "Transform"
        : "transform"),
      (CSS.vendor = prefix.css),
      (CSS.transformProperty = (function () {
        switch (prefix.lowercase) {
          case "moz":
            return "-moz-transform";
          case "webkit":
            return "-webkit-transform";
          case "o":
            return "-o-transform";
          case "ms":
            return "-ms-transform";
          default:
            return "transform";
        }
      })()),
      (CSS.tween = {}),
      (CSS.tween.complete = prefix.unprefixed
        ? "transitionend"
        : prefix.lowercase + "TransitionEnd");
  }),
  Class(function CSSTransition(
    _object,
    _props,
    _time,
    _ease,
    _delay,
    _callback
  ) {
    function killed() {
      return !_this || _this.kill || !_object || !_object.div;
    }
    function initProperties() {
      var transform = TweenManager._getAllTransforms(_object),
        properties = [];
      for (var key in _props)
        TweenManager._isTransform(key)
          ? ((transform.use = !0),
            (transform[key] = _props[key]),
            delete _props[key])
          : ("number" == typeof _props[key] || key.includes(["-", "color"])) &&
            properties.push(key);
      transform.use &&
        (properties.push(CSS.transformProperty), delete transform.use),
        (_transformProps = transform),
        (_transitionProps = properties);
    }
    async function initCSSTween(values) {
      if (!killed()) {
        _object._cssTween && (_object._cssTween.kill = !0),
          (_object._cssTween = _this),
          (_object.div._transition = !0);
        var strings = buildStrings(_time, _ease, _delay);
        _object.willChange(strings.props);
        var time = values ? values.time : _time,
          delay = values ? values.delay : _delay,
          props = values ? values.props : _props,
          transformProps = values ? values.transform : _transformProps;
        if (
          ((_this.time = _time),
          (_this.delay = _delay),
          await defer(),
          await defer(),
          !killed())
        ) {
          if (
            ((_object.div.style[CSS.styles.vendorTransition] =
              strings.transition),
            (_this.playing = !0),
            "safari" == Device.system.browser)
          ) {
            if (
              (Device.system.browserVersion < 11 && (await defer()), killed())
            )
              return;
            _object.css(props), _object.transform(transformProps);
          } else _object.css(props), _object.transform(transformProps);
          Timer.create(function () {
            killed() ||
              (clearCSSTween(),
              _callback && _callback(),
              _this.completePromise && _this.completePromise.resolve());
          }, time + delay);
        }
      }
    }
    function buildStrings(time, ease, delay) {
      for (
        var props = "", str = "", len = _transitionProps.length, i = 0;
        i < len;
        i++
      ) {
        var transitionProp = _transitionProps[i];
        (props += (props.length ? ", " : "") + transitionProp),
          (str +=
            (str.length ? ", " : "") +
            transitionProp +
            " " +
            time +
            "ms " +
            TweenManager._getEase(ease) +
            " " +
            delay +
            "ms");
      }
      return { props: props, transition: str };
    }
    function clearCSSTween() {
      killed() ||
        ((_this.playing = !1),
        (_object._cssTween = null),
        _object.willChange(null),
        (_object = _props = null),
        Utils.nullObject(this));
    }
    const _this = this;
    let _transformProps, _transitionProps;
    (this.playing = !0),
      (function () {
        if ("number" != typeof _time)
          throw "CSSTween Requires object, props, time, ease";
        initProperties(), initCSSTween();
      })(),
      (this.stop = function () {
        this.playing &&
          ((this.kill = !0),
          (this.playing = !1),
          (_object.div.style[CSS.styles.vendorTransition] = ""),
          (_object.div._transition = !1),
          _object.willChange(null),
          (_object._cssTween = null),
          Utils.nullObject(this));
      }),
      (this.onComplete = function (callback) {
        return (_callback = callback), this;
      }),
      (this.promise = function () {
        return (
          (_this.completePromise = Promise.create()), _this.completePromise
        );
      });
  }),
  Class(function FrameTween(
    _object,
    _props,
    _time,
    _ease,
    _delay,
    _callback,
    _manual
  ) {
    function killed() {
      return _this.kill || !_object || !_object.div;
    }
    function initValues() {
      _props.math && delete _props.math,
        Device.tween.transition &&
          _object.div._transition &&
          ((_object.div.style[CSS.styles.vendorTransition] = ""),
          (_object.div._transition = !1)),
        (_this.time = _time),
        (_this.delay = _delay),
        (_endValues = {}),
        (_transformEnd = {}),
        (_transformStart = {}),
        (_startValues = {}),
        _object.multiTween ||
          (void 0 === _props.x && (_props.x = _object.x),
          void 0 === _props.y && (_props.y = _object.y),
          void 0 === _props.z && (_props.z = _object.z));
      for (var key in _props)
        if (key.includes(["damping", "spring"]))
          (_endValues[key] = _props[key]), (_transformEnd[key] = _props[key]);
        else if (TweenManager._isTransform(key))
          (_isTransform = !0),
            (_transformStart[key] = _object[key] || ("scale" == key ? 1 : 0)),
            (_transformEnd[key] = _props[key]);
        else {
          _isCSS = !0;
          var v = _props[key];
          "string" == typeof v
            ? (_object.div.style[key] = v)
            : "number" == typeof v &&
              ((_startValues[key] = Number(_object.css(key))),
              (_endValues[key] = v));
        }
    }
    function startTween() {
      !_object._cssTween ||
        _manual ||
        _object.multiTween ||
        (_object._cssTween.kill = !0),
        (_this.time = _time),
        (_this.delay = _delay),
        _object.multiTween &&
          (_object._cssTweens || (_object._cssTweens = []),
          _object._cssTweens.push(_this)),
        (_object._cssTween = _this),
        (_this.playing = !0),
        (_props = copy(_startValues)),
        (_transformProps = copy(_transformStart)),
        _isCSS &&
          (_cssTween = tween(
            _props,
            _endValues,
            _time,
            _ease,
            _delay,
            null,
            _manual
          )
            .onUpdate(update)
            .onComplete(tweenComplete)),
        _isTransform &&
          (_transformTween = tween(
            _transformProps,
            _transformEnd,
            _time,
            _ease,
            _delay,
            null,
            _manual
          )
            .onComplete(_isCSS ? null : tweenComplete)
            .onUpdate(_isCSS ? null : update));
    }
    function copy(obj) {
      let newObj = {};
      for (let key in obj)
        "number" == typeof obj[key] && (newObj[key] = obj[key]);
      return newObj;
    }
    function clear() {
      _object._cssTweens && _object._cssTweens.remove(_this),
        (_this.playing = !1),
        (_object._cssTween = null),
        (_object = _props = null);
    }
    function update() {
      if (!killed()) {
        if ((_isCSS && _object.css(_props), _isTransform))
          if (_object.multiTween) {
            for (var key in _transformProps)
              "number" == typeof _transformProps[key] &&
                (_object[key] = _transformProps[key]);
            _object.transform();
          } else _object.transform(_transformProps);
        _update && _update();
      }
    }
    function tweenComplete() {
      _this.playing &&
        (clear(),
        _callback && _callback(),
        _this.completePromise && _this.completePromise.resolve());
    }
    var _endValues,
      _transformEnd,
      _transformStart,
      _startValues,
      _isTransform,
      _isCSS,
      _transformProps,
      _cssTween,
      _transformTween,
      _update,
      _this = this;
    (this.playing = !0),
      (_this.object = _object),
      (_this.props = _props),
      (_this.time = _time),
      (_this.ease = _ease),
      (_this.delay = _delay),
      defer(function () {
        if (_this.overrideValues) {
          let values = _this.overrideValues(
            _this,
            _object,
            _props,
            _time,
            _ease,
            _delay
          );
          values &&
            ((_this.props = _props = values.props || _props),
            (_this.time = _time = values.time || _time),
            (_this.ease = _ease = values.ease || _ease),
            (_this.delay = _delay = values.delay || _delay));
        }
        if (
          ("object" == typeof _ease && (_ease = "easeOutCubic"),
          _object && _props)
        ) {
          if (((_this.object = _object), "number" != typeof _time))
            throw "FrameTween Requires object, props, time, ease";
          initValues(), startTween();
        }
      }),
      (this.stop = function () {
        this.playing &&
          (_cssTween && _cssTween.stop && _cssTween.stop(),
          _transformTween && _transformTween.stop && _transformTween.stop(),
          clear());
      }),
      (this.interpolate = function (elapsed) {
        _cssTween && _cssTween.interpolate(elapsed),
          _transformTween && _transformTween.interpolate(elapsed),
          update();
      }),
      (this.getValues = function () {
        return {
          start: _startValues,
          transformStart: _transformStart,
          end: _endValues,
          transformEnd: _transformEnd,
        };
      }),
      (this.setEase = function (ease) {
        _cssTween && _cssTween.setEase(ease),
          _transformTween && _transformTween.setEase(ease);
      }),
      (this.onUpdate = function () {
        return this;
      }),
      (this.onComplete = function (callback) {
        return (_callback = callback), this;
      }),
      (this.promise = function () {
        return (
          _this.completePromise || (_this.completePromise = Promise.create()),
          _this.completePromise
        );
      });
  }),
  Class(
    function Interaction(_object) {
      function Vec2() {
        (this.x = 0),
          (this.y = 0),
          (this.length = function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          });
      }
      function loop() {
        _moved++ > 10 && (_this.velocity.x = _this.velocity.y = 0);
      }
      function addHandlers() {
        _object == Stage || _object == __window
          ? Interaction.bind("touchstart", down)
          : _object.bind("touchstart", down),
          Interaction.bind("touchmove", move),
          Interaction.bind("touchend", up);
      }
      function down(e) {
        (_this.isTouching = !0),
          e.touches &&
            "number" == typeof e.touches[0].force &&
            (e.force = e.touches[0].force),
          (_this.x = e.x),
          (_this.y = e.y),
          (_this.hold.x = _this.last.x = e.x),
          (_this.hold.y = _this.last.y = e.y),
          (_this.delta.x = _this.move.x = _this.velocity.x = 0),
          (_this.delta.y = _this.move.y = _this.velocity.y = 0),
          (_distance = 0),
          _this.events.fire(Interaction.START, e, !0),
          (_timeDown = _timeMove = Render.TIME);
      }
      function move(e) {
        _this.isTouching &&
          ((_this.move.x = e.x - _this.hold.x),
          (_this.move.y = e.y - _this.hold.y)),
          e.touches &&
            "number" == typeof e.touches[0].force &&
            (e.force = e.touches[0].force),
          (_this.x = e.x),
          (_this.y = e.y),
          (_this.delta.x = e.x - _this.last.x),
          (_this.delta.y = e.y - _this.last.y),
          (_this.last.x = e.x),
          (_this.last.y = e.y),
          (_moved = 0),
          (_distance += _this.delta.length());
        let delta = Render.TIME - (_timeMove || Render.TIME);
        if (((_timeMove = Render.TIME), delta > 0.01)) {
          let velocity = _vec2Pool.get();
          (velocity.x = Math.abs(_this.delta.x) / delta),
            (velocity.y = Math.abs(_this.delta.y) / delta),
            _velocity.push(velocity),
            _velocity.length > 5 && _vec2Pool.put(_velocity.shift());
        }
        _this.velocity.x = _this.velocity.y = 0;
        for (let i = 0; i < _velocity.length; i++)
          (_this.velocity.x += _velocity[i].x),
            (_this.velocity.y += _velocity[i].y);
        (_this.velocity.x /= _velocity.length),
          (_this.velocity.y /= _velocity.length),
          (_this.velocity.x = _this.velocity.x || 0),
          (_this.velocity.y = _this.velocity.y || 0),
          _this.events.fire(Interaction.MOVE, e, !0),
          _this.isTouching && _this.events.fire(Interaction.DRAG, e, !0);
      }
      function up(e) {
        _this.isTouching &&
          ((_this.isTouching = !1),
          (_this.move.x = 0),
          (_this.move.y = 0),
          Math.max(0.001, Render.TIME - (_timeMove || Render.TIME)) > 100 &&
            ((_this.delta.x = 0), (_this.delta.y = 0)),
          _distance < 20 &&
            Render.TIME - _timeDown < 2e3 &&
            _this.events.fire(Interaction.CLICK, e, !0),
          _this.events.fire(Interaction.END, e, !0),
          Device.mobile && (_this.velocity.x = _this.velocity.y = 0));
      }
      Inherit(this, Events);
      const _this = this;
      var _velocity = [],
        _moved = 0,
        _vec2Pool = new ObjectPool(Vec2, 10);
      (this.x = 0),
        (this.y = 0),
        (this.hold = new Vec2()),
        (this.last = new Vec2()),
        (this.delta = new Vec2()),
        (this.move = new Vec2()),
        (this.velocity = new Vec2());
      let _distance, _timeDown, _timeMove;
      !(function () {
        if (!_object instanceof HydraObject)
          throw "Interaction.Input requires a HydraObject";
        addHandlers(), Render.start(loop);
      })(),
        (this.onDestroy = function () {
          Interaction.unbind("touchstart", down),
            Interaction.unbind("touchmove", move),
            Interaction.unbind("touchend", up),
            Render.stop(loop),
            _object && _object.unbind && _object.unbind("touchstart", down);
        });
    },
    () => {
      function touchMove(e) {
        _events.touchmove.forEach((c) => c(e));
      }
      function touchStart(e) {
        _events.touchstart.forEach((c) => c(e));
      }
      function touchEnd(e) {
        _events.touchend.forEach((c) => c(e));
      }
      Namespace(Interaction),
        (Interaction.CLICK = "interaction_click"),
        (Interaction.START = "interaction_start"),
        (Interaction.MOVE = "interaction_move"),
        (Interaction.DRAG = "interaction_drag"),
        (Interaction.END = "interaction_end");
      const _events = { touchstart: [], touchmove: [], touchend: [] };
      Hydra.ready(async () => {
        await defer(),
          __window.bind("touchstart", touchStart),
          __window.bind("touchmove", touchMove),
          __window.bind("touchend", touchEnd),
          __window.bind("touchcancel", touchEnd),
          __window.bind("contextmenu", touchEnd);
      }),
        (Interaction.bind = function (evt, callback) {
          _events[evt].push(callback);
        }),
        (Interaction.unbind = function (evt, callback) {
          _events[evt].remove(callback);
        });
    }
  ),
  Class(function Mouse() {
    function init() {
      (_this.input = new Interaction(__window)),
        _this.events.sub(_this.input, Interaction.START, update),
        _this.events.sub(_this.input, Interaction.MOVE, update),
        _this.events.sub(_this.input, Interaction.END, end),
        (_this.hold = _this.input.hold),
        (_this.last = _this.input.last),
        (_this.delta = _this.input.delta),
        (_this.move = _this.input.move),
        (_this.velocity = _this.input.velocity),
        defer(() => {
          _this.events.sub(Events.RESIZE, resize), resize();
        });
    }
    function update(e) {
      (_this.x = e.x),
        (_this.y = e.y),
        Stage.width &&
          Stage.height &&
          ((_this.normal.x = e.x / Stage.width - _offset.x),
          (_this.normal.y = e.y / Stage.height - _offset.y),
          (_this.tilt.x = 2 * _this.normal.x - 1),
          (_this.tilt.y = 1 - 2 * _this.normal.y),
          (_this.inverseNormal.x = _this.normal.x),
          (_this.inverseNormal.y = 1 - _this.normal.y));
    }
    function end(e) {
      Device.mobile && _this.resetOnRelease && update(_this.resetOnRelease);
    }
    function resize() {
      Stage.css("top") && (_offset.y = Stage.css("top") / Stage.height),
        Stage.css("left") && (_offset.x = Stage.css("left") / Stage.width);
    }
    Inherit(this, Events);
    const _this = this;
    (this.x = 0),
      (this.y = 0),
      (this.normal = { x: 0, y: 0 }),
      (this.tilt = { x: 0, y: 0 }),
      (this.inverseNormal = { x: 0, y: 0 }),
      (this.resetOnRelease = !1);
    const _offset = { x: 0, y: 0 };
    Hydra.ready(init);
  }, "Static"),
  Class(function Mobile() {
    function addHandlers() {
      _this.events.sub(Events.RESIZE, resize),
        Device.mobile.native ||
          window.addEventListener("touchstart", preventNativeScroll, {
            passive: !1,
          });
    }
    function preventNativeScroll(e) {
      if (_this.isAllowNativeScroll) return;
      let target = e.target;
      if (
        "INPUT" == target.nodeName ||
        "TEXTAREA" == target.nodeName ||
        "SELECT" == target.nodeName ||
        "A" == target.nodeName
      )
        return;
      let prevent = !0;
      for (; target.parentNode && prevent; )
        target._scrollParent && (prevent = !1), (target = target.parentNode);
      prevent && e.preventDefault();
    }
    function resize() {
      updateOrientation(),
        checkResizeRefresh(),
        _this.isAllowNativeScroll || (document.body.scrollTop = 0);
    }
    function updateOrientation() {
      (_this.orientation =
        Stage.width > Stage.height ? "landscape" : "portrait"),
        _this.orientationSet &&
          (window.Fullscreen.isOpen || Device.mobile.pwa) &&
          window.screen &&
          window.screen.orientation &&
          window.screen.orientation.lock(_this.orientationSet);
    }
    Inherit(this, Component), Namespace(this);
    const _this = this;
    Hydra.ready(() => {
      Device.mobile &&
        (addHandlers(),
        "safari" != Device.system.browser ||
          Device.mobile.native ||
          (__body.css({ height: "100%" }).div.scrollTop = 0),
        Device.mobile.native && Stage.css({ width: "100vw", height: "100vh" }));
    });
    const checkResizeRefresh = (function () {
      let _lastWidth;
      return function () {
        _this.isPreventResizeReload ||
          (_lastWidth != Stage.width &&
            ((_lastWidth = Stage.width),
            ("ios" === Device.system.os ||
              ("android" == Device.system.os && Device.system.version >= 7)) &&
              (!Device.mobile.tablet ||
                Math.max(Stage.width, Stage.height) > 800 ||
                window.location.reload())));
      };
    })();
    (this.vibrate = function (duration) {
      navigator.vibrate && navigator.vibrate(duration);
    }),
      (this.fullscreen = function () {
        if (
          Device.mobile &&
          !Device.mobile.native &&
          !Device.mobile.pwa &&
          !Dev.emulator
        ) {
          if (!window.Fullscreen)
            throw "Mobile.fullscreen requires Fullscreen module";
          "android" === Device.system.os &&
            (__window.bind("touchend", () => {
              Fullscreen.open();
            }),
            _this.ScreenLock && _this.ScreenLock.isActive && window.onresize());
        }
      }),
      (this.setOrientation = function (orientation, isForce) {
        if (_this.System && _this.NativeCore.active)
          return (_this.System.orientation =
            _this.System[orientation.toUpperCase()]);
        if (
          ((_this.orientationSet = orientation), updateOrientation(), isForce)
        ) {
          if (!_this.ScreenLock)
            throw "Mobile.setOrientation isForce argument requires ScreenLock module";
          "any" === orientation
            ? _this.ScreenLock.unlock()
            : _this.ScreenLock.lock();
        }
      }),
      (this.allowNativeScroll = function () {
        _this.isAllowNativeScroll = !0;
      }),
      (this.preventResizeReload = function () {
        _this.isPreventResizeReload = !0;
      }),
      (this._addOverflowScroll = function ($obj) {
        ($obj.div._scrollParent = !0),
          Device.mobile.native ||
            (($obj.div._preventEvent = function (e) {
              e.stopPropagation();
            }),
            $obj.bind("touchmove", $obj.div._preventEvent));
      }),
      (this._removeOverflowScroll = function ($obj) {
        $obj.unbind("touchmove", $obj.div._preventEvent);
      }),
      this.get("phone", () => {
        throw "Mobile.phone is removed. Use Device.mobile.phone";
      }),
      this.get("tablet", () => {
        throw "Mobile.tablet is removed. Use Device.mobile.tablet";
      }),
      this.get("os", () => {
        throw "Mobile.os is removed. Use Device.system.os";
      });
  }, "Static"),
  Class(function PushState(_isHash) {
    function addHandlers() {
      if (_isHash)
        return window.addEventListener(
          "hashchange",
          () => handleStateChange(getState()),
          !1
        );
      window.onpopstate = history.onpushstate = () =>
        handleStateChange(getState());
    }
    function getState() {
      return _isHash
        ? String(window.location.hash.slice(3))
        : ("/" !== _root
            ? location.pathname.split(_root)[1]
            : location.pathname.slice(1)) || "";
    }
    function handleStateChange(state, forced) {
      if (state !== _store || forced)
        if (_this.isLocked) {
          if (!_store) return;
          _isHash
            ? (window.location.hash = "!/" + _store)
            : window.history.pushState(null, null, _root + _store);
        } else
          (_store = state),
            _this.events.fire(Events.UPDATE, {
              value: state,
              split: state.split("/"),
            });
    }
    const _this = this;
    let _store,
      _root = "";
    "boolean" != typeof _isHash &&
      (_isHash = Hydra.LOCAL || !Device.system.pushstate),
      (this.isLocked = !1),
      addHandlers(),
      (_store = getState()),
      (this.getState = function () {
        return Device.mobile.native
          ? Storage.get("app_state") || ""
          : getState();
      }),
      (this.setRoot = function (root) {
        _root = "/" === root.charAt(0) ? root : "/" + root;
      }),
      (this.setState = function (state) {
        if (
          (Device.mobile.native && Storage.set("app_state", state),
          state !== _store)
        )
          return (
            (_store = state),
            _isHash
              ? (window.location.hash = "!/" + state)
              : window.history.pushState(null, null, _root + state),
            PushState.fireChangeWhenSet && handleStateChange(getState(), !0),
            !0
          );
      }),
      (this.replaceState = function (state) {
        state !== _store &&
          ((_store = state),
          _isHash
            ? (window.location.hash = "!/" + state)
            : window.history.replaceState(null, null, _root + state));
      }),
      (this.setTitle = function (title) {
        document.title = title;
      }),
      (this.lock = function () {
        this.isLocked = !0;
      }),
      (this.unlock = function () {
        this.isLocked = !1;
      }),
      (this.useHash = function () {
        _isHash = !0;
      });
  }),
  Class(function Dev() {
    function catchErrors() {
      window.onerror = function (message, file, line) {
        var string = message + " ::: " + file + " : " + line;
        _alert && alert(string),
          _post && post(_post + "/api/data/debug", getDebugInfo(string)),
          _this.onError && _this.onError(message, file, line);
      };
    }
    function getDebugInfo(string) {
      var obj = {};
      return (
        (obj.time = new Date().toString()),
        (obj.deviceId = _id),
        (obj.err = string),
        (obj.ua = Device.agent),
        (obj.width = Stage.width),
        (obj.height = Stage.height),
        (obj.screenWidth = screen.width),
        (obj.screenHeight = screen.height),
        obj
      );
    }
    var _post,
      _alert,
      _inter,
      _timerName,
      _this = this,
      _id = Utils.timestamp();
    (this.emulator =
      Device.mobile &&
      navigator.platform &&
      navigator.platform.toLowerCase().includes(["mac", "windows"])),
      (this.alertErrors = function (url) {
        (_alert = !0), "string" == typeof url && (url = [url]);
        for (var i = 0; i < url.length; i++)
          if (location.href.includes(url[i]) || location.hash.includes(url[i]))
            return catchErrors();
      }),
      (this.postErrors = function (url, post) {
        (_post = post), "string" == typeof url && (url = [url]);
        for (var i = 0; i < url.length; i++)
          if (location.href.includes(url[i])) return catchErrors();
      }),
      (this.expose = function (name, val, force) {
        (Hydra.LOCAL || force) && (window[name] = val);
      }),
      (this.logServer = function (msg) {
        _post && post(_post + "/api/data/debug", getDebugInfo(msg));
      }),
      (this.unsupported = function (needsAlert) {
        needsAlert &&
          alert(
            "Hi! This build is not yet ready for this device, things may not work as expected. Refer to build schedule for when this device will be supported."
          );
      }),
      (this.checkForLeaks = function (flag, array) {
        if (!window.AURA) {
          var matchArray = function (prop) {
            if (!array) return !1;
            for (var i = 0; i < array.length; i++)
              if (prop.includes(array[i])) return !0;
            return !1;
          };
          clearInterval(_inter),
            flag &&
              (_inter = setInterval(function () {
                for (var prop in window)
                  if (
                    !prop.includes("webkit") &&
                    "function" != typeof window[prop] &&
                    prop.length > 2
                  ) {
                    if (
                      prop.includes("_ga") ||
                      prop.includes("_typeface_js") ||
                      matchArray(prop)
                    )
                      continue;
                    var char1 = prop.charAt(0),
                      char2 = prop.charAt(1);
                    if (
                      ("_" == char1 || "$" == char1) &&
                      char2 !== char2.toUpperCase()
                    )
                      throw (
                        (console.log(window[prop]),
                        "Hydra Warning:: " +
                          prop +
                          " leaking into global scope")
                      );
                  }
              }, 1e3));
        }
      }),
      (this.startTimer = function (name) {
        (_timerName = name || "Timer"),
          console.time && !window._NODE_
            ? console.time(_timerName)
            : (_timer = performance.now());
      }),
      (this.stopTimer = function () {
        console.time && !window._NODE_
          ? console.timeEnd(_timerName)
          : console.log(
              "Render " + _timerName + ": " + (performance.now() - _timer)
            );
      }),
      (this.writeFile = function (file, data) {
        if (!Hydra.LOCAL) return;
        let url =
          location.protocol +
          "//" +
          location.hostname +
          ":8017" +
          location.pathname +
          file;
        post(url, data).then((e) => {
          "OK" != e && console.warn(`Unable to write to ${file}`);
        });
      }),
      Hydra.LOCAL && _this.checkForLeaks(!0);
  }, "Static"),
  Class(function Service() {
    function initWorker() {
      (_this.active = !0),
        navigator.serviceWorker
          .register("sw.js")
          .then(handleRegistration)
          .then(handleReady)
          .then(handleError);
    }
    function checkCache() {
      Storage.get("service_cache") != window._CACHE_ &&
        _this.post("clearCache");
    }
    function getSWAssets() {
      if (!window.ASSETS.SW || _this.cached) return [];
      var assets = window.ASSETS.SW;
      return (
        assets.forEach((asset, i) => {
          asset.includes(".js") &&
            (asset = assets[i].replace(".js", ".js?" + window._CACHE_));
        }),
        assets
      );
    }
    function handleRegistration(e) {}
    function handleReady(e) {
      (_this.isReady = !0),
        _this.events.fire(Events.READY, e, !0),
        (_sw = navigator.serviceWorker.controller),
        checkCache();
    }
    function handleError(e) {
      e && (_this.events.fire(Events.ERROR, e, !0), (_this.active = !1));
    }
    function handleMessage(e) {
      var data = e.data;
      data.evt && _this.events.fire(data.evt, data);
    }
    Inherit(this, Component);
    var _sw,
      _this = this;
    (this.active = !1),
      (this.ready = !1),
      (this.cached = !1),
      (this.offline = !1),
      (this.disabled = !1),
      (this.ready = function () {
        return this.wait(this, "isReady");
      }),
      (this.init = function () {
        Hydra.ready(() => {
          !("serviceWorker" in navigator) ||
            (Hydra.LOCAL && "" == location.port) ||
            window.process ||
            _this.disabled ||
            initWorker();
        });
      }),
      (this.cache = function (assets = []) {
        assets = Array.from(assets);
        _this.active &&
          _this.wait(_this, "ready", function () {
            _this.post("upload", {
              assets: assets,
              cdn: Assets.CDN,
              hostname: location.hostname,
              sw: getSWAssets(),
              offline: _this.offline,
            }),
              Storage.set("service_cache", window._CACHE_),
              (_this.cached = !0);
          });
      }),
      (this.post = function (fn, data = {}) {
        if (!_this.active) return;
        _this.wait(_this, "ready", function () {
          let mc = new MessageChannel();
          (mc.port1.onmessage = handleMessage),
            (data.fn = fn),
            _sw && _sw.postMessage(data, [mc.port2]);
        });
      });
  }, "static"),
  Class(function Storage() {
    function testStorage() {
      try {
        if (window.localStorage)
          try {
            (window.localStorage.test = 1),
              window.localStorage.removeItem("test"),
              (_storage = !0);
          } catch (e) {
            _storage = !1;
          }
        else _storage = !1;
      } catch (e) {
        _storage = !1;
      }
    }
    function cookie(key, value, expires) {
      var options;
      if (
        arguments.length > 1 &&
        (null === value || "object" != typeof value)
      ) {
        if (
          ((options = {}),
          (options.path = "/"),
          (options.expires = expires || 1),
          null === value && (options.expires = -1),
          "number" == typeof options.expires)
        ) {
          var days = options.expires,
            t = (options.expires = new Date());
          t.setDate(t.getDate() + days);
        }
        return (document.cookie = [
          encodeURIComponent(key),
          "=",
          options.raw ? String(value) : encodeURIComponent(String(value)),
          options.expires ? "; expires=" + options.expires.toUTCString() : "",
          options.path ? "; path=" + options.path : "",
          options.domain ? "; domain=" + options.domain : "",
          options.secure ? "; secure" : "",
        ].join(""));
      }
      var result,
        decode = (options = value || {}).raw
          ? function (s) {
              return s;
            }
          : decodeURIComponent;
      return (result = new RegExp(
        "(?:^|; )" + encodeURIComponent(key) + "=([^;]*)"
      ).exec(document.cookie))
        ? decode(result[1])
        : null;
    }
    var _storage;
    testStorage(),
      (this.setCookie = function (key, value, expires) {
        cookie(key, value, expires);
      }),
      (this.getCookie = function (key) {
        return cookie(key);
      }),
      (this.set = function (key, value) {
        null != value &&
          "object" == typeof value &&
          (value = JSON.stringify(value)),
          _storage
            ? null === value
              ? window.localStorage.removeItem(key)
              : (window.localStorage[key] = value)
            : cookie(key, value, 365);
      }),
      (this.get = function (key) {
        var val;
        if ((val = _storage ? window.localStorage[key] : cookie(key))) {
          var char0;
          val.charAt && (char0 = val.charAt(0)),
            ("{" != char0 && "[" != char0) || (val = JSON.parse(val)),
            ("true" != val && "false" != val) || (val = "true" == val);
        }
        return val;
      });
  }, "Static"),
  Class(
    function Thread(_class) {
      function init() {
        let file = window._ES5_
          ? "assets/js/hydra/hydra-thread-es5.js"
          : "assets/js/hydra/hydra-thread.js";
        (_callbacks = {}), (_worker = new Worker(Thread.PATH + file));
      }
      function importClasses() {
        importClass(Utils),
          importClass(Component),
          importClass(Events),
          importClass(_class, !0);
      }
      function importClass(_class, scoped) {
        if (_class) {
          var code;
          if (scoped) {
            code = (code = _class.toString().replace("{", "!!!")).split(
              "!!!"
            )[1];
            for (
              var splitChar = window._MINIFIED_ ? "=" : " ";
              code.includes("this");

            ) {
              var name = code
                .slice(code.indexOf("this."))
                .split("this.")[1]
                .split(splitChar)[0];
              (code = code.replace("this", "self")), createMethod(name);
            }
            code = (code = code.slice(0, -1)).replace(/_self/g, "_this");
          } else if ("function" != typeof _class) {
            if ((code = _class.constructor.toString()).includes("[native"))
              return;
            code =
              (_class.constructor._namespace
                ? _class.constructor._namespace + "."
                : "") +
              "Class(" +
              code +
              ', "static");';
          } else
            code =
              (_class._namespace ? _class._namespace + "." : "") +
              "Class(" +
              _class.toString() +
              ");";
          _worker.postMessage({ code: code });
        }
      }
      function createMethod(name) {
        _this[name] = function (message = {}, callback) {
          let promise;
          return (
            void 0 === callback &&
              (callback = (promise = Promise.create()).resolve),
            _this.send(name, message, callback),
            promise
          );
        };
      }
      function addListeners() {
        _worker.addEventListener("message", workerMessage);
      }
      function workerMessage(e) {
        if (e.data.console) console.log(e.data.message);
        else if (e.data.id)
          (callback = _callbacks[e.data.id]) && callback(e.data.message),
            delete _callbacks[e.data.id];
        else if (e.data.emit)
          (callback = _callbacks[e.data.evt]) && callback(e.data.msg);
        else {
          var callback = _callbacks.transfer;
          callback && callback(e.data);
        }
      }
      Inherit(this, Component);
      var _this = this,
        _worker,
        _callbacks,
        _path,
        _mvc,
        _msg = {};
      init(),
        importClasses(),
        addListeners(),
        (this.on = function (evt, callback) {
          _callbacks[evt] = callback;
        }),
        (this.off = function (evt) {
          delete _callbacks[evt];
        }),
        (this.loadFunction = function () {
          let names = [];
          for (var i = 0; i < arguments.length; i++)
            ((code) => {
              var split = (code = (code = code.toString()).replace(
                  "(",
                  "!!!"
                )).split("!!!"),
                name = split[0].split(" ")[1];
              (code = "self." + name + " = function(" + split[1]),
                _worker.postMessage({ code: code }),
                createMethod(name),
                names.push(name);
            })(arguments[i]);
          return names;
        }),
        (this.importScript = function (path) {
          _worker.postMessage({
            path: Thread.absolutePath(path),
            importScript: !0,
          });
        }),
        (this.importCode = function (code) {
          _worker.postMessage({ code: code });
        }),
        (this.importClass = function () {
          for (var i = 0; i < arguments.length; i++) importClass(arguments[i]);
        }),
        (this.importModules = this.importModule =
          function () {
            for (var i = 0; i < arguments.length; i++) {
              let code = Modules.getConstructor(arguments[i]).toString();
              _worker.postMessage({ code: `Module(${code})` });
            }
          }),
        (this.importES6Class = function (name) {
          if (window._ES5_) {
            let Class = window[name],
              base = Class.toString(),
              proto = [];
            Object.getOwnPropertyNames(Class.prototype).forEach((fn) => {
              "constructor" != fn &&
                Class.prototype[fn] &&
                proto.push({ key: fn, string: Class.prototype[fn].toString() });
            }),
              _worker.postMessage({ es5: base, name: name, proto: proto });
          } else _worker.postMessage({ es6: `(${eval(name)})`, name: name });
        }),
        (this.send = function (name, message, callback) {
          if ("string" == typeof name) {
            (message = message || {}).fn = name;
          } else (callback = message), (message = name);
          var id = Utils.timestamp();
          callback && (_callbacks[id] = callback),
            message.transfer
              ? ((message.msg.id = id),
                (message.msg.fn = message.fn),
                (message.msg.transfer = !0),
                _worker.postMessage(message.msg, message.buffer))
              : ((_msg.message = message),
                (_msg.id = id),
                _worker.postMessage(_msg));
        }),
        (this.onDestroy = function () {
          _worker.terminate && _worker.terminate();
        });
    },
    () => {
      (Thread.PATH = ""),
        (Thread.absolutePath = Hydra.absolutePath),
        (Thread.cluster = function () {
          return new (function () {
            let index = 0,
              array = [];
            (this.push = function (thread) {
              array.push(thread);
            }),
              (this.get = function () {
                let thread = array[index];
                return ++index >= array.length && (index = 0), thread;
              }),
              (this.array = array);
          })();
        }),
        (Thread.upload = function (...args) {
          Thread.shared();
          let name;
          for (let i = 0; i < _shared.array.length; i++)
            name = _shared.array[i].loadFunction(...args);
          return name;
        });
      var _shared;
      Thread.shared = function (list) {
        if (!_shared) {
          _shared = Thread.cluster();
          let count = navigator.hardwareConcurrency || 4;
          for (let i = 0; i < count; i++) _shared.push(new Thread());
        }
        return list ? _shared : _shared.get();
      };
    }
  ),
  Class(function TweenManager() {
    function updateTweens(time) {
      for (let i = _tweens.length - 1; i >= 0; i--) {
        let tween = _tweens[i];
        tween.update ? tween.update(time) : _this._removeMathTween(tween);
      }
    }
    function stringToValues(str) {
      for (
        var values = str.split("(")[1].slice(0, -1).split(","), i = 0;
        i < values.length;
        i++
      )
        values[i] = parseFloat(values[i]);
      return values;
    }
    function findEase(name) {
      for (var eases = _this.CubicEases, i = eases.length - 1; i > -1; i--)
        if (eases[i].name == name) return eases[i];
      return !1;
    }
    Namespace(this);
    var _this = this,
      _tweens = [];
    (this.CubicEases = []),
      Render.start(updateTweens),
      (this._addMathTween = function (tween) {
        _tweens.push(tween);
      }),
      (this._removeMathTween = function (tween) {
        _tweens.remove(tween);
      }),
      (this._getEase = function (name, values) {
        var ease = findEase(name);
        return (
          !!ease &&
          (values ? (ease.path ? ease.path.solve : ease.values) : ease.curve)
        );
      }),
      (this._inspectEase = function (name) {
        return findEase(name);
      }),
      (this.tween = function (
        object,
        props,
        time,
        ease,
        delay,
        complete,
        isManual
      ) {
        "number" != typeof delay &&
          ((update = complete), (complete = delay), (delay = 0));
        const tween = new MathTween(
          object,
          props,
          time,
          ease,
          delay,
          complete,
          isManual
        );
        let usePromise = null;
        return (
          complete &&
            complete instanceof Promise &&
            ((usePromise = complete), (complete = complete.resolve)),
          usePromise || tween
        );
      }),
      (this.clearTween = function (object) {
        if (
          (object._mathTween &&
            object._mathTween.stop &&
            object._mathTween.stop(),
          object._mathTweens)
        ) {
          for (var tweens = object._mathTweens, i = 0; i < tweens.length; i++) {
            var tw = tweens[i];
            tw && tw.stop && tw.stop();
          }
          object._mathTweens = null;
        }
      }),
      (this.addCustomEase = function (ease) {
        var add = !0;
        if ("object" != typeof ease || !ease.name || !ease.curve)
          throw "TweenManager :: addCustomEase requires {name, curve}";
        for (var i = _this.CubicEases.length - 1; i > -1; i--)
          ease.name == _this.CubicEases[i].name && (add = !1);
        if (add) {
          if ("m" == ease.curve.charAt(0).toLowerCase()) {
            if (!window.EasingPath)
              throw "Using custom eases requires easingpath module";
            ease.path = new EasingPath(ease.curve);
          } else ease.values = stringToValues(ease.curve);
          _this.CubicEases.push(ease);
        }
        return ease;
      }),
      (Math.interpolate = function (start, end, alpha, ease) {
        const fn = _this.Interpolation.convertEase(ease);
        return Math.mix(
          start,
          end,
          "function" == typeof fn
            ? fn(alpha)
            : _this.Interpolation.solve(fn, alpha)
        );
      }),
      (window.tween = this.tween),
      (window.clearTween = this.clearTween);
  }, "Static"),
  TweenManager.Class(function Interpolation() {
    function calculateBezier(aT, aA1, aA2) {
      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    }
    function getTForX(aX, mX1, mX2) {
      for (var aGuessT = aX, i = 0; i < 4; i++) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (0 == currentSlope) return aGuessT;
        aGuessT -= (calculateBezier(aGuessT, mX1, mX2) - aX) / currentSlope;
      }
      return aGuessT;
    }
    function getSlope(aT, aA1, aA2) {
      return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
    }
    function A(aA1, aA2) {
      return 1 - 3 * aA2 + 3 * aA1;
    }
    function B(aA1, aA2) {
      return 3 * aA2 - 6 * aA1;
    }
    function C(aA1) {
      return 3 * aA1;
    }
    (this.convertEase = function (ease) {
      var fn = (function () {
        switch (ease) {
          case "easeInQuad":
            return TweenManager.Interpolation.Quad.In;
          case "easeInCubic":
            return TweenManager.Interpolation.Cubic.In;
          case "easeInQuart":
            return TweenManager.Interpolation.Quart.In;
          case "easeInQuint":
            return TweenManager.Interpolation.Quint.In;
          case "easeInSine":
            return TweenManager.Interpolation.Sine.In;
          case "easeInExpo":
            return TweenManager.Interpolation.Expo.In;
          case "easeInCirc":
            return TweenManager.Interpolation.Circ.In;
          case "easeInElastic":
            return TweenManager.Interpolation.Elastic.In;
          case "easeInBack":
            return TweenManager.Interpolation.Back.In;
          case "easeInBounce":
            return TweenManager.Interpolation.Bounce.In;
          case "easeOutQuad":
            return TweenManager.Interpolation.Quad.Out;
          case "easeOutCubic":
            return TweenManager.Interpolation.Cubic.Out;
          case "easeOutQuart":
            return TweenManager.Interpolation.Quart.Out;
          case "easeOutQuint":
            return TweenManager.Interpolation.Quint.Out;
          case "easeOutSine":
            return TweenManager.Interpolation.Sine.Out;
          case "easeOutExpo":
            return TweenManager.Interpolation.Expo.Out;
          case "easeOutCirc":
            return TweenManager.Interpolation.Circ.Out;
          case "easeOutElastic":
            return TweenManager.Interpolation.Elastic.Out;
          case "easeOutBack":
            return TweenManager.Interpolation.Back.Out;
          case "easeOutBounce":
            return TweenManager.Interpolation.Bounce.Out;
          case "easeInOutQuad":
            return TweenManager.Interpolation.Quad.InOut;
          case "easeInOutCubic":
            return TweenManager.Interpolation.Cubic.InOut;
          case "easeInOutQuart":
            return TweenManager.Interpolation.Quart.InOut;
          case "easeInOutQuint":
            return TweenManager.Interpolation.Quint.InOut;
          case "easeInOutSine":
            return TweenManager.Interpolation.Sine.InOut;
          case "easeInOutExpo":
            return TweenManager.Interpolation.Expo.InOut;
          case "easeInOutCirc":
            return TweenManager.Interpolation.Circ.InOut;
          case "easeInOutElastic":
            return TweenManager.Interpolation.Elastic.InOut;
          case "easeInOutBack":
            return TweenManager.Interpolation.Back.InOut;
          case "easeInOutBounce":
            return TweenManager.Interpolation.Bounce.InOut;
          case "linear":
            return TweenManager.Interpolation.Linear.None;
        }
      })();
      if (!fn) {
        var curve = TweenManager._getEase(ease, !0);
        fn = curve || TweenManager.Interpolation.Cubic.Out;
      }
      return fn;
    }),
      (this.solve = function (values, elapsed) {
        return values[0] == values[1] && values[2] == values[3]
          ? elapsed
          : calculateBezier(
              getTForX(elapsed, values[0], values[2]),
              values[1],
              values[3]
            );
      }),
      (this.Linear = {
        None: function (k) {
          return k;
        },
      }),
      (this.Quad = {
        In: function (k) {
          return k * k;
        },
        Out: function (k) {
          return k * (2 - k);
        },
        InOut: function (k) {
          return (k *= 2) < 1 ? 0.5 * k * k : -0.5 * (--k * (k - 2) - 1);
        },
      }),
      (this.Cubic = {
        In: function (k) {
          return k * k * k;
        },
        Out: function (k) {
          return --k * k * k + 1;
        },
        InOut: function (k) {
          return (k *= 2) < 1 ? 0.5 * k * k * k : 0.5 * ((k -= 2) * k * k + 2);
        },
      }),
      (this.Quart = {
        In: function (k) {
          return k * k * k * k;
        },
        Out: function (k) {
          return 1 - --k * k * k * k;
        },
        InOut: function (k) {
          return (k *= 2) < 1
            ? 0.5 * k * k * k * k
            : -0.5 * ((k -= 2) * k * k * k - 2);
        },
      }),
      (this.Quint = {
        In: function (k) {
          return k * k * k * k * k;
        },
        Out: function (k) {
          return --k * k * k * k * k + 1;
        },
        InOut: function (k) {
          return (k *= 2) < 1
            ? 0.5 * k * k * k * k * k
            : 0.5 * ((k -= 2) * k * k * k * k + 2);
        },
      }),
      (this.Sine = {
        In: function (k) {
          return 1 - Math.cos((k * Math.PI) / 2);
        },
        Out: function (k) {
          return Math.sin((k * Math.PI) / 2);
        },
        InOut: function (k) {
          return 0.5 * (1 - Math.cos(Math.PI * k));
        },
      }),
      (this.Expo = {
        In: function (k) {
          return 0 === k ? 0 : Math.pow(1024, k - 1);
        },
        Out: function (k) {
          return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
        },
        InOut: function (k) {
          return 0 === k
            ? 0
            : 1 === k
            ? 1
            : (k *= 2) < 1
            ? 0.5 * Math.pow(1024, k - 1)
            : 0.5 * (2 - Math.pow(2, -10 * (k - 1)));
        },
      }),
      (this.Circ = {
        In: function (k) {
          return 1 - Math.sqrt(1 - k * k);
        },
        Out: function (k) {
          return Math.sqrt(1 - --k * k);
        },
        InOut: function (k) {
          return (k *= 2) < 1
            ? -0.5 * (Math.sqrt(1 - k * k) - 1)
            : 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        },
      }),
      (this.Elastic = {
        In: function (k, a = 1, p = 0.4) {
          var s;
          return 0 === k
            ? 0
            : 1 === k
            ? 1
            : (!a || a < 1
                ? ((a = 1), (s = p / 4))
                : (s = (p * Math.asin(1 / a)) / (2 * Math.PI)),
              -a *
                Math.pow(2, 10 * (k -= 1)) *
                Math.sin(((k - s) * (2 * Math.PI)) / p));
        },
        Out: function (k, a = 1, p = 0.4) {
          var s;
          return 0 === k
            ? 0
            : 1 === k
            ? 1
            : (!a || a < 1
                ? ((a = 1), (s = p / 4))
                : (s = (p * Math.asin(1 / a)) / (2 * Math.PI)),
              a *
                Math.pow(2, -10 * k) *
                Math.sin(((k - s) * (2 * Math.PI)) / p) +
                1);
        },
        InOut: function (k, a = 1, p = 0.4) {
          var s;
          return 0 === k
            ? 0
            : 1 === k
            ? 1
            : (!a || a < 1
                ? ((a = 1), (s = p / 4))
                : (s = (p * Math.asin(1 / a)) / (2 * Math.PI)),
              (k *= 2) < 1
                ? a *
                  Math.pow(2, 10 * (k -= 1)) *
                  Math.sin(((k - s) * (2 * Math.PI)) / p) *
                  -0.5
                : a *
                    Math.pow(2, -10 * (k -= 1)) *
                    Math.sin(((k - s) * (2 * Math.PI)) / p) *
                    0.5 +
                  1);
        },
      }),
      (this.Back = {
        In: function (k) {
          var s = 1.70158;
          return k * k * ((s + 1) * k - s);
        },
        Out: function (k) {
          var s = 1.70158;
          return --k * k * ((s + 1) * k + s) + 1;
        },
        InOut: function (k) {
          var s = 2.5949095;
          return (k *= 2) < 1
            ? k * k * ((s + 1) * k - s) * 0.5
            : 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        },
      }),
      (this.Bounce = {
        In: function (k) {
          return 1 - this.Bounce.Out(1 - k);
        },
        Out: function (k) {
          return k < 1 / 2.75
            ? 7.5625 * k * k
            : k < 2 / 2.75
            ? 7.5625 * (k -= 1.5 / 2.75) * k + 0.75
            : k < 2.5 / 2.75
            ? 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375
            : 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
        },
        InOut: function (k) {
          return k < 0.5
            ? 0.5 * this.Bounce.In(2 * k)
            : 0.5 * this.Bounce.Out(2 * k - 1) + 0.5;
        },
      });
  }, "Static"),
  Class(function MathTween(
    _object,
    _props,
    _time,
    _ease,
    _delay,
    _callback,
    _manual
  ) {
    function start() {
      _object.multiTween ||
        !_object._mathTween ||
        _manual ||
        TweenManager.clearTween(_object),
        _manual || TweenManager._addMathTween(_this),
        (_this.time = _time),
        (_this.delay = _delay);
      let propString = getPropString();
      (_object._mathTween = _this),
        _object.multiTween &&
          (_object._mathTweens || (_object._mathTweens = []),
          _object._mathTweens.forEach((t) => {
            t.props == propString && t.tween.stop();
          }),
          (_this._tweenWrapper = { props: propString, tween: _this }),
          _object._mathTweens.push(_this._tweenWrapper)),
        _ease || (_ease = "linear"),
        "string" == typeof _ease &&
          ((_ease = TweenManager.Interpolation.convertEase(_ease)),
          (_easeFunction = "function" == typeof _ease)),
        (_startTime = performance.now()),
        (_startTime += _delay),
        (_endValues = _props),
        (_startValues = {}),
        _props.spring && (_spring = _props.spring),
        _props.damping && (_damping = _props.damping),
        (_this.startValues = _startValues);
      for (var prop in _endValues)
        "number" == typeof _object[prop] &&
          (_startValues[prop] = _object[prop]);
    }
    function getPropString() {
      let string = "";
      for (let key in _props)
        "number" == typeof _props[key] && (string += key + " ");
      return string;
    }
    function clear() {
      if (!_object && !_props) return !1;
      (_object._mathTween = null),
        TweenManager._removeMathTween(_this),
        Utils.nullObject(_this),
        _object._mathTweens && _object._mathTweens.remove(_this._tweenWrapper);
    }
    var _startTime,
      _startValues,
      _endValues,
      _easeFunction,
      _paused,
      _newEase,
      _spring,
      _damping,
      _update,
      _this = this,
      _elapsed = 0;
    (_this.object = _object),
      (_this.props = _props),
      (_this.time = _time),
      (_this.ease = _ease),
      (_this.delay = _delay),
      defer(function () {
        if (_this.overrideValues) {
          let values = _this.overrideValues(
            _this,
            _object,
            _props,
            _time,
            _ease,
            _delay
          );
          values &&
            ((_this.props = _props = values.props || _props),
            (_this.time = _time = values.time || _time),
            (_this.ease = _ease = values.ease || _ease),
            (_this.delay = _delay = values.delay || _delay));
        }
        if (_object && _props) {
          if (((_this.object = _object), "number" != typeof _time))
            throw "MathTween Requires object, props, time, ease";
          start();
        }
      }),
      (this.update = function (time) {
        if (_paused || time < _startTime) return;
        _elapsed = (_elapsed = (time - _startTime) / _time) > 1 ? 1 : _elapsed;
        let delta = this.interpolate(_elapsed);
        _update && _update(delta),
          1 == _elapsed &&
            (_callback && _callback(),
            _this.completePromise && _this.completePromise.resolve(),
            clear());
      }),
      (this.pause = function () {
        _paused = !0;
      }),
      (this.resume = function () {
        (_paused = !1), (_startTime = performance.now() - _elapsed * _time);
      }),
      (this.stop = function () {
        return (_this.stopped = !0), clear(), null;
      }),
      (this.setEase = function (ease) {
        _newEase != ease &&
          ((_newEase = ease),
          (_ease = TweenManager.Interpolation.convertEase(ease)),
          (_easeFunction = "function" == typeof _ease));
      }),
      (this.getValues = function () {
        return { start: _startValues, end: _endValues };
      }),
      (this.interpolate = function (elapsed) {
        var delta = _easeFunction
          ? _ease(elapsed, _spring, _damping)
          : TweenManager.Interpolation.solve(_ease, elapsed);
        for (var prop in _startValues)
          if (
            "number" == typeof _startValues[prop] &&
            "number" == typeof _endValues[prop]
          ) {
            var start = _startValues[prop],
              end = _endValues[prop];
            _object[prop] = start + (end - start) * delta;
          }
        return delta;
      }),
      (this.onUpdate = function (callback) {
        return (_update = callback), this;
      }),
      (this.onComplete = function (callback) {
        return (_callback = callback), this;
      }),
      (this.promise = function () {
        return (
          (_this.completePromise = Promise.create()), _this.completePromise
        );
      });
  }),
  Class(function TweenTimeline() {
    function calculate() {
      _tweens.sort(function (a, b) {
        const ta = a.time + a.delay;
        return b.time + b.delay - ta;
      });
      const first = _tweens[0];
      _total = first.time + first.delay;
    }
    function loop() {
      let time = _this.elapsed * _total;
      for (let i = _tweens.length - 1; i > -1; i--) {
        let t = _tweens[i],
          relativeTime = time - t.delay,
          elapsed = Math.clamp(relativeTime / t.time, 0, 1);
        t.interpolate(elapsed);
      }
      _this.events.fire(Events.UPDATE, _this, !0);
    }
    Inherit(this, Component);
    const _this = this;
    let _tween,
      _total = 0;
    const _tweens = [];
    (this.elapsed = 0),
      this.get("timeRemaining", () => _total - _this.elapsed * _total),
      (this.add = function (object, props, time, ease, delay = 0) {
        (object instanceof MathTween || object instanceof FrameTween) &&
          ((props = object.props),
          (time = object.time),
          (ease = object.ease),
          (delay = object.delay),
          (object = object.object));
        let tween;
        return (
          (tween =
            object instanceof HydraObject
              ? new FrameTween(object, props, time, ease, delay, null, !0)
              : new MathTween(object, props, time, ease, delay, null, !0)),
          _tweens.push(tween),
          defer(calculate),
          tween
        );
      }),
      (this.tween = function (to, time, ease, delay, callback) {
        return (
          _this.clearTween(),
          (_tween = tween(_this, { elapsed: to }, time, ease, delay)
            .onUpdate(loop)
            .onComplete(callback))
        );
      }),
      (this.clearTween = function () {
        _tween && _tween.stop && _tween.stop();
      }),
      (this.startRender = function () {
        Render.start(loop);
      }),
      (this.stopRender = function () {
        Render.stop(loop);
      }),
      (this.update = function () {
        loop();
      }),
      (this.onDestroy = function () {
        _this.clearTween(), Render.stop(loop);
        for (var i = 0; i < _tweens.length; i++) _tweens[i].stop();
      });
  }),
  Class(function Data() {
    Inherit(this, Model);
    const _this = this;
    !(async function () {
      await Hydra.ready(),
        // (_this.STATIC_DATA = await get(
        //   Config.DATA + (Config.DATA.includes("?") ? "&" : "?") + Date.now()
        // )),
        _this.STATIC_DATA = {
            "copy": {
                "LOADER_TAG": "Acoustic Garage",
                "SECTION_STEP_1": "Step 1",
                "SECTION_STEP_1_TEXT": "Select a vehicle type",
                "SECTION_STEP_2": "Step 2",
                "SECTION_STEP_2_TEXT": "Select an engine type",
                "SECTION_STEP_3": "Step 3",
                "SECTION_STEP_3_TEXT": "Select a NVH package",
                "SECTION_STEP_4": "Step 4",
                "SECTION_STEP_4_TEXT": "Customize your package",
                "SECTION_STEP_5": "Step 5",
                "SECTION_BODY": "Body style",
                "SECTION_BODY_TEXT": "As an automotive NVH designer, different types of vehicles confront you with different acoustic challenges",
                "SECTION_ENGINE": "Engine",
                "SECTION_ENGINE_TEXT": "The type of engine you select can decisively alter the acoustic character of your vehicle ",
                "SECTION_PRESETS": "Presets",
                "SECTION_PRESETS_TEXT": "To get you started, Autoneum has designed specific sound packages tailored to different requirements. Learn how the acoustic performance changes based on the recommended technologies.",
                "SECTION_CUSTOMISE": "Customize",
                "SECTION_CUSTOMISE_TEXT": "Learn what it takes to bring driving comfort to your vehicle. Customize the sound package to your liking and see how it performs against Autoneum's preset packages",
                "SECTION_CUSTOMISE_PROMPT": "Customize",
                "SECTION_REPORT": "Calculate",
                "PRODUCT_WEIGHT": "Product weight",
                "PRODUCT_WEIGHT_CALCULATING": "calculating...",
                "KEY_VALUES": "Key values",
                "KEY_VALUES_POPUP": "Use the radar chart to experience how key values shift as a result of your customized acoustic settings.",
                "TRANSMISSION_LOSS": "Transmission loss",
                "TRANSMISSION_LOSS_POPUP": "Describes the accumulated decrease in intensity of acoustic energy as sound propagates through a certain area or structure (i.e. firewall between engine bay and pasenger cabin). It is measured in decibel (dB). The higher, the better. ",
                "FREQUENCY": "Frequency (Hz)",
                "DECIBELS": "[dB]",
                "ABSORPTION": "Absorption",
                "ABSORPTION_POPUP": "Refers to the process by which a material, structure, or object takes insoundenergy whensoundwaves are encountered, as opposed to reflecting the energy. Part of theabsorbedenergy is transformed into heat and part is transmitted through theabsorbingbody.",
                "TECHNOLOGIES": "Technologies",
                "TECHNOLOGY": "Technologies",
                "VARIABLES": "Variables",
                "VARIABLE_THIN": "Thin",
                "VARIABLE_THICK": "Thick",
                "LISTEN_TO_ME": "Listen To Me",
                "GENERATING_REPORT": "Generating ### report",
                "GENERATING_CUSTOMISATION": "Generating ### customization",
                "LOADING_REPORT": "Loading report",
                "CUSTOMISATION_BY": "by",
                "TOTAL_WEIGHT": "Total weight",
                "SOUND_SIGNATURE": "Autoneum sound signature",
                "ACOUSTIC_TRANSFER": "Acoustic transfer function",
                "SIGNATURE_SOURCES": "from engine and tire sources",
                "SIGNATURE_TIRE": "tire",
                "SIGNATURE_ENGINE": "engine",
                "SOUND_PRESSURE": "Sound pressure level (dB)",
                "DRIVER_EARS": "Driver ears",
                "REAR_PASSENGER_EARS": "Rear passenger ears",
                "PRODUCTS_TECH": "Products and tech",
                "REPORT_RENAME": "Rename",
                "REPORT_DELETE": "Delete",
                "REPORT_DELETE_ALL": "Clear all",
                "REPORT_DELETE_ALL_CONFIRM": "Are you sure you would like to delete all your reports?",
                "REPORT_DELETE_ALL_OK": "Yes",
                "REPORT_DELETE_ALL_CANCEL": "No",
                "REPORT_EMAIL": "Email",
                "REPORT_SHARE": "Share",
                "REPORT_COMPARE": "Compare",
                "MENU_LANGUAGE": "Language",
                "MENU_CONTACT": "Stay tuned ! \n",
                "MENU_CONTACT_EMAIL": "patp@autoneum.com",
                "MODAL_ENJOY_TITLE": "Hi there!",
                "MODAL_ENJOY_TEXT": "We hope that you're enjoying the experience.\nSign up to receive updates on Acoustic Garage.",
                "MODAL_CONTACT_TEXT": "We hope that you're enjoying the experience.\nWould you like to get in touch with Autoneum experts?",
                "MODAL_FIRST_NAME": "First name",
                "MODAL_LAST_NAME": "Last name",
                "MODAL_COMPANY": "Company",
                "MODAL_POSITION": "Position",
                "MODAL_EMAIL": "Email",
                "MODAL_CONFIRM_EMAIL": "Confirm email",
                "MODAL_REQUIRED": "Required fields",
                "MODAL_ERROR": "Please make sure that all required fields are completed",
                "MODAL_SUBMIT": "Submit",
                "MODAL_MESSAGE": "Message",
                "MODAL_OPT_TEXT": "By clicking the box, I give my explicit consent that Autoneum can use my personal data for statistical purposes and in order to contact me if requested. I am aware that I am entitled to withdraw my consent to use my personal data anytime. In addition, I declare to have read and understood the information in the privacy notice concerning the processing of my personal data by Autoneum and my related rights.",
                "COOKIES_TEXT": "Cookies facilitate the provision of our services. By using our services you agree that we use cookies.",
                "COOKIES_OK": "OK",
                "COOKIES_MORE": "More information",
                "COOKIES_MORE_URL": "https://www.autoneum.com/data-protection/",
                "REPORT_TITLE": "{preset} Report {count}",
                "REPORT_TITLE_SHARED_SUFFIX": " [shared]",
                "REPORT_EMAIL_SUBJECT": "Autoneum configuration",
                "REPORT_EMAIL_CONTENT": "Hi,\n\nTake a look at the customized vehicle sound package I just made in the Autoneum Acoustic Garage on https://acoustics.autoneum.com: ",
                "REPORT_SHARE_COPIED": "Your share link has been copied to the clipboard.",
                "REPORT_SHARE_BUTTON": "Ok",
                "PAGE_TITLE": "Autoneum Acoustic Garage",
                "PAGE_DESCRIPTION": "Autoneum Acoustic Garage",
                "INTRO_TITLE": "Welcome",
                "INTRO_TEXT": "In the Autoneum acoustic garage you can discover and tune your own acoustic package.",
                "UNSUPPORTED_TITLE": "Unsupported Device",
                "UNSUPPORTED_TEXT": "Please visit on a tablet or PC for the full experience",
                "ROTATE_DEVICE": "Please rotate your device",
                "RESET_TEXT": "Your customisations were reset to",
                "RESET_BUTTON_TEXT": "Ok",
                "COMING_SOON_TITLE": "Coming soon",
                "COMING_SOON_SUV": "That selection is not available yet, please choose another to continue.",
                "COMING_SOON_SEDAN": "That selection is not available yet, please choose another to continue.",
                "COMING_SOON_HEV": "That selection is not available yet, please choose another to continue.",
                "IE_DISCLAIMER_TEXT": "Acoustic Garage is optimized for web browsers other than Internet Explorer.",
                "HIGHER_BETTER_TEXT": "Higher is better",
                "LOWER_BETTER_TEXT": "Lower is better",
                "MENU_ICON_TEXT": "Menu",
                "UI_CONTACT_TEXT": "Contact us",
                "MIN_ABBR_TEXT": "MIN",
                "MAX_ABBR_TEXT": "MAX"
            },
            "menu": [
                {
                    "name": "Behind The Scenes",
                    "description": "Click here for more information on Autoneum's Acoustic Garage.",
                    "url": "https://www.autoneum.com/innovation/acoustic-garage/"
                },
                {
                    "name": "Part performance",
                    "description": "Part performance are based on Autoneum's simulation software VisualSISAB,  with which Porous Material Models are calculated that are representative for part serial production. Click here for more information.",
                    "url": "http://www.autoneum.com/wp-content/uploads/2017/09/220733_Autoneum_Flyer_Simulation_VisualSISAB_Realisation_170705_GZD2.pdf"
                },
                {
                    "name": "Vehicle performance",
                    "description": "Vehicle performance are based on Autoneum REVAMP (SEA) simulations and including NVH performances of parts as selected by the user. Click here for more information.",
                    "url": "https://www.autoneum.com/wp-content/uploads/2017/09/220733_Autoneum_Flyer_Simulation_REVAMP_Realisation_170705_GZD.pdf"
                }
            ],
            "bodyStyles": [
                {
                    "active": true,
                    "enabled": true,
                    "default": true,
                    "name": "Hatchback",
                    "description": "A car with a hatch-type rear door that opens upwards and often a shared space for the passenger area and trunk",
                    "perma": "hatchback",
                    "code": "C",
                    "powertrains": [
                        "B",
                        "H",
                        "I"
                    ],
                    "products": [
                        "O",
                        "H",
                        "N",
                        "M",
                        "T",
                        "F",
                        "C",
                        "D",
                        "A",
                        "U",
                        "W",
                        "V"
                    ]
                },
                {
                    "active": true,
                    "enabled": false,
                    "default": false,
                    "name": "SUV",
                    "description": "Car combining element of a hatchback with features from off-road vehicles, such as raised ground clearance and four wheel drive",
                    "perma": "suv",
                    "code": "B",
                    "powertrains": [
                        "H",
                        "I",
                        "B"
                    ],
                    "products": [
                        "O",
                        "H",
                        "N",
                        "M",
                        "T",
                        "F",
                        "C",
                        "D",
                        "A",
                        "U",
                        "W",
                        "V"
                    ]
                },
                {
                    "active": true,
                    "enabled": false,
                    "default": false,
                    "name": "Sedan",
                    "description": "Car with separate compartments for engine, passenger and trunk ",
                    "perma": "sedan",
                    "code": "A",
                    "powertrains": [
                        "I",
                        "B",
                        "H"
                    ],
                    "products": [
                        "O",
                        "H",
                        "N",
                        "M",
                        "T",
                        "F",
                        "C",
                        "D",
                        "A",
                        "U",
                        "W",
                        "V"
                    ]
                }
            ],
            "powertrains": [
                {
                    "active": true,
                    "enabled": true,
                    "default": true,
                    "name": "Internal Combustion Engine (ICE)",
                    "perma": "ice",
                    "code": "I",
                    "description": "Four-cylinder internal combustion engine ",
                    "bodyStyles": [
                        "A",
                        "C",
                        "B"
                    ],
                    "products": [
                        "C",
                        "D",
                        "O",
                        "U",
                        "W",
                        "H",
                        "N",
                        "T",
                        "A"
                    ]
                },
                {
                    "active": true,
                    "enabled": true,
                    "default": false,
                    "name": "Battery Electric Vehicle (BEV)",
                    "perma": "bev",
                    "code": "B",
                    "description": "Battery Electric Vehicle",
                    "bodyStyles": [
                        "A",
                        "C",
                        "B"
                    ],
                    "products": [
                        "C",
                        "D",
                        "O",
                        "W",
                        "M",
                        "F",
                        "V",
                        "H",
                        "U"
                    ]
                },
                {
                    "active": true,
                    "enabled": false,
                    "default": false,
                    "name": "Hybrid Electric Vehicle (HEV)",
                    "perma": "hev",
                    "code": "H",
                    "description": "Hybrid Electric Vehicle",
                    "bodyStyles": [
                        "A",
                        "B",
                        "C"
                    ],
                    "products": [
                        "C",
                        "D",
                        "O",
                        "U",
                        "W",
                        "H",
                        "N",
                        "T",
                        "A"
                    ]
                }
            ],
            "products": [
                {
                    "name": "Carpet System",
                    "perma": "carpet-system",
                    "code": "C",
                    "description": "Carpet systems have a decisive influence on the acoustics in the passenger cabin due to their size and textile properties. The visible face material provides high frequency absorption, whereas the backing and decoupler technologies contribute mainly to the overall acoustic performance of the floor carpet system.",
                    "powertrains": [
                        "I",
                        "H",
                        "B"
                    ],
                    "bodyStyles": [
                        "C",
                        "A",
                        "B"
                    ],
                    "productVariables": [
                        {
                            "name": "Carpet face",
                            "description": "Mostly related to aesthetics, cleanability and abrasion resistance.",
                            "perma": "top-face",
                            "code": "TF",
                            "options": [
                                {
                                    "name": "Tuft",
                                    "code": "a",
                                    "perma": "tufted",
                                    "aa": 0,
                                    "ai": 0,
                                    "presets": []
                                },
                                {
                                    "name": "Needlepunch",
                                    "code": "b",
                                    "perma": "needlepunch",
                                    "aa": 0,
                                    "ai": 0,
                                    "presets": [
                                        "B",
                                        "L",
                                        "A",
                                        "I"
                                    ]
                                }
                            ]
                        },
                        {
                            "name": "Coverage",
                            "description": "Percentage of body covered. Low coverage weakens part performance, notably in insulation.",
                            "perma": "coverage",
                            "code": "C",
                            "options": [
                                {
                                    "name": "Low",
                                    "code": "a",
                                    "perma": "low",
                                    "aa": -1,
                                    "ai": -1,
                                    "presets": []
                                },
                                {
                                    "name": "Average",
                                    "code": "b",
                                    "perma": "average",
                                    "aa": 0,
                                    "ai": 0,
                                    "presets": [
                                        "B",
                                        "L",
                                        "A",
                                        "I"
                                    ]
                                },
                                {
                                    "name": "High",
                                    "code": "c",
                                    "perma": "high",
                                    "aa": 1,
                                    "ai": 1,
                                    "presets": []
                                }
                            ]
                        },
                        {
                            "name": "Packaging Space",
                            "description": "Thickness distribution of the part. Thin areas weaken part performances, especially in insulation.",
                            "perma": "packaging-space",
                            "code": "PS",
                            "options": [
                                {
                                    "name": "Low",
                                    "code": "a",
                                    "perma": "low",
                                    "aa": -1,
                                    "ai": -1,
                                    "presets": []
                                },
                                {
                                    "name": "Average",
                                    "code": "b",
                                    "perma": "average",
                                    "aa": 0,
                                    "ai": 0,
                                    "presets": [
                                        "B",
                                        "L",
                                        "A",
                                        "I"
                                    ]
                                },
                                {
                                    "name": "High",
                                    "code": "c",
                                    "perma": "high",
                                    "aa": 1,
                                    "ai": 1,
                                    "presets": []
                                }
                            ]
                        }
                    ],
                    "technologies": [
                        {
                            "name": "Spring-Mass FLEX",
                            "description": "Acoustically insulating multilayer made of a polymeric acoustic barrier and a polyurethane foam decoupler.",
                            "code": "A",
                            "perma": "carpet-spring-mass-flex",
                            "presets": [
                                "B"
                            ],
                            "variables": [
                                {
                                    "name": "Decoupler stiffness",
                                    "description": "Stiffness of the decoupling layer",
                                    "code": "D",
                                    "options": [
                                        {
                                            "name": "Low",
                                            "code": "a",
                                            "perma": "low",
                                            "keys": {
                                                "AI": 7,
                                                "DF": 10,
                                                "AA": 2,
                                                "L": 2,
                                                "S": 3,
                                                "VO": 3
                                            },
                                            "presets": []
                                        },
                                        {
                                            "name": "Medium",
                                            "code": "b",
                                            "perma": "medium",
                                            "keys": {
                                                "AI": 7,
                                                "AA": 2,
                                                "DF": 9,
                                                "L": 2,
                                                "S": 3,
                                                "VO": 3
                                            },
                                            "presets": []
                                        },
                                        {
                                            "name": "High",
                                            "code": "c",
                                            "perma": "high",
                                            "keys": {
                                                "AI": 6,
                                                "AA": 2,
                                                "DF": 9,
                                                "L": 2,
                                                "S": 3,
                                                "VO": 3
                                            },
                                            "presets": [
                                                "B"
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "name": "Insulative layer density",
                                    "description": "Area weight of the heavy layer",
                                    "code": "I",
                                    "options": [
                                        {
                                            "name": "Light",
                                            "code": "a",
                                            "perma": "light",
                                            "keys": {
                                                "AI": 7,
                                                "DF": 9,
                                                "AA": 2,
                                                "L": 2,
                                                "S": 3,
                                                "VO": 3
                                            },
                                            "presets": [
                                                "B"
                                            ]
                                        },
                                        {
                                            "name": "Heavy",
                                            "code": "b",
                                            "perma": "heavy",
                                            "keys": {
                                                "AI": 6,
                                                "AA": 2,
                                                "DF": 10,
                                                "L": 1,
                                                "S": 3,
                                                "VO": 3
                                            },
                                            "presets": []
                                        }
                                    ]
                                }
                            ],
                            "multiKeys": {
                                "Da": {
                                    "Ia": {
                                        "AI": 7,
                                        "DF": 9,
                                        "S": 3,
                                        "VO": 3,
                                        "L": 2,
                                        "AA": 2
                                    },
                                    "Ib": {
                                        "AI": 8,
                                        "AA": 2,
                                        "DF": 10,
                                        "L": 1,
                                        "S": 3,
                                        "VO": 3
                                    }
                                },
                                "Dc": {
                                    "Ia": {
                                        "AI": 5,
                                        "AA": 2,
                                        "DF": 9,
                                        "L": 2,
                                        "S": 3,
                                        "VO": 3
                                    },
                                    "Ib": {
                                        "AI": 6,
                                        "AA": 2,
                                        "DF": 10,
                                        "L": 1,
                                        "S": 3,
                                        "VO": 3
                                    }
                                },
                                "Db": {
                                    "Ia": {
                                        "AI": 6,
                                        "AA": 2,
                                        "DF": 9,
                                        "L": 2,
                                        "S": 3,
                                        "VO": 3
                                    },
                                    "Ib": {
                                        "AI": 7,
                                        "AA": 2,
                                        "DF": 10,
                                        "L": 1,
                                        "S": 3,
                                        "VO": 3
                                    }
                                }
                            }
                        },
                        {
                            "name": "Spring-Mass ECO",
                            "description": "Acoustically insulating multilayer made of a polymeric acoustic barrier and a felt decoupler",
                            "code": "B",
                            "perma": "carpet-spring-mass-eco",
                            "presets": [
                                "I"
                            ],
                            "variables": [
                                {
                                    "name": "Decoupler stiffness",
                                    "description": "Stiffness of the decoupling layer",
                                    "code": "D",
                                    "options": [
                                        {
                                            "name": "Low",
                                            "code": "a",
                                            "perma": "low",
                                            "keys": {
                                                "AI": 9,
                                                "AA": 2,
                                                "DF": 2,
                                                "L": 2,
                                                "S": 5,
                                                "VO": 4
                                            },
                                            "presets": [
                                                "I"
                                            ]
                                        },
                                        {
                                            "name": "Medium",
                                            "code": "b",
                                            "perma": "medium",
                                            "keys": {
                                                "AI": 8,
                                                "AA": 2,
                                                "DF": 2,
                                                "L": 2,
                                                "S": 5,
                                                "VO": 4
                                            },
                                            "presets": []
                                        },
                                        {
                                            "name": "High",
                                            "code": "c",
                                            "perma": "high",
                                            "keys": {
                                                "AI": 9,
                                                "AA": 2,
                                                "DF": 2,
                                                "L": 2,
                                                "S": 5,
                                                "VO": 4
                                            },
                                            "presets": [
                                                "B"
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "name": "Insulative layer density",
                                    "description": "Area weight of the heavy layer",
                                    "code": "I",
                                    "options": [
                                        {
                                            "name": "Light",
                                            "code": "a",
                                            "perma": "light",
                                            "keys": {
                                                "AI": 8,
                                                "AA": 2,
                                                "DF": 2,
                                                "L": 2,
                                                "S": 5,
                                                "VO": 4
                                            },
                                            "presets": [
                                                "B"
                                            ]
                                        },
                                        {
                                            "name": "Heavy",
                                            "code": "b",
                                            "perma": "heavy",
                                            "keys": {
                                                "AI": 9,
                                                "AA": 2,
                                                "DF": 3,
                                                "L": 1,
                                                "S": 5,
                                                "VO": 4
                                            },
                                            "presets": [
                                                "I"
                                            ]
                                        }
                                    ]
                                }
                            ],
                            "multiKeys": {
                                "Da": {
                                    "Ia": {
                                        "AI": 8,
                                        "AA": 2,
                                        "DF": 2,
                                        "L": 2,
                                        "S": 5,
                                        "VO": 4
                                    },
                                    "Ib": {
                                        "AI": 9,
                                        "AA": 2,
                                        "DF": 3,
                                        "L": 1,
                                        "S": 5,
                                        "VO": 4
                                    }
                                },
                                "Db": {
                                    "Ia": {
                                        "AI": 8,
                                        "AA": 2,
                                        "DF": 2,
                                        "L": 2,
                                        "S": 5,
                                        "VO": 4
                                    },
                                    "Ib": {
                                        "AI": 9,
                                        "AA": 2,
                                        "DF": 3,
                                        "L": 1,
                                        "S": 5,
                                        "VO": 4
                                    }
                                },
                                "Dc": {
                                    "Ia": {
                                        "AI": 8,
                                        "AA": 2,
                                        "DF": 2,
                                        "L": 2,
                                        "S": 5,
                                        "VO": 4
                                    },
                                    "Ib": {
                                        "AI": 9,
                                        "AA": 2,
                                        "DF": 3,
                                        "L": 1,
                                        "S": 5,
                                        "VO": 4
                                    }
                                }
                            }
                        },
                        {
                            "name": "Prime-Light",
                            "description": "Acoustically absorbing multilayer made of a felt-based airflow resistive layer and a felt decoupler. ",
                            "code": "C",
                            "perma": "carpet-primelight",
                            "presets": [
                                "A",
                                "L"
                            ],
                            "variables": [
                                {
                                    "name": "Construction",
                                    "description": "Area weight of the felt",
                                    "code": "C",
                                    "options": [
                                        {
                                            "name": "Light",
                                            "code": "a",
                                            "perma": "light",
                                            "keys": {
                                                "AA": 8,
                                                "AI": 3,
                                                "DF": 6,
                                                "L": 9,
                                                "S": 7,
                                                "VO": 7
                                            },
                                            "presets": [
                                                "B",
                                                "L"
                                            ]
                                        },
                                        {
                                            "name": "Medium",
                                            "code": "b",
                                            "perma": "medium",
                                            "keys": {
                                                "AA": 8,
                                                "AI": 4,
                                                "DF": 7,
                                                "L": 8,
                                                "S": 7,
                                                "VO": 7
                                            },
                                            "presets": []
                                        },
                                        {
                                            "name": "Heavy",
                                            "code": "c",
                                            "perma": "heavy",
                                            "keys": {
                                                "AA": 8,
                                                "AI": 5,
                                                "DF": 8,
                                                "L": 7,
                                                "S": 7,
                                                "VO": 7
                                            },
                                            "presets": [
                                                "A"
                                            ]
                                        }
                                    ]
                                }
                            ],
                            "multiKeys": null
                        },
                        {
                            "name": "Hybrid-Acoustics ECO+",
                            "description": "Acoustically insulating and absorbing multilayer made of a felt acoustic barrier, an impervious film and a felt decoupler. ",
                            "code": "E",
                            "perma": "carpet-hybrid-acoustic-eco",
                            "presets": [],
                            "variables": [
                                {
                                    "name": "Construction",
                                    "description": "Area weight of the felt",
                                    "code": "C",
                                    "options": [
                                        {
                                            "name": "Absorptive",
                                            "code": "a",
                                            "perma": "absorptive",
                                            "keys": {
                                                "AA": 7,
                                                "AI": 6,
                                                "DF": 5,
                                                "L": 5,
                                                "S": 7,
                                                "VO": 7
                                            },
                                            "presets": [
                                                "B"
                                            ]
                                        },
                                        {
                                            "name": "Insulative",
                                            "code": "b",
                                            "perma": "insulative",
                                            "keys": {
                                                "AA": 4,
                                                "AI": 8,
                                                "DF": 5,
                                                "L": 5,
                                                "S": 7,
                                                "VO": 7
                                            },
                                            "presets": []
                                        }
                                    ]
                                }
                            ],
                            "multiKeys": null
                        },
                        {
                            "name": "Hybrid-Acoustics FLEX",
                            "description": "Acoustically insulating and absorbing multilayer made of a felt acoustic barrier, an impervious film and a Polyurethane foam decoupler.",
                            "code": "F",
                            "perma": "carpet-hybrid-acoustic-flex",
                            "presets": [],
                            "variables": [
                                {
                                    "name": "Construction",
                                    "description": "Area weight of the felt",
                                    "code": "C",
                                    "options": [
                                        {
                                            "name": "Absorptive",
                                            "code": "a",
                                            "perma": "absorptive",
                                            "keys": {
                                                "AA": 7,
                                                "AI": 5,
                                                "DF": 10,
                                                "L": 5,
                                                "S": 4,
                                                "VO": 6
                                            },
                                            "presets": [
                                                "B"
                                            ]
                                        },
                                        {
                                            "name": "Insulative",
                                            "code": "b",
                                            "perma": "insulative",
                                            "keys": {
                                                "AA": 4,
                                                "AI": 7,
                                                "DF": 10,
                                                "L": 5,
                                                "S": 4,
                                                "VO": 6
                                            },
                                            "presets": []
                                        }
                                    ]
                                }
                            ],
                            "multiKeys": null
                        }
                    ]
                },
                {
                    "name": "Inner Dash",
                    "perma": "inner-dash",
                    "code": "D",
                    "description": "Located behind the instrument panel, the inner dash reduces the powertrain noise inside the cabin by means of absorption, insulation or both (hybrid constructions). Grommets and their interface with the inner dash are key to guarantee good acoustic performance, especially at high frequencies (above 3kHz).",
                    "powertrains": [
                        "I",
                        "H",
                        "B"
                    ],
                    "bodyStyles": [
                        "C",
                        "A",
                        "B"
                    ],
                    "productVariables": [
                        {
                            "name": "Pass-Through",
                            "description": "Sealing of the openings located on the dash, needed for cables, pipes and other components.",
                            "perma": "pass-through",
                            "code": "PT",
                            "options": [
                                {
                                    "name": "Poor",
                                    "code": "a",
                                    "perma": "low",
                                    "aa": -1,
                                    "ai": -1,
                                    "presets": []
                                },
                                {
                                    "name": "Average",
                                    "code": "b",
                                    "perma": "average",
                                    "aa": 0,
                                    "ai": 0,
                                    "presets": [
                                        "B",
                                        "L",
                                        "A",
                                        "I"
                                    ]
                                },
                                {
                                    "name": "Best-in-class",
                                    "code": "c",
                                    "perma": "high",
                                    "aa": 1,
                                    "ai": 1,
                                    "presets": []
                                }
                            ]
                        },
                        {
                            "name": "Coverage",
                            "description": "Percentage of body covered. Low coverage weakens part performance, notably in insulation.",
                            "perma": "coverage",
                            "code": "C",
                            "options": [
                                {
                                    "name": "Low",
                                    "code": "a",
                                    "perma": "low",
                                    "aa": -1,
                                    "ai": -1,
                                    "presets": []
                                },
                                {
                                    "name": "Average",
                                    "code": "b",
                                    "perma": "average",
                                    "aa": 0,
                                    "ai": 0,
                                    "presets": [
                                        "B",
                                        "L",
                                        "A",
                                        "I"
                                    ]
                                },
                                {
                                    "name": "High",
                                    "code": "c",
                                    "perma": "high",
                                    "aa": 1,
                                    "ai": 1,
                                    "presets": []
                                }
                            ]
                        },
                        {
                            "name": "Packaging Space",
                            "description": "Thickness distribution of the part. Thin areas weaken part performances, especially in insulation.",
                            "perma": "packaging-space",
                            "code": "PS",
                            "options": [
                                {
                                    "name": "Low",
                                    "code": "a",
                                    "perma": "low",
                                    "aa": -1,
                                    "ai": -1,
                                    "presets": []
                                },
                                {
                                    "name": "Average",
                                    "code": "b",
                                    "perma": "average",
                                    "aa": 0,
                                    "ai": 0,
                                    "presets": [
                                        "B",
                                        "L",
                                        "A",
                                        "I"
                                    ]
                                },
                                {
                                    "name": "High",
                                    "code": "c",
                                    "perma": "high",
                                    "aa": 1,
                                    "ai": 1,
                                    "presets": []
                                }
                            ]
                        }
                    ],
                    "technologies": [
                        {
                            "name": "Spring-Mass FLEX",
                            "description": "Acoustically insulating multilayer made of a polymeric acoustic barrier and a polyurethane foam decoupler.",
                            "code": "A",
                            "perma": "dash-spring-mass-flex",
                            "presets": [
                                "B"
                            ],
                            "variables": [
                                {
                                    "name": "Decoupler stiffness",
                                    "description": "Stiffness of the decoupling layer",
                                    "code": "D",
                                    "options": [
                                        {
                                            "name": "Low",
                                            "code": "a",
                                            "perma": "low",
                                            "keys": {
                                                "AA": 2,
                                                "AI": 7,
                                                "DF": 9,
                                                "L": 2,
                                                "S": 3,
                                                "VO": 3
                                            },
                                            "presets": [
                                                "I"
                                            ]
                                        },
                                        {
                                            "name": "Medium",
                                            "code": "b",
                                            "perma": "medium",
                                            "keys": {
                                                "AA": 2,
                                                "AI": 6,
                                                "DF": 9,
                                                "L": 2,
                                                "S": 3,
                                                "VO": 3
                                            },
                                            "presets": []
                                        },
                                        {
                                            "name": "High",
                                            "code": "c",
                                            "perma": "high",
                                            "keys": {
                                                "AA": 2,
                                                "AI": 5,
                                                "DF": 9,
                                                "L": 2,
                                                "S": 3,
                                                "VO": 3
                                            },
                                            "presets": [
                                                "B"
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "name": "Insulative layer density",
                                    "description": "Area weight of the heavy layer",
                                    "code": "I",
                                    "options": [
                                        {
                                            "name": "Light",
                                            "code": "a",
                                            "perma": "light",
                                            "keys": {
                                                "AA": 2,
                                                "AI": 6,
                                                "DF": 9,
                                                "L": 2,
                                                "S": 3,
                                                "VO": 3
                                            },
                                            "presets": [
                                                "B"
                                            ]
                                        },
                                        {
                                            "name": "Heavy",
                                            "code": "b",
                                            "perma": "heavy",
                                            "keys": {
                                                "AA": 2,
                                                "AI": 7,
                                                "DF": 10,
                                                "L": 1,
                                                "S": 3,
                                                "VO": 3
                                            },
                                            "presets": [
                                                "I"
                                            ]
                                        }
                                    ]
                                }
                            ],
                            "multiKeys": {
                                "Da": {
                                    "Ia": {
                                        "AA": 2,
                                        "AI": 7,
                                        "DF": 9,
                                        "L": 2,
                                        "S": 3,
                                        "VO": 3
                                    },
                                    "Ib": {
                                        "AA": 2,
                                        "AI": 8,
                                        "DF": 10,
                                        "L": 1,
                                        "S": 3,
                                        "VO": 3
                                    }
                                },
                                "Db": {
                                    "Ia": {
                                        "AA": 2,
                                        "AI": 6,
                                        "DF": 9,
                                        "L": 2,
                                        "S": 3,
                                        "VO": 3
                                    },
                                    "Ib": {
                                        "AA": 2,
                                        "AI": 7,
                                        "DF": 10,
                                        "L": 1,
                                        "S": 3,
                                        "VO": 3
                                    }
                                },
                                "Dc": {
                                    "Ia": {
                                        "AA": 2,
                                        "AI": 5,
                                        "DF": 9,
                                        "L": 2,
                                        "S": 3,
                                        "VO": 3
                                    },
                                    "Ib": {
                                        "AA": 2,
                                        "AI": 6,
                                        "DF": 10,
                                        "L": 1,
                                        "S": 3,
                                        "VO": 3
                                    }
                                }
                            }
                        },
                        {
                            "name": "Spring-Mass ECO",
                            "description": "Acoustically insulating multilayer made of a polymeric acoustic barrier and a felt decoupler.",
                            "code": "B",
                            "perma": "dash-spring-mass-eco",
                            "presets": [
                                "I"
                            ],
                            "variables": [
                                {
                                    "name": "Decoupler stiffness",
                                    "description": "Stiffness of the decoupling layer",
                                    "code": "D",
                                    "options": [
                                        {
                                            "name": "Low",
                                            "code": "a",
                                            "perma": "low",
                                            "keys": {
                                                "AA": 2,
                                                "AI": 8,
                                                "DF": 2,
                                                "L": 2,
                                                "S": 5,
                                                "VO": 4
                                            },
                                            "presets": [
                                                "I"
                                            ]
                                        },
                                        {
                                            "name": "Medium",
                                            "code": "b",
                                            "perma": "medium",
                                            "keys": {
                                                "AA": 2,
                                                "AI": 8,
                                                "DF": 2,
                                                "L": 2,
                                                "S": 5,
                                                "VO": 4
                                            },
                                            "presets": []
                                        },
                                        {
                                            "name": "High",
                                            "code": "c",
                                            "perma": "high",
                                            "keys": {
                                                "AA": 2,
                                                "AI": 8,
                                                "DF": 2,
                                                "L": 2,
                                                "S": 5,
                                                "VO": 4
                                            },
                                            "presets": [
                                                "B"
                                            ]
                                        }
                                    ]
                                },
                                {
                                    "name": "Insulative layer density",
                                    "description": "Area weight of the heavy layer",
                                    "code": "I",
                                    "options": [
                                        {
                                            "name": "Light",
                                            "code": "a",
                                            "perma": "light",
                                            "keys": {
                                                "AA": 2,
                                                "AI": 8,
                                                "DF": 2,
                                                "L": 2,
                                                "S": 5,
                                                "VO": 4
                                            },
                                            "presets": [
                                                "B"
                                            ]
                                        },
                                        {
                                            "name": "Heavy",
                                            "code": "b",
                                            "perma": "heavy",
                                            "keys": {
                                                "AA": 2,
                                                "AI": 9,
                                                "DF": 3,
                                                "L": 1,
                                                "S": 5,
                                                "VO": 4
                                            },
                                            "presets": [
                                                "I"
                                            ]
                                        }
                                    ]
                                }
                            ],
                            "multiKeys": {
                                "Da": {
                                    "Ia": {
                                        "AA": 2,
                                        "AI": 8,
                                        "DF": 2,
                                        "L": 2,
                                        "S": 5,
                                        "VO": 4
                                    },
                                    "Ib": {
                                        "AA": 2,
                                        "AI": 9,
                                        "DF": 3,
                                        "L": 1,
                                        "S": 5,
                                        "VO": 4
                                    }
                                },
                                "Db": {
                                    "Ia": {
                                        "AA": 2,
                                        "AI": 8,
                                        "DF": 2,
                                        "L": 2,
                                        "S": 5,
                                        "VO": 4
                                    },
                                    "Ib": {
                                        "AA": 2,
                                        "AI": 9,
                                        "DF": 3,
                                        "L": 1,
                                        "S": 5,
                                        "VO": 4
                                    }
                                },
                                "Dc": {
                                    "Ia": {
                                        "AA": 2,
                                        "AI": 8,
                                        "DF": 2,
                                        "L": 2,
                                        "S": 5,
                                        "VO": 4
                                    },
                                    "Ib": {
                                        "AA": 2,
                                        "AI": 9,
                                        "DF": 3,
                                        "L": 1,
                                        "S": 5,
                                        "VO": 4
                                    }
                                }
                            }
                        },
                        {
                            "name": "Prime-Light",
                            "description": "Acoustically absorbing multilayer made of a felt airflow resistive layer and a felt decoupler.   ",
                            "code": "C",
                            "perma": "dash-primelight",
                            "presets": [
                                "L",
                                "A"
                            ],
                            "variables": [
                                {
                                    "name": "Construction",
                                    "description": "Area weight of the felt",
                                    "code": "C",
                                    "options": [
                                        {
                                            "name": "Light",
                                            "code": "a",
                                            "perma": "light",
                                            "keys": {
                                                "AA": 8,
                                                "AI": 3,
                                                "DF": 6,
                                                "L": 9,
                                                "S": 7,
                                                "VO": 7
                                            },
                                            "presets": [
                                                "B",
                                                "L"
                                            ]
                                        },
                                        {
                                            "name": "Medium",
                                            "code": "b",
                                            "perma": "medium",
                                            "keys": {
                                                "AA": 8,
                                                "AI": 4,
                                                "DF": 7,
                                                "L": 8,
                                                "S": 7,
                                                "VO": 7
                                            },
                                            "presets": []
                                        },
                                        {
                                            "name": "Heavy",
                                            "code": "c",
                                            "perma": "heavy",
                                            "keys": {
                                                "AA": 8,
                                                "AI": 5,
                                                "DF": 8,
                                                "L": 7,
                                                "S": 7,
                                                "VO": 7
                                            },
                                            "presets": [
                                                "A"
                                            ]
                                        }
                                    ]
                                }
                            ],
                            "multiKeys": null
                        },
                        {
                            "name": "Hybrid-Acoustics ECO",
                            "description": "Acoustically insulating and absorbing multilayer made of a felt acoustic barrier, an impervious film and a felt decoupler. ",
                            "code": "E",
                            "perma": "dash-hybrid-acoustic-eco",
                            "presets": [],
                            "variables": [
                                {
                                    "name": "Construction",
                                    "description": "Area weight of the felt",
                                    "code": "C",
                                    "options": [
                                        {
                                            "name": "Absorptive",
                                            "code": "a",
                                            "perma": "absorptive",
                                            "keys": {
                                                "AA": 7,
                                                "AI": 6,
                                                "DF": 6,
                                                "L": 5,
                                                "S": 7,
                                                "VO": 7
                                            },
                                            "presets": []
                                        },
                                        {
                                            "name": "Insulative",
                                            "code": "b",
                                            "perma": "insulative",
                                            "keys": {
                                                "AA": 4,
                                                "AI": 8,
                                                "DF": 4,
                                                "L": 5,
                                                "S": 7,
                                                "VO": 7
                                            },
                                            "presets": [
                                                "B"
                                            ]
                                        },
                                        {
                                            "name": "Hybrid",
                                            "code": "c",
                                            "perma": "mixed",
                                            "keys": {
                                                "AA": 6,
                                                "AI": 7,
                                                "DF": 5,
                                                "L": 5,
                                                "S": 7,
                                                "VO": 7
                                            },
                                            "presets": []
                                        }
                                    ]
                                }
                            ],
                            "multiKeys": null
                        },
                        {
                            "name": "Hybrid-Acoustics FLEX",
                            "description": "Acoustically insulating and absorbing multilayer made of a felt acoustic barrier, an impervious film and a Polyurethane foam decoupler.",
                            "code": "F",
                            "perma": "dash-hybrid-acoustic-flex",
                            "presets": [],
                            "variables": [
                                {
                                    "name": "Construction",
                                    "description": "Area weight of the felt",
                                    "code": "C",
                                    "options": [
                                        {
                                            "name": "Absorptive",
                                            "code": "a",
                                            "perma": "absorptive",
                                            "keys": {
                                                "AA": 7,
                                                "AI": 5,
                                                "DF": 9,
                                                "L": 5,
                                                "S": 5,
                                                "VO": 6
                                            },
                                            "presets": []
                                        },
                                        {
                                            "name": "Insulative",
                                            "code": "b",
                                            "perma": "insulative",
                                            "keys": {
                                                "AA": 4,
                                                "AI": 7,
                                                "DF": 9,
                                                "L": 5,
                                                "S": 5,
                                                "VO": 6
                                            },
                                            "presets": [
                                                "B"
                                            ]
                                        },
                                        {
                                            "name": "Hybrid",
                                            "code": "c",
                                            "perma": "mixed",
                                            "keys": {
                                                "AA": 6,
                                                "AI": 6,
                                                "DF": 9,
                                                "L": 5,
                                                "S": 5,
                                                "VO": 6
                                            },
                                            "presets": []
                                        }
                                    ]
                                }
                            ],
                            "multiKeys": null
                        }
                    ]
                },
                {
                    "name": "Outer Dash",
                    "perma": "outer-dash",
                    "code": "O",
                    "description": "Located in the engine bay, outer dashes dissipate powertrain noise close to the source.",
                    "powertrains": [
                        "I",
                        "H",
                        "B"
                    ],
                    "bodyStyles": [
                        "C",
                        "A",
                        "B"
                    ],
                    "technologyOptions": [
                        {
                            "name": "N.A.",
                            "description": "No technology applied",
                            "perma": "nothing",
                            "code": "1",
                            "weight": 0,
                            "keys": {
                                "CR": 1,
                                "WS": 10,
                                "R": 10,
                                "EN": 1,
                                "AE": 1,
                                "IN": 1
                            },
                            "presets": []
                        },
                        {
                            "name": "Standard glasswool",
                            "description": "Used as a single-layer solution, this material has acoustic absorption properties and resists to high temperatures.",
                            "perma": "standard-glassfiber-felt",
                            "code": "3",
                            "weight": 0.54,
                            "keys": {
                                "CR": 2,
                                "WS": 7,
                                "R": 5,
                                "EN": 8,
                                "IN": 3,
                                "AE": 5
                            },
                            "presets": [
                                "B"
                            ]
                        },
                        {
                            "name": "Thermoset felt",
                            "description": "Used as a single-layer solution, this cotton-based material has good acoustic absorption properties.",
                            "perma": "ts-felt",
                            "code": "4",
                            "weight": 0.49,
                            "keys": {
                                "CR": 2,
                                "WS": 6,
                                "R": 5,
                                "EN": 7,
                                "IN": 3,
                                "AE": 5
                            },
                            "presets": [
                                "L"
                            ]
                        },
                        {
                            "name": "Theta-Cell",
                            "description": "Innovative polyurethane foam material for noise and heat protection application in the engine bay applications. It allows weight savings of up to 60% compared to common fiber technologies used in the engine bay.",
                            "perma": "theta-cell",
                            "code": "2",
                            "weight": 0.12,
                            "keys": {
                                "CR": 2,
                                "WS": 8,
                                "R": 2,
                                "EN": 8,
                                "IN": 3,
                                "AE": 5
                            },
                            "presets": [
                                "A",
                                "I"
                            ]
                        }
                    ]
                },
                {
                    "name": "Hoodliner",
                    "perma": "hoodliner",
                    "code": "H",
                    "description": "A hoodliner is a noise absorber that is fixed on the inner side of the hood to dissipate powertrain noise close to the source.",
                    "powertrains": [
                        "I",
                        "H",
                        "B"
                    ],
                    "bodyStyles": [
                        "C",
                        "A",
                        "B"
                    ],
                    "technologyOptions": [
                        {
                            "name": "Standard glasswool",
                            "description": "Used as a single-layer solution, this material has acoustic absorption properties and resists to high temperatures.",
                            "perma": "standard-glassfiber-felt",
                            "code": "1",
                            "weight": 0.85,
                            "keys": {
                                "CR": 2,
                                "WS": 7,
                                "R": 5,
                                "EN": 8,
                                "IN": 3,
                                "AE": 5
                            },
                            "presets": [
                                "B"
                            ]
                        },
                        {
                            "name": "N.A.",
                            "description": "No technology applied",
                            "perma": "nothing",
                            "code": "3",
                            "weight": 0,
                            "keys": {
                                "CR": 1,
                                "WS": 10,
                                "R": 10,
                                "EN": 1,
                                "IN": 1,
                                "AE": 1
                            },
                            "presets": []
                        },
                        {
                            "name": "Theta-Cell",
                            "description": "Innovative polyurethane foam material for noise and heat protection application in the engine bay applications. It allows weight savings of up to 60% compared to common fiber technologies used in the engine bay.",
                            "perma": "theta-cell",
                            "code": "4",
                            "weight": 0.38,
                            "keys": {
                                "CR": 2,
                                "WS": 8,
                                "R": 2,
                                "EN": 8,
                                "IN": 3,
                                "AE": 5
                            },
                            "presets": [
                                "A",
                                "I"
                            ]
                        },
                        {
                            "name": "Thermoset felt",
                            "description": "Used as a single-layer solution, this cotton-based material has good acoustic absorption properties.",
                            "perma": "ts-felt",
                            "code": "2",
                            "weight": 0.77,
                            "keys": {
                                "CR": 2,
                                "WS": 6,
                                "R": 5,
                                "EN": 7,
                                "IN": 3,
                                "AE": 5
                            },
                            "presets": [
                                "L"
                            ]
                        }
                    ]
                },
                {
                    "name": "Engine Encapsulation",
                    "perma": "engine-encapsulation",
                    "code": "N",
                    "description": "Engine contact treatment allows to treat noise at the source for maximum efficiency of the sound pack. It minimizes the noise emitted both to the interior and the exterior of the vehicle. In addition, Engine Encapsulation helps to store heat in the engine bay for longer periods so that less fuel is used for cold starts, thereby reducing vehicle's emissions.",
                    "powertrains": [
                        "I",
                        "H"
                    ],
                    "bodyStyles": [
                        "C",
                        "A",
                        "B"
                    ],
                    "technologyOptions": [
                        {
                            "name": "N.A.",
                            "description": "No technology applied",
                            "perma": "nothing",
                            "code": "1",
                            "weight": 0,
                            "keys": {
                                "CR": 1,
                                "WS": 10,
                                "R": 10,
                                "EN": 1,
                                "IN": 1,
                                "AE": 1
                            },
                            "presets": [
                                "B"
                            ]
                        },
                        {
                            "name": "Theta-FiberCell",
                            "description": "Multi-layer material developed specifically for demanding engine bay applications. As well as the acoustic absorption of interior and exterior noise, this technology provides thermal insulation and high temperature stability up to 200C in peak. Theta-FiberCell also appeals due to its lightweight compared to solid plastic, low flammability and displays high resistance towards engine vibrations.",
                            "perma": "theta-fibercell",
                            "code": "3",
                            "weight": 0.3,
                            "keys": {
                                "CR": 3,
                                "WS": 8,
                                "R": 1,
                                "EN": 8,
                                "IN": 3,
                                "AE": 5
                            },
                            "presets": [
                                "L",
                                "A"
                            ]
                        },
                        {
                            "name": "Hybrid-Acoustics PET",
                            "description": "Multi-layered and engine-mounted felt technology that simulteneously absorbs and insulates the noise of ICE and e-motors. Hybrid-Acoustics PET thus contributes to optimum acoustics in the vehicle. The technology is also particularly environmentally-friendly: the base material consists largely of recycled PET fibers, is glass-free and is manufactured in a zero-waste manufacturing process.",
                            "perma": "theta-felt",
                            "code": "2",
                            "weight": 0.76,
                            "keys": {
                                "CR": 3,
                                "WS": 8,
                                "R": 9,
                                "EN": 8,
                                "IN": 3,
                                "AE": 5
                            },
                            "presets": [
                                "I"
                            ]
                        }
                    ]
                },
                {
                    "name": "E-motor Encapsulation",
                    "perma": "e-motor-encapsulation",
                    "code": "M",
                    "description": "The e-motor treatment reduces noise at the source for maximum efficiency of the sound pack. Autoneum's NVH optimized solutions provide a superior balance between insulation and absorption.",
                    "powertrains": [
                        "B"
                    ],
                    "bodyStyles": [
                        "C",
                        "A",
                        "B"
                    ],
                    "technologyOptions": [
                        {
                            "name": "Hybrid-Acoustics PET",
                            "description": "Multi-layered and engine-mounted felt technology that simulteneously absorbs and insulates the noise of ICE and e-motors. Hybrid-Acoustics PET thus contributes to optimum acoustics in the vehicle. The technology is also particularly environmentally-friendly: the base material consists largely of recycled PET fibers, is glass-free and is manufactured in a zero-waste manufacturing process.",
                            "perma": "theta-felt",
                            "code": "1",
                            "weight": 0.38,
                            "keys": {
                                "IN": 8,
                                "S": 9,
                                "EN": 8,
                                "WS": 8
                            },
                            "presets": [
                                "B",
                                "L",
                                "I",
                                "A"
                            ]
                        }
                    ]
                },
                {
                    "name": "Engine Top Cover",
                    "perma": "engine-top-cover",
                    "code": "T",
                    "description": "By encapsulating the engine's top face and thereby absorbing engine noise, this part contributes to improved acoustics in the passenger compartment and enhanced driving comfort. Autoneum engine top covers are made out of textile with integrated acoustic function, allowing weight savings of more than 50% compared to conventional solutions made of solid plastic with additional absorbing pads. ",
                    "powertrains": [
                        "I",
                        "H"
                    ],
                    "bodyStyles": [
                        "C",
                        "A",
                        "B"
                    ],
                    "technologyOptions": [
                        {
                            "name": "Theta-FiberCell",
                            "description": "Multi-layer material developed specifically for demanding engine bay applications. As well as the acoustic absorption of interior and exterior noise, this technology provides thermal insulation and high temperature stability up to 200C in peak. Theta-FiberCell also appeals due to its lightweight compared to solid plastic, low flammability and displays high resistance towards engine vibrations.",
                            "perma": "theta-fibercell",
                            "code": "2",
                            "weight": 0.13,
                            "keys": {
                                "CR": 2,
                                "WS": 8,
                                "R": 1,
                                "EN": 8,
                                "IN": 3,
                                "AE": 5
                            },
                            "presets": [
                                "L",
                                "A",
                                "I"
                            ]
                        },
                        {
                            "name": "N.A.",
                            "description": "No technology applied",
                            "perma": "nothing",
                            "code": "1",
                            "weight": 0,
                            "keys": {
                                "CR": 1,
                                "WS": 10,
                                "R": 10,
                                "EN": 1,
                                "IN": 1,
                                "AE": 1
                            },
                            "presets": [
                                "B"
                            ]
                        }
                    ]
                },
                {
                    "name": "Frunk",
                    "perma": "frunk",
                    "code": "F",
                    "description": "The frunk or front trunk allows for an extra storage room under the hood. Autoneum proposes a patented semi-structural textile solution which is simple, as one part replaces assembly of different plastic and trim components, offers 50% lower weight compared to current solutions, and has an additional acoustic function integrated in the noise absorbing textile of the carrier.\n",
                    "powertrains": [
                        "B"
                    ],
                    "bodyStyles": [
                        "C",
                        "A",
                        "B"
                    ],
                    "technologyOptions": [
                        {
                            "name": "Ultra-Silent",
                            "description": "Textile lightweight technology that is up to 50% lighter than plastic. It is PET-based, glass-free, water and heat resistant and fully recyclable. Underbody systems based on Ultra-Silent offer high impact resistance, optimum stone impact protection and reduce vehicle noise thanks to the large absorbing area.",
                            "perma": "ultra-silent",
                            "code": "1",
                            "weight": 0.7,
                            "keys": {
                                "IN": 3,
                                "WS": 10,
                                "EN": 3,
                                "R": 9,
                                "AE": 10
                            },
                            "presets": [
                                "B",
                                "L",
                                "I",
                                "A"
                            ]
                        }
                    ]
                },
                {
                    "name": "Outer Tunnel Insulator",
                    "perma": "under-tunnel-shield",
                    "code": "A",
                    "description": "Located underneath the floor tunnel area, outer tunnel insulators reduce noise from the exterior and from the powertrain by means of absorption and/or insulation. They also have a thermal comfort function protecting against the heat from the engine bay and the exhaust system. ",
                    "powertrains": [
                        "I",
                        "H"
                    ],
                    "bodyStyles": [
                        "C",
                        "A",
                        "B"
                    ],
                    "technologyOptions": [
                        {
                            "name": "Aluminum",
                            "description": "Basic heatshields made of aluminum have specifically a thermal protection function. Autoneum is specialized on the design of single-layer and multi-layer solutions depending on source temperature, boundary conditions and durability requirements.",
                            "perma": "aluminium",
                            "code": "1",
                            "weight": 0.95,
                            "keys": {
                                "HP": 8,
                                "R": 9,
                                "EN": 1
                            },
                            "presets": [
                                "B",
                                "I"
                            ]
                        },
                        {
                            "name": "RIMIC Multi-Layer",
                            "description": "RIMIC can also be used as multi-layer and in combination with additional sound absorbing materials to ensure an advanced acoustic performance.",
                            "perma": "rimic-multi",
                            "code": "3",
                            "weight": 1.15,
                            "keys": {
                                "HP": 10,
                                "R": 8,
                                "EN": 5
                            },
                            "presets": [
                                "A"
                            ]
                        },
                        {
                            "name": "RIMIC single-layer",
                            "description": "Lightweight, fully recyclable technology for heatshields that not only protect against heat but also absorb noise thanks to a special perforation developed by Autoneum.",
                            "perma": "rimic-single",
                            "code": "2",
                            "weight": 0.92,
                            "keys": {
                                "HP": 8,
                                "R": 9,
                                "EN": 3
                            },
                            "presets": []
                        },
                        {
                            "name": "Thermo-composite felt",
                            "description": "Typically applied to outer tunnel insulators. This felt-based material has good acoustic absorption properties. The needed thermal function is ensured by additional aluminum protection.",
                            "perma": "thermo-composite-felt",
                            "code": "4",
                            "weight": 0.64,
                            "keys": {
                                "HP": 7,
                                "R": 6,
                                "EN": 5
                            },
                            "presets": [
                                "L"
                            ]
                        }
                    ]
                },
                {
                    "name": "Underbody Shield",
                    "perma": "underbody-shield",
                    "code": "U",
                    "description": "Underbody systems enhance the aerodynamics of a vehicle affecting drag and lift, leading to lower fuel consumption and vehicle emissions. The textile and lightweight underbody shields of Autoneum also absorb noise and therefore reduce the interior and exterior noise (pass-by noise) of cars.",
                    "powertrains": [
                        "I",
                        "H",
                        "B"
                    ],
                    "bodyStyles": [
                        "C",
                        "A",
                        "B"
                    ],
                    "technologyOptions": [
                        {
                            "name": "N.A.",
                            "description": "No technology applied",
                            "perma": "nothing",
                            "code": "1",
                            "weight": 0,
                            "keys": {
                                "CR": 1,
                                "WS": 10,
                                "AC": 1,
                                "SN": 1,
                                "R": 10,
                                "EN": 1
                            },
                            "presets": [
                                "B"
                            ]
                        },
                        {
                            "name": "DLFT",
                            "description": "Plastic part reinforced with long glass fibers. This process enables lightweight plastic parts with good mechanical properties. ",
                            "perma": "dlft",
                            "code": "3",
                            "weight": 7.26,
                            "keys": {
                                "CR": 9,
                                "WS": 5,
                                "AC": 10,
                                "SN": 3,
                                "R": 3,
                                "EN": 3
                            },
                            "presets": []
                        },
                        {
                            "name": "DLFT + patch ERA",
                            "description": "The ERA patch (Exterior Resistant Absorber) reduces tire noise with outstanding resistance against dust and water. It is welded locally on top of a DLFT part.",
                            "perma": "dlft-patch",
                            "code": "4",
                            "weight": 7.81,
                            "keys": {
                                "CR": 9,
                                "WS": 4,
                                "AC": 10,
                                "SN": 3,
                                "R": 5,
                                "EN": 5
                            },
                            "presets": [
                                "I"
                            ]
                        },
                        {
                            "name": "Ultra-Silent",
                            "description": "Textile lightweight technology that is up to 50% lighter than plastic. It is PET-based, glass-free, water and heat resistant and fully recyclable. Underbody systems based on Ultra-Silent offer high impact resistance, optimum stone impact protection and reduce vehicle noise thanks to the large absorbing area.",
                            "perma": "ultra-silent",
                            "code": "2",
                            "weight": 3.3,
                            "keys": {
                                "CR": 9,
                                "WS": 8,
                                "AC": 10,
                                "SN": 10,
                                "R": 9,
                                "EN": 8
                            },
                            "presets": [
                                "L",
                                "A"
                            ]
                        }
                    ]
                },
                {
                    "name": "Wheelhouse Outer Liner",
                    "perma": "wheelhouse-outer-liner",
                    "code": "W",
                    "description": "Besides protecting the body-in-white from stone impact, textile wheelhouse outer liners absorb tire noise close to the noise source and contribute to reducing interior and exterior rolling noise.",
                    "powertrains": [
                        "I",
                        "H",
                        "B"
                    ],
                    "bodyStyles": [
                        "C",
                        "A",
                        "B"
                    ],
                    "technologyOptions": [
                        {
                            "name": "Injected plastic",
                            "description": "Plastic part (optionally reinforced with glass fibers) obtained by injection of molten thermo-plastic polymer in a mold. ",
                            "perma": "injected-plastic",
                            "code": "1",
                            "weight": 5.5,
                            "keys": {
                                "WS": 1,
                                "SN": 5,
                                "R": 5,
                                "EN": 1,
                                "AIC": 10
                            },
                            "presets": [
                                "B",
                                "I"
                            ]
                        },
                        {
                            "name": "Textile",
                            "description": "Needlepunched nonwoven textile material made of PET fibers and a binder which are put in shape in a moulding tool. It allows weight savings and good acoustic absorption.",
                            "perma": "textile",
                            "code": "2",
                            "weight": 2.5,
                            "keys": {
                                "WS": 10,
                                "SN": 10,
                                "R": 5,
                                "EN": 6,
                                "AIC": 5
                            },
                            "presets": [
                                "L"
                            ]
                        },
                        {
                            "name": "Alpha-Liner",
                            "description": "Alpha-Liner is a lightweight  textile wheelhouse outer liner with a thin coating applied on the inner (tire) side. It improves the acoustic absorption especially for exterior noise and prevents ice sticking on the part. ",
                            "perma": "alpha-liner",
                            "code": "4",
                            "weight": 3.13,
                            "keys": {
                                "WS": 9,
                                "SN": 10,
                                "R": 8,
                                "EN": 9,
                                "AIC": 10
                            },
                            "presets": []
                        },
                        {
                            "name": "Textile + patch ERA",
                            "description": "The ERA patch (Exterior Resistant Absorber) reduces tire noise with outstanding resistance against dust and water.  It is welded locally on top of a textile part, thereby enhancing its acoustic effectiveness against tyre noise.",
                            "perma": "textile-patch",
                            "code": "3",
                            "weight": 2.92,
                            "keys": {
                                "WS": 9,
                                "SN": 10,
                                "R": 4,
                                "EN": 9,
                                "AIC": 5
                            },
                            "presets": [
                                "A"
                            ]
                        }
                    ]
                },
                {
                    "name": "Under Battery Cover",
                    "perma": "under-battery-cover",
                    "code": "V",
                    "description": "Undercovers based on Ultra-Silent are installed underneath the battery casing, providing the best possible protection against extreme ambient conditions and hence, contributing to a better energy efficiency of the battery. In addition, they absorb tire noise and improve pass-by noise and driving comfort.",
                    "powertrains": [
                        "B"
                    ],
                    "bodyStyles": [
                        "A",
                        "C",
                        "B"
                    ],
                    "technologyOptions": [
                        {
                            "name": "Ultra-Silent",
                            "description": "Textile lightweight technology that is up to 50% lighter than plastic. It is PET-based, glass-free, water and heat resistant and fully recyclable. Underbody systems based on Ultra-Silent offer high impact resistance, optimum stone impact protection and reduce vehicle noise thanks to the large absorbing area.",
                            "perma": "ultra-silent",
                            "code": "1",
                            "weight": 2.5,
                            "keys": {
                                "TI": 8,
                                "AD": 7,
                                "WS": 3,
                                "AC": 10,
                                "SN": 10,
                                "R": 9,
                                "EN": 8
                            },
                            "presets": [
                                "B",
                                "L",
                                "I",
                                "A"
                            ]
                        }
                    ]
                }
            ],
            "presets": [
                {
                    "name": "Baseline",
                    "perma": "baseline",
                    "code": "B",
                    "active": true,
                    "enabled": true,
                    "description": "Discover a default package representing an average car.",
                    "color": 1
                },
                {
                    "name": "Lightweight",
                    "perma": "lightweight",
                    "code": "L",
                    "active": true,
                    "enabled": true,
                    "description": "Discover the ultimate Autoneum package to reduce the weight and maintain the acoustic performance to its best.",
                    "color": 2
                },
                {
                    "name": "Max insulation",
                    "perma": "max-insulation",
                    "code": "I",
                    "active": true,
                    "enabled": true,
                    "description": "Discover a typical insulative package. A combination of the reference insulative technologies to reduce the interior sound pressure level.",
                    "color": 3
                },
                {
                    "name": "Max absorption",
                    "perma": "max-absorption",
                    "code": "A",
                    "active": true,
                    "enabled": true,
                    "description": "Discover a typical absorptive package. A combination of the reference absorptive technologies to reduce the interior and the exterior sound.",
                    "color": 4
                }
            ],
            "keys": [
                {
                    "name": "Acoustic absorption",
                    "perma": "acoustic-absorption",
                    "code": "AA",
                    "description": "Ability to absorb the noise: 1=poor; 10=excellent",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Acoustic insulation",
                    "perma": "acoustic-insulation",
                    "code": "AI",
                    "description": "Ability to insulate from the noise: 1=poor; 10=excellent",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Aerodynamics",
                    "perma": "aerodynamics",
                    "code": "AD",
                    "description": "Ability to facilitate the interaction with the air: 1=poor; 10=excellent",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Aesthetic",
                    "perma": "aesthetic",
                    "code": "AE",
                    "description": "Aesthetic: 1=No aesthetic gain: 10=Excellent aesthetic gain",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Anti-corrosion",
                    "perma": "anti-corrosion",
                    "code": "AC",
                    "description": "Ability to reduce corrosion: 1=None; 10=Excellent",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Anti-icing",
                    "perma": "anti-icing",
                    "code": "AIC",
                    "description": "Ability to avoid ice sticking: 1=None; 10=Excellent",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "CO2 reduction",
                    "perma": "co2-reduction",
                    "code": "CR",
                    "description": "Ability to reduce C02 emission: 1=None; 10=Excellent",
                    "powertrains": [
                        "H",
                        "I"
                    ]
                },
                {
                    "name": "Design freedom",
                    "perma": "design-freedom",
                    "code": "DF",
                    "description": "Part-related constrain: 1=little design freedom; 10=excellent design freedom",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Exterior noise",
                    "perma": "exterior-noise",
                    "code": "EN",
                    "description": "Ability to reduce the exterior noise: 1=None; 10=Excellent",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Heat protection",
                    "perma": "heat-protection",
                    "code": "HP",
                    "description": "Ability to protect from the heat: 1=poor; 10=excellent",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Interior noise",
                    "perma": "interior-noise",
                    "code": "IN",
                    "description": "Ability to reduce the noise inside the vehicle: 1=None; 10=Excellent",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Lightweight ",
                    "perma": "lightweight",
                    "code": "L",
                    "description": "Weight: 1=no light; 10=very light",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Stone impact noise",
                    "perma": "stone-chipping-noise",
                    "code": "SN",
                    "description": "Ability to reduce noise from stone chipping: 1=None; 10=Excellent",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Sustainability",
                    "perma": "sustainability",
                    "code": "S",
                    "description": "Sustainable: 1=poor; 10=excellent",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Sustainability",
                    "perma": "recyclability",
                    "code": "R",
                    "description": "Reciclability: 1=Not recyclable; 10=fully recyclable",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Thermal insulation",
                    "perma": "thermal-insulation",
                    "code": "TI",
                    "description": "Ability to insulate from the heat: 1=poor; 10=excellent",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "VOC & odor",
                    "perma": "voc-odor",
                    "code": "VO",
                    "description": "Volatile Organic Compounds and Odor: 1=Certainly high; 10=Certainly low",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                },
                {
                    "name": "Weight saving",
                    "perma": "weight-saving",
                    "code": "WS",
                    "description": "Weight Saving: 1=None; 10=Excellent",
                    "powertrains": [
                        "H",
                        "B",
                        "I"
                    ]
                }
            ]
        }
        _this.STATIC_DATA.copy && (_this.COPY = _this.STATIC_DATA.copy),
        _this.STATIC_DATA.menu && (_this.MENU = _this.STATIC_DATA.menu),
        _this.STATIC_DATA.products &&
          (_this.PRODUCTS = _this.STATIC_DATA.products),
        _this.STATIC_DATA.bodyStyles &&
          (_this.BODY_STYLES = _this.STATIC_DATA.bodyStyles),
        _this.STATIC_DATA.powertrains &&
          (_this.POWERTRAINS = _this.STATIC_DATA.powertrains),
        _this.STATIC_DATA.presets &&
          (_this.PRESETS = _this.STATIC_DATA.presets),
        _this.STATIC_DATA.keys && (_this.KEYS = _this.STATIC_DATA.keys),
        (_this.dataReady = !0);
    })(),
      (this.copy = function (key, returnNull) {
        return _this.COPY && _this.COPY[key]
          ? _this.COPY[key]
          : returnNull
          ? null
          : "!MISSING!";
      }),
      (this.product = function (code) {
        return _this.PRODUCTS.find((p) => p.code === code);
      }),
      (this.refresh = async function () {
        let response = await get(
          "https://us-central1-acoustics.cloudfunctions.net/refresh"
        );
        response.success && console.log(`Data updated [${response.ms}ms]`);
      });
  }, "static"),
  Class(function ConfigurationData(data) {
    Inherit(this, Model);
    const _this = this;
    var _bodyStyle,
      _powertrain,
      _products,
      _preset,
      _title,
      _date,
      _configID = Utils.timestamp();
    (_bodyStyle = data.bodyStyle || null),
      (_powertrain = data.powertrain || null),
      (_products = data.products || null),
      (_preset = data.preset || null),
      (_title = data.title || null),
      (_date = data.date || null),
      this.get("products", () => _products),
      this.get("bodyStyle", () => _bodyStyle),
      this.set("bodyStyle", (newValue) => {
        (_bodyStyle = newValue), _this.events.fire(Events.UPDATE);
      }),
      this.get("powertrain", () => _powertrain),
      this.set("powertrain", (newValue) => {
        if (newValue !== _powertrain) {
          _powertrain = newValue;
          for (let p in _products)
            Meta.PRODUCTS.find((_p) => _p.code === p) || delete _products[p];
          (_this.preset = _preset || Configuration.DEFAULT_PRESET),
            _this.events.fire(Events.UPDATE);
        }
      }),
      this.get("preset", () => _preset),
      this.set("preset", function (code) {
        Meta.PRODUCTS.map((product) => {
          _this.clearProduct(product.code),
            product.productVariables &&
              product.productVariables.map((productVariable) => {
                productVariable.options.map((productVariableOption) => {
                  productVariableOption.presets.map((preset) => {
                    preset === code &&
                      _this.setProductVariable(
                        product.code,
                        productVariable.code,
                        productVariableOption.code
                      );
                  });
                });
              }),
            product.technologies &&
              product.technologies.map((technology) => {
                technology.presets &&
                  technology.presets.map((technologyPreset) => {
                    technologyPreset === code &&
                      technology.variables.map((technologyVariable) => {
                        technologyVariable.options.map(
                          (technologyVariableOption) => {
                            technologyVariableOption.presets.map((preset) => {
                              preset === code &&
                                _this.setProductTechnology(
                                  product.code,
                                  technology.code,
                                  technologyVariable.code,
                                  technologyVariableOption.code
                                );
                            });
                          }
                        );
                      });
                  });
              }),
            product.technologyOptions &&
              product.technologyOptions.map((technologyOption) => {
                technologyOption.presets &&
                  technologyOption.presets.map((technologyOptionPreset) => {
                    technologyOptionPreset === code &&
                      _this.setProductTechnologyOption(
                        product.code,
                        technologyOption.code
                      );
                  });
              });
        }),
          (_preset = code);
      }),
      _this.get("date", () => _date),
      _this.set("date", (d) => (_date = d)),
      _this.get("title", () => _title),
      _this.set("title", (t) => (_title = t)),
      _this.get("configID", () => _configID),
      (this.getData = function () {
        return {
          bodyStyle: _bodyStyle,
          powertrain: _powertrain,
          products: _products,
          preset: _preset,
          title: _title,
          date: _date,
        };
      }),
      (this.clear = function () {
        (_bodyStyle = null),
          (_powertrain = null),
          (_products = null),
          (_preset = null),
          (_title = null),
          (_data = null);
      }),
      (this.clearProduct = function (p) {
        _products && _products[p] && (_products[p] = {});
      }),
      (this.getProduct = function (p) {
        return _products[p];
      }),
      (this.setProductVariable = function (p, v, o) {
        _products || (_products = {}),
          _products[p] || (_products[p] = {}),
          _products[p].variables || (_products[p].variables = {}),
          (_products[p].variables[v] = o);
      }),
      (this.getProductVariables = function (p) {
        return _products[p] && _products[p].variables
          ? _products[p].variables
          : null;
      }),
      (this.setProductTechnology = function (p, t, v, o) {
        _products || (_products = {}),
          _products[p] || (_products[p] = {}),
          _products[p].technology || (_products[p].technology = {}),
          Object.keys(_products[p].technology)[0] === t ||
            v ||
            o ||
            ((_products[p].technology = {}),
            Meta.PRODUCT(p)
              .technologies.find((technology) => technology.code === t)
              .variables.map((technologyVariable) => {
                technologyVariable.options.map((technologyVariableOption) => {
                  technologyVariableOption.presets.map((preset) => {
                    "B" === preset &&
                      (_products[p].technology[t] ||
                        (_products[p].technology[t] = {}),
                      (_products[p].technology[t][technologyVariable.code] =
                        technologyVariableOption.code));
                  });
                });
              })),
          _products[p].technology[t] || (_products[p].technology[t] = {}),
          o && (_products[p].technology[t][v] = o);
      }),
      (this.getProductTechnology = function (p) {
        return _products[p].technology ? _products[p].technology : null;
      }),
      (this.getProductTechnologyVariables = function (p, t) {
        return _products[p].technology && _products[p].technology[t]
          ? _products[p].technology[t]
          : null;
      }),
      (this.setProductTechnologyOption = function (p, o) {
        _products || (_products = {}),
          _products[p] || (_products[p] = {}),
          (_products[p].technologyOption = o);
      }),
      (this.getProductTechnologyOption = function (p) {
        return _products[p].technologyOption
          ? _products[p].technologyOption
          : null;
      }),
      (this.load = function (code) {
        let data = Configuration.decode(code);
        (_this.bodyStyle = data.bodyStyle),
          (_this.powertrain = data.powertrain),
          (_this.products = data.products),
          (_this.preset = data.preset),
          (_this.date = data.date),
          (_this.title = data.title);
      }),
      (this.shareURL = function () {
        let lang = Utils.query("lang") ? "&lang=" + Utils.query("lang") : "";
        return (
          location.protocol +
          "//" +
          location.hostname +
          location.pathname +
          "?code=" +
          Configuration.encode(_this) +
          lang
        );
      });
  }),
  (window.ASSETS = [
    "assets/images/background/particle.jpg",
    "assets/images/car/env-001.jpg",
    "assets/images/car/floor.png",
    "assets/images/car/line-texture01.jpg",
    "assets/images/car/reflection.jpg",
    "assets/images/car/rotate.jpg",
    "assets/images/crosssection/layers/alpha-liner/alpha.jpg",
    "assets/images/crosssection/layers/alpha-liner/diffuse.jpg",
    "assets/images/crosssection/layers/aluminium/alpha.jpg",
    "assets/images/crosssection/layers/aluminium/diffuse.jpg",
    "assets/images/crosssection/layers/cover/alpha.jpg",
    "assets/images/crosssection/layers/cover/diffuse.jpg",
    "assets/images/crosssection/layers/decor/alpha.jpg",
    "assets/images/crosssection/layers/decor/diffuse.jpg",
    "assets/images/crosssection/layers/decoupler-felt/alpha.jpg",
    "assets/images/crosssection/layers/decoupler-felt/diffuse.jpg",
    "assets/images/crosssection/layers/decoupler-felt-thin/alpha.jpg",
    "assets/images/crosssection/layers/decoupler-felt-thin/diffuse.jpg",
    "assets/images/crosssection/layers/decoupler-foam/alpha.jpg",
    "assets/images/crosssection/layers/decoupler-foam/diffuse.jpg",
    "assets/images/crosssection/layers/decoupler-foam-white/alpha.jpg",
    "assets/images/crosssection/layers/decoupler-foam-white/diffuse.jpg",
    "assets/images/crosssection/layers/dlft/alpha.jpg",
    "assets/images/crosssection/layers/dlft/diffuse.jpg",
    "assets/images/crosssection/layers/era-film/alpha.jpg",
    "assets/images/crosssection/layers/era-film/diffuse.jpg",
    "assets/images/crosssection/layers/era-foam/alpha.jpg",
    "assets/images/crosssection/layers/era-foam/diffuse.jpg",
    "assets/images/crosssection/layers/film/alpha.jpg",
    "assets/images/crosssection/layers/film/diffuse.jpg",
    "assets/images/crosssection/layers/flexi-loft/alpha.jpg",
    "assets/images/crosssection/layers/flexi-loft/diffuse.jpg",
    "assets/images/crosssection/layers/flexi-loft-compressed/alpha.jpg",
    "assets/images/crosssection/layers/flexi-loft-compressed/diffuse.jpg",
    "assets/images/crosssection/layers/flexi-loft-uncompressed/alpha.jpg",
    "assets/images/crosssection/layers/flexi-loft-uncompressed/diffuse.jpg",
    "assets/images/crosssection/layers/heavy-rubber/alpha.jpg",
    "assets/images/crosssection/layers/heavy-rubber/diffuse.jpg",
    "assets/images/crosssection/layers/injected-plastic/alpha.jpg",
    "assets/images/crosssection/layers/injected-plastic/diffuse.jpg",
    "assets/images/crosssection/layers/nothing/alpha.jpg",
    "assets/images/crosssection/layers/nothing/diffuse.jpg",
    "assets/images/crosssection/layers/rimic-multilayer/alpha.jpg",
    "assets/images/crosssection/layers/rimic-multilayer/diffuse.jpg",
    "assets/images/crosssection/layers/rimic-single-layer/alpha.jpg",
    "assets/images/crosssection/layers/rimic-single-layer/diffuse.jpg",
    "assets/images/crosssection/layers/standard-glassfiber-felt/alpha.jpg",
    "assets/images/crosssection/layers/standard-glassfiber-felt/diffuse.jpg",
    "assets/images/crosssection/layers/textile/alpha.jpg",
    "assets/images/crosssection/layers/textile/diffuse.jpg",
    "assets/images/crosssection/layers/thermo-composite-felt/alpha.jpg",
    "assets/images/crosssection/layers/thermo-composite-felt/diffuse.jpg",
    "assets/images/crosssection/layers/theta-cell-felt/alpha.jpg",
    "assets/images/crosssection/layers/theta-cell-felt/diffuse.jpg",
    "assets/images/crosssection/layers/theta-cell-foam/alpha.jpg",
    "assets/images/crosssection/layers/theta-cell-foam/diffuse.jpg",
    "assets/images/crosssection/layers/theta-fiber-felt/alpha.jpg",
    "assets/images/crosssection/layers/theta-fiber-felt/diffuse.jpg",
    "assets/images/crosssection/layers/theta-fiber-foam/alpha.jpg",
    "assets/images/crosssection/layers/theta-fiber-foam/diffuse.jpg",
    "assets/images/crosssection/layers/ts-felt/alpha.jpg",
    "assets/images/crosssection/layers/ts-felt/diffuse.jpg",
    "assets/images/crosssection/layers/ultra-silent/alpha.jpg",
    "assets/images/crosssection/layers/ultra-silent/diffuse.jpg",
    "assets/images/crosssection/shadow.jpg",
    "assets/images/engines/ao/bev.jpg",
    "assets/images/engines/ao/hev.jpg",
    "assets/images/engines/ao/ice.jpg",
    "assets/images/engines/env.jpg",
    "assets/images/engines/matcap.jpg",
    "assets/images/products/ao/carpet-system.jpg",
    "assets/images/products/ao/e-motor-encapsulation.jpg",
    "assets/images/products/ao/engine-encapsulation.jpg",
    "assets/images/products/ao/engine-top-cover.jpg",
    "assets/images/products/ao/frunk.jpg",
    "assets/images/products/ao/hoodliner.jpg",
    "assets/images/products/ao/inner-dash.jpg",
    "assets/images/products/ao/outer-dash.jpg",
    "assets/images/products/ao/under-battery-cover.jpg",
    "assets/images/products/ao/under-tunnel-shield.jpg",
    "assets/images/products/ao/underbody-shield-bev.jpg",
    "assets/images/products/ao/underbody-shield.jpg",
    "assets/images/products/ao/wheelhouse-outer-liner.jpg",
    "assets/images/products/env.jpg",
    "assets/images/products/matcap.jpg",
    "assets/images/products/settings/coverage/carpet-system.jpg",
    "assets/images/products/settings/coverage/inner-dash.jpg",
    "assets/images/products/settings/pass-through/inner-dash.jpg",
    "assets/images/products/settings/thickness/carpet-system.jpg",
    "assets/images/products/settings/thickness/inner-dash.jpg",
    "assets/images/products/settings/top-face/needlepunch.jpg",
    "assets/images/products/settings/top-face/tufted.jpg",
    "assets/images/products/shadow/carpet-system.jpg",
    "assets/images/products/shadow/e-motor-encapsulation.jpg",
    "assets/images/products/shadow/engine-encapsulation.jpg",
    "assets/images/products/shadow/engine-top-cover.jpg",
    "assets/images/products/shadow/frunk.jpg",
    "assets/images/products/shadow/hoodliner.jpg",
    "assets/images/products/shadow/inner-dash.jpg",
    "assets/images/products/shadow/outer-dash.jpg",
    "assets/images/products/shadow/under-battery-cover.jpg",
    "assets/images/products/shadow/under-tunnel-shield.jpg",
    "assets/images/products/shadow/underbody-shield-bev.jpg",
    "assets/images/products/shadow/underbody-shield.jpg",
    "assets/images/products/shadow/wheelhouse-outer-liner.jpg",
    "assets/images/ripple/matcap.jpg",
    "assets/images/ui/arrow.svg",
    "assets/images/ui/control-keyboard.png",
    "assets/images/ui/customise/close-dark.svg",
    "assets/images/ui/customise/close.svg",
    "assets/images/ui/customise/down-arrow.svg",
    "assets/images/ui/customise/info.svg",
    "assets/images/ui/customise/variables/absorptive.svg",
    "assets/images/ui/customise/variables/average.svg",
    "assets/images/ui/customise/variables/heavy.svg",
    "assets/images/ui/customise/variables/high.svg",
    "assets/images/ui/customise/variables/insulative.svg",
    "assets/images/ui/customise/variables/light.svg",
    "assets/images/ui/customise/variables/low.svg",
    "assets/images/ui/customise/variables/medium.svg",
    "assets/images/ui/customise/variables/mixed.svg",
    "assets/images/ui/customise/variables/needlepunch.svg",
    "assets/images/ui/customise/variables/no-mask/absorptive.svg",
    "assets/images/ui/customise/variables/no-mask/average.svg",
    "assets/images/ui/customise/variables/no-mask/heavy.svg",
    "assets/images/ui/customise/variables/no-mask/high.svg",
    "assets/images/ui/customise/variables/no-mask/insulative.svg",
    "assets/images/ui/customise/variables/no-mask/light.svg",
    "assets/images/ui/customise/variables/no-mask/low.svg",
    "assets/images/ui/customise/variables/no-mask/medium.svg",
    "assets/images/ui/customise/variables/no-mask/mixed.svg",
    "assets/images/ui/customise/variables/no-mask/needlepunch.svg",
    "assets/images/ui/customise/variables/no-mask/tufted.svg",
    "assets/images/ui/customise/variables/tufted.svg",
    "assets/images/ui/icons/clean-tuft.svg",
    "assets/images/ui/icons/coverage.svg",
    "assets/images/ui/icons/dry-light.svg",
    "assets/images/ui/icons/packaging-space.svg",
    "assets/images/ui/icons/pass-through.svg",
    "assets/images/ui/icons/prime-light.svg",
    "assets/images/ui/icons/theta-fibercell.svg",
    "assets/images/ui/icons/top-face.svg",
    "assets/images/ui/icons/tune-in.svg",
    "assets/images/ui/icons/ultra-silent.svg",
    "assets/images/ui/info.svg",
    "assets/images/ui/keyboard/down.png",
    "assets/images/ui/keyboard/left.png",
    "assets/images/ui/keyboard/right.png",
    "assets/images/ui/keyboard/up.png",
    "assets/images/ui/logo.svg",
    "assets/images/ui/main/bodystyles/hatchback.png",
    "assets/images/ui/main/bodystyles/hatchback.svg",
    "assets/images/ui/main/bodystyles/sedan.png",
    "assets/images/ui/main/bodystyles/sedan.svg",
    "assets/images/ui/main/bodystyles/suv.png",
    "assets/images/ui/main/bodystyles/suv.svg",
    "assets/images/ui/main/customise/reset.png",
    "assets/images/ui/main/customise/reset.svg",
    "assets/images/ui/main/customise/sliders.png",
    "assets/images/ui/main/customise/sliders.svg",
    "assets/images/ui/main/engines/bev.png",
    "assets/images/ui/main/engines/bev.svg",
    "assets/images/ui/main/engines/hev.png",
    "assets/images/ui/main/engines/hev.svg",
    "assets/images/ui/main/engines/ice.png",
    "assets/images/ui/main/engines/ice.svg",
    "assets/images/ui/main/presets/baseline.png",
    "assets/images/ui/main/presets/baseline.svg",
    "assets/images/ui/main/presets/lightweight.png",
    "assets/images/ui/main/presets/lightweight.svg",
    "assets/images/ui/main/presets/max-absorption.png",
    "assets/images/ui/main/presets/max-absorption.svg",
    "assets/images/ui/main/presets/max-insulation.png",
    "assets/images/ui/main/presets/max-insulation.svg",
    "assets/images/ui/main/report/done.png",
    "assets/images/ui/main/report/done.svg",
    "assets/images/ui/menu/link-over.svg",
    "assets/images/ui/menu/link.svg",
    "assets/images/ui/modal/hand.svg",
    "assets/images/ui/unsupported/car-background.jpg",
    "assets/images/ui/unsupported/rotate.svg",
    "assets/data/curves/hatchback/flow-body.json",
    "assets/data/curves/hatchback/flow-ground.json",
    "assets/data/curves/hatchback/form.json",
    "assets/data/curves/hatchback/wheels.json",
    "assets/data/curves/sedan/flow-body.json",
    "assets/data/curves/sedan/flow-ground.json",
    "assets/data/curves/sedan/form.json",
    "assets/data/curves/sedan/wheels.json",
    "assets/data/curves/suv/flow-body.json",
    "assets/data/curves/suv/flow-ground.json",
    "assets/data/curves/suv/form.json",
    "assets/data/curves/suv/wheels.json",
    "assets/data/uil.json",
    "assets/shaders/compiled.vs",
  ]),
  (ASSETS.SW = [
    "assets/fonts/bebasneue-bold-webfont.woff",
    "assets/fonts/bebasneue-bold-webfont.woff2",
    "assets/fonts/bebasneue-regular-webfont.woff",
    "assets/fonts/bebasneue-regular-webfont.woff2",
    "assets/fonts/d-din-bold.woff",
    "assets/fonts/d-din-bold.woff2",
    "assets/fonts/d-din.woff",
    "assets/fonts/d-din.woff2",
    "assets/fonts/montserrat-medium.woff",
    "assets/fonts/montserrat-medium.woff2",
    "assets/css/style.css",
    "assets/js/app.js",
  ]),
  Class(function Config() {
    (this.API = window._CONFIG_.CONFIGURATOR),
      (this.CONTACT = window._CONFIG_.CONTACT),
      (this.ANALYTICS_ID = window._CONFIG_.ANALYTICS),
      (this.LANG = ["cn", "de", "ja"].includes(Utils.query("lang"))
        ? Utils.query("lang")
        : "en"),
      (this.DATA = window._CONFIG_.DATA.replace("{lang}", this.LANG)),
      (this.SESSION_ID = Date.now()),
      (this.RADIUS = {
        value: 150,
        scale: 1,
        state: "loader",
        stateValue: 0,
        loaderValue: 120,
        mainValue: 250,
        engineValue: 200,
        drivingValue: 290,
        reportValue: 260,
        ignoreUIL: !0,
      }),
      (this.RADIUS_UPDATE = "event_radius_update"),
      (this.NUM_COLOR_PRESETS = 5),
      (this.CURRENT_PRESET = 0),
      (this.PRESET_COLORS = []),
      (this.BASE_COLORS = ["#c2cb88", "#c1c490", "#adc7d0"]),
      (this.BRAND_COLOR = "#BAC529"),
      (this.COOKIES_BG_COLOR = "#090909"),
      (this.PRODUCT_DATA = {
        "carpet-system": {
          position: { x: 0, y: 0.52, z: -0.56 },
          colorIndex: 0,
          renderOrder: 0,
          camera: [7.316, 5.846, -5.134],
        },
        "inner-dash": {
          position: { x: 0.21, y: 0.65, z: 0.83 },
          colorIndex: 0,
          renderOrder: 1,
          camera: [4.217, 1.541, -4.419],
        },
        "outer-dash": {
          position: { x: -0.25, y: 0.63, z: 1 },
          colorIndex: 1,
          renderOrder: 2,
          camera: [5.059, 3.79, 4.727],
        },
        hoodliner: {
          position: { x: 0, y: 0.85, z: 1.77 },
          colorIndex: 1,
          renderOrder: 3,
          camera: [0, 6.84, 10.34],
        },
        "engine-encapsulation": {
          position: { x: 0.08, y: 0.51, z: 1.5 },
          colorIndex: 1,
          renderOrder: 1,
          camera: [-7.959, 0.634, 0],
        },
        "engine-top-cover": {
          position: { x: 0.09, y: 0.79, z: 1.4 },
          colorIndex: 1,
          renderOrder: 0,
          camera: [0.578, 2.147, 5.344],
        },
        "under-tunnel-shield": {
          position: { x: 0, y: 0.17, z: 0.6 },
          colorIndex: 2,
          renderOrder: 6,
          camera: [-7.737, -6.845, -5.145],
        },
        "underbody-shield": {
          position: { x: 0.37, y: 0.25, z: -1.85 },
          colorIndex: 2,
          renderOrder: 7,
          camera: [-6.415, -4.226, -2.622],
        },
        "wheelhouse-outer-liner": {
          position: { x: -0.69, y: 0.79, z: -1.42 },
          colorIndex: 2,
          renderOrder: 8,
          camera: [-8.889, 2.88, -1.633],
        },
        frunk: {
          position: { x: 0.35, y: 0.6, z: 1.8 },
          colorIndex: 1,
          renderOrder: 2,
          camera: [-3.831, 3.55, 7.981],
        },
        "e-motor-encapsulation": {
          position: { x: 0.2, y: 0.45, z: 1.35 },
          colorIndex: 1,
          renderOrder: 1,
          camera: [-7.959, 0.634, 0],
        },
        "under-battery-cover": {
          position: { x: -0.2, y: 0.17, z: 0.2 },
          colorIndex: 2,
          renderOrder: 6,
          camera: [-6.857, -6.564, 2.256],
        },
      }),
      (this.ENGINE_DATA = {
        ice: { camera: [-2.879, 1.942, 5.731], target: [0, 0.5, 1.4] },
        hev: { camera: [3.215, 1.333, 3.509], target: [0, 0.5, 1.4] },
        bev: { camera: [-8.329, 2.426, 0.899], target: [0, 0.75, 0] },
      }),
      (this.ALTERNATIVE_MODELS = {
        B: { "underbody-shield": "underbody-shield-bev" },
      }),
      (this.STORAGE_PREFIX = "acoustic_e_");
  }, "static"),
  Class(function KeyboardUtil() {
    function addListeners() {
      __window.keydown(keydown),
        __window.keyup(keyup),
        __window.keypress(keypress);
    }
    function keydown(e) {
      _this.events.fire(_this.DOWN, e);
    }
    function keyup(e) {
      _this.events.fire(_this.UP, e);
    }
    function keypress(e) {
      _this.events.fire(_this.PRESS, e);
    }
    Inherit(this, Component);
    var _this = this;
    (_this.DOWN = "keyboard_down"),
      (_this.PRESS = "keyboard_press"),
      (_this.UP = "keyboard_up"),
      Hydra.ready(addListeners);
  }, "static"),
  Mobile.Class(function Accelerometer() {
    function updateAccel(e) {
      switch (window.orientation) {
        case 0:
          (_this.x = -e.accelerationIncludingGravity.x),
            (_this.y = e.accelerationIncludingGravity.y),
            (_this.z = e.accelerationIncludingGravity.z),
            e.rotationRate &&
              ((_this.rotationRate.alpha =
                e.rotationRate.beta * _this.toRadians),
              (_this.rotationRate.beta =
                -e.rotationRate.alpha * _this.toRadians),
              (_this.rotationRate.gamma =
                e.rotationRate.gamma * _this.toRadians));
          break;
        case 180:
          (_this.x = e.accelerationIncludingGravity.x),
            (_this.y = -e.accelerationIncludingGravity.y),
            (_this.z = e.accelerationIncludingGravity.z),
            e.rotationRate &&
              ((_this.rotationRate.alpha =
                -e.rotationRate.beta * _this.toRadians),
              (_this.rotationRate.beta =
                e.rotationRate.alpha * _this.toRadians),
              (_this.rotationRate.gamma =
                e.rotationRate.gamma * _this.toRadians));
          break;
        case 90:
          (_this.x = e.accelerationIncludingGravity.y),
            (_this.y = e.accelerationIncludingGravity.x),
            (_this.z = e.accelerationIncludingGravity.z),
            e.rotationRate &&
              ((_this.rotationRate.alpha =
                e.rotationRate.alpha * _this.toRadians),
              (_this.rotationRate.beta = e.rotationRate.beta * _this.toRadians),
              (_this.rotationRate.gamma =
                e.rotationRate.gamma * _this.toRadians));
          break;
        case -90:
          (_this.x = -e.accelerationIncludingGravity.y),
            (_this.y = -e.accelerationIncludingGravity.x),
            (_this.z = e.accelerationIncludingGravity.z),
            e.rotationRate &&
              ((_this.rotationRate.alpha =
                -e.rotationRate.alpha * _this.toRadians),
              (_this.rotationRate.beta =
                -e.rotationRate.beta * _this.toRadians),
              (_this.rotationRate.gamma =
                e.rotationRate.gamma * _this.toRadians));
      }
      "android" == Device.system.os &&
        ((_this.x *= -1), (_this.y *= -1), (_this.z *= -1));
    }
    function updateOrientation(e) {
      for (var key in e)
        key.toLowerCase().includes("heading") && (_this.heading = e[key]);
      switch (window.orientation) {
        case 0:
          (_this.alpha = e.beta * _this.toRadians),
            (_this.beta = -e.alpha * _this.toRadians),
            (_this.gamma = e.gamma * _this.toRadians);
          break;
        case 180:
          (_this.alpha = -e.beta * _this.toRadians),
            (_this.beta = e.alpha * _this.toRadians),
            (_this.gamma = e.gamma * _this.toRadians);
          break;
        case 90:
          (_this.alpha = e.alpha * _this.toRadians),
            (_this.beta = e.beta * _this.toRadians),
            (_this.gamma = e.gamma * _this.toRadians);
          break;
        case -90:
          (_this.alpha = -e.alpha * _this.toRadians),
            (_this.beta = -e.beta * _this.toRadians),
            (_this.gamma = e.gamma * _this.toRadians);
      }
      (_this.tilt = e.beta * _this.toRadians),
        (_this.yaw = e.alpha * _this.toRadians),
        (_this.roll = -e.gamma * _this.toRadians),
        "android" == Device.system.os &&
          (_this.heading = compassHeading(e.alpha, e.beta, e.gamma));
    }
    function compassHeading(alpha, beta, gamma) {
      var degtorad = Math.PI / 180,
        _x = beta ? beta * degtorad : 0,
        _y = gamma ? gamma * degtorad : 0,
        _z = alpha ? alpha * degtorad : 0,
        cY = (Math.cos(_x), Math.cos(_y)),
        cZ = Math.cos(_z),
        sX = Math.sin(_x),
        sY = Math.sin(_y),
        sZ = Math.sin(_z),
        Vx = -cZ * sY - sZ * sX * cY,
        Vy = -sZ * sY + cZ * sX * cY,
        compassHeading = Math.atan(Vx / Vy);
      return (
        Vy < 0
          ? (compassHeading += Math.PI)
          : Vx < 0 && (compassHeading += 2 * Math.PI),
        compassHeading * (180 / Math.PI)
      );
    }
    var _this = this;
    (this.x = 0),
      (this.y = 0),
      (this.z = 0),
      (this.alpha = 0),
      (this.beta = 0),
      (this.gamma = 0),
      (this.heading = 0),
      (this.rotationRate = {}),
      (this.rotationRate.alpha = 0),
      (this.rotationRate.beta = 0),
      (this.rotationRate.gamma = 0),
      (this.toRadians = "ios" == Device.system.os ? Math.PI / 180 : 1),
      (this.capture = function () {
        this.active ||
          ((this.active = !0),
          (window.ondevicemotion = updateAccel),
          window.addEventListener("deviceorientation", updateOrientation));
      }),
      (this.stop = function () {
        (this.active = !1),
          (window.ondevicemotion = null),
          (_this.x = _this.y = _this.z = 0),
          window.removeEventListener("deviceorientation", updateOrientation);
      });
  }, "Static"),
  Namespace("FX"),
  FX.Class(function AfterImage(_nuke = World.NUKE) {
    function initRTs() {
      let pars = {
        minFilter: Texture.LINEAR,
        magFilter: Texture.NEAREST,
        format: Texture.RGBAFormat,
      };
      (_this.rtOld = new RenderTarget(
        _this.resolution.x,
        _this.resolution.y,
        pars
      )),
        (_this.rtCmp = new RenderTarget(
          _this.resolution.x,
          _this.resolution.y,
          pars
        ));
    }
    function initMeshes() {
      (_afterImageShader = _this.initClass(Shader, "AfterImage", {
        damp: { value: 0.96 },
        tOld: { value: null, ignoreUIL: !0 },
        tNew: { value: null, ignoreUIL: !0 },
      })),
        ((_mesh = new Mesh(World.QUAD, _afterImageShader)).frustumCulled = !1);
    }
    function initPass() {
      _this.pass = _this.initClass(NukePass, "AfterImagePass", {
        tMap: { value: null },
      });
    }
    function render() {
      if (!_this.enabled) return;
      let renderer = _nuke.renderer;
      (_afterImageShader.uniforms.tOld.value = _this.rtOld.texture),
        (_afterImageShader.uniforms.tNew.value =
          _inputTexture || _nuke.rttBuffer.texture),
        (_mesh.shader = _afterImageShader),
        renderer.renderSingle(_mesh, _nuke.camera, _this.rtCmp),
        (_this.pass.uniforms.tMap.value = _this.rtCmp.texture);
      let temp = _this.rtOld;
      (_this.rtOld = _this.rtCmp), (_this.rtCmp = temp);
    }
    function resizeHandler() {
      _this.resolution
        .set(_nuke.stage.width, _nuke.stage.height)
        .multiplyScalar(_DPR),
        _this.rtOld.setSize(_this.resolution.x, _this.resolution.y),
        _this.rtCmp.setSize(_this.resolution.x, _this.resolution.y);
    }
    function addListeners() {
      _this.events.sub(Events.RESIZE, resizeHandler),
        _this.events.sub(RenderManager.RENDER, render);
    }
    Inherit(this, Component);
    var _afterImageShader,
      _mesh,
      _inputTexture,
      _this = this,
      _DPR = _nuke.dpr;
    (this.resolution = new Vector2(
      _nuke.stage.width * _DPR,
      _nuke.stage.height * _DPR
    )),
      (this.enabled = !0),
      initRTs(),
      initMeshes(),
      initPass(),
      addListeners(),
      ShaderUIL.add(_afterImageShader).setLabel("AfterImage"),
      this.set("texture", (texture) => {
        _inputTexture = texture;
      }),
      this.set("dpr", (dpr) => {
        (_DPR = dpr), resizeHandler();
      }),
      this.set("damp", (val) => {
        _afterImageShader.uniforms.damp.value = val;
      }),
      this.get("damp", () => _afterImageShader.uniforms.damp.value),
      (this.renderAfterImage = render),
      (this.renderMesh = _mesh);
  }),
  Class(function Antimatter(_num, _config, _renderer = World.RENDERER) {
    function createBuffer() {
      AntimatterUtil.createBufferArray(
        _size,
        _num,
        _config,
        function (geometry, vertices, attribs) {
          (_this.vertices = new AntimatterAttribute(vertices, 4)),
            _this.vertices.texture.upload(),
            (_geometry = new Geometry()).addAttribute(
              "position",
              new GeometryAttribute(geometry, 3)
            ),
            _geometry.addAttribute("random", new GeometryAttribute(attribs, 4)),
            (_this.vertices.geometry = _geometry),
            (_this.attribs = new AntimatterAttribute(attribs, 4)),
            _this.init(_geometry, _renderer, _size);
        }
      );
    }
    Inherit(this, AntimatterFBO);
    var _geometry,
      _this = this,
      _size = (function findSize() {
        var values = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048];
        for (let i = 0; i < values.length; i++)
          if (_num == values[i]) return (_num *= _num), values[i];
        for (let i = 0; i < values.length; i++) {
          var p2 = values[i];
          if (p2 * p2 >= _num) return p2;
        }
      })();
    (this.particleCount = _num),
      defer(createBuffer),
      (this.createFloatArray = function (components) {
        return new Float32Array(_size * _size * (components || 3));
      }),
      (this.ready = function (callback) {
        return _this.wait(_this, "vertices");
      }),
      (this.useShader = function (vs, fs, params) {
        "object" == typeof fs && ((params = fs), (fs = null)),
          (this.vertexShader = vs),
          (this.fragmentShader = fs || vs),
          (this.uniforms = params);
      }),
      (this.createMesh = this.getMesh =
        function () {
          let shader = _this.createShader(
            _this.fragmentShader || "AntimatterBasicFrag"
          );
          return (
            (_this.mesh = new Points(_geometry, shader)),
            (_this.mesh.frustumCulled = !1),
            (_this.shader = shader),
            (_this.geometry = _geometry),
            _this.mesh
          );
        }),
      (this.createShader = function (fs) {
        let uniforms = _this.uniforms || {},
          obj = {
            tPos: { type: "t", value: _this.vertices.texture, ignoreUIL: !0 },
          };
        for (let key in uniforms) obj[key] = uniforms[key];
        let shader = new Shader(
            _this.vertexShader || "AntimatterPosition",
            fs,
            obj
          ),
          vs = shader.vertexShader;
        if (vs && !vs.includes("uniform sampler2D tPos")) {
          let split = vs.split("__ACTIVE_THEORY_LIGHTS__");
          shader.vertexShader =
            split[0] +
            "\nuniform sampler2D tPos;\n            vec3 getPos() { return texture2D(tPos, position.xy).xyz; }\n            vec2 getUV() { return position.xy; }\n            vec4 getPos4() { return texture2D(tPos, position.xy); }\n__ACTIVE_THEORY_LIGHTS__\n" +
            split[1];
        }
        return shader;
      }),
      (this.getLookupArray = function () {
        return new Float32Array(
          _this.vertices.geometry.attributes.position.array
        );
      }),
      this.get("particleCount", (_) => _size * _size);
  }),
  Class(function AntimatterAttribute(_data, _components) {
    Inherit(this, Component);
    var _this = this,
      _size = Math.sqrt(_data.length / (_components || 3));
    (this.size = _size),
      (this.count = _size * _size),
      (this.buffer = _data),
      (this.texture = new DataTexture(
        _data,
        _size,
        _size,
        4 == _components ? Texture.RGBAFormat : Texture.RGBFormat,
        Texture.FLOAT
      )),
      this.set("needsUpdate", function () {
        _this.texture.needsUpdate = !0;
      }),
      (this.bufferData = function (data, components) {
        (_this.buffer = data),
          components != _components
            ? (_this.texture.destroy(),
              (_this.texture = new DataTexture(
                data,
                _size,
                _size,
                4 == components ? Texture.RGBAFormat : Texture.RGBFormat,
                Texture.FLOAT
              )))
            : ((_this.texture.data = data), (_this.texture.needsUpdate = !0)),
          (_components = components),
          (_data = data);
      }),
      (this.clone = function () {
        var array = new Float32Array(_data);
        return new AntimatterAttribute(array, _components);
      }),
      (this.onDestroy = function () {
        _this.texture && _this.texture.destroy && _this.texture.destroy();
      });
  }),
  Class(
    function AntimatterFBO() {
      function initPasses() {
        (_camera = new OrthographicCamera(
          _size / -2,
          _size / 2,
          _size / 2,
          _size / -2,
          1,
          1e3
        )),
          (_geometry = World.QUAD),
          (_scene = new Scene()),
          ((_mesh = new Mesh(_geometry, null)).frustumCulled = !1),
          _scene.add(_mesh);
        var copyShader = AntimatterFBO.getCopyShader();
        (_copy = new Mesh(_geometry, copyShader)),
          _scene.add(_copy),
          (_copy.visible = !1);
      }
      function copy(input, output) {
        (_copy.visible = !0),
          (_mesh.visible = !1),
          (_copy.shader.uniforms.tDiffuse.value = input),
          _renderer.render(_scene, _camera, output),
          (_copy.visible = !1),
          (_mesh.visible = !0);
      }
      Inherit(this, Component);
      var _this,
        _gpuGeom,
        _renderer,
        _size,
        _scene,
        _mesh,
        _camera,
        _copy,
        _geometry,
        _output = { type: "t", value: null, ignoreUIL: !0 };
      (this.passes = []),
        (this.init = function (geometry, renderer, size) {
          (_this = this),
            (_gpuGeom = geometry.attributes.position.array),
            (_renderer = renderer),
            (_size = size),
            initPasses();
        }),
        (this.getGPUGeom = function () {
          return _gpuGeom;
        }),
        (this.addPass = function (pass, index) {
          (_this = this),
            "number" != typeof index
              ? _this.passes.push(pass)
              : _this.passes.splice(index, 0, pass);
        }),
        (this.findPass = function (name) {
          _this = this;
          for (var i = 0; i < _this.passes.length; i++) {
            var pass = _this.passes[i];
            if (pass.name == name) return pass;
          }
        }),
        (this.removePass = function (pass) {
          (_this = this),
            "number" == typeof pass
              ? _this.passes.splice(pass)
              : _this.passes.remove(pass);
        }),
        (this.update = function () {
          if ((_this = this).mesh) {
            for (
              var output = _output.value || _this.vertices.texture, i = 0;
              i < _this.passes.length;
              i++
            ) {
              var pass = _this.passes[i],
                needsInit = !pass.init,
                firstRender = !pass.first;
              needsInit && pass.initialize(_size),
                (pass.first = !0),
                (_mesh.shader = pass.shader),
                (_mesh.shader.uniforms.tInput.value = pass.lockIO
                  ? firstRender
                    ? _this.vertices.texture
                    : pass.output
                  : output),
                pass.ready ||
                  (_mesh.shader.uniforms.tInput.value = _this.vertices.texture);
              var rt = firstRender ? pass.getRT(0) : pass.getWrite(),
                output = pass.output;
              _renderer.render(_scene, _camera, rt),
                copy(rt, output),
                pass.swap();
            }
            output &&
              ((_output.value = output),
              (_this.mesh.shader.uniforms.tPos = _output));
          }
        }),
        (this.onDestroy = function () {
          _this.vertices.destroy(),
            _this.passes.forEach(function (pass) {
              (pass.first = !1),
                _this.persistPasses || (pass && pass.destroy && pass.destroy());
            }),
            _this.mesh.shader.destroy();
        }),
        (this.getOutput = function () {
          return _output;
        });
    },
    function () {
      var _shader;
      AntimatterFBO.getCopyShader = function () {
        return (
          _shader ||
            ((_shader = new Shader("AntimatterCopy")).uniforms = {
              tDiffuse: { type: "t", value: null },
            }),
          _shader
        );
      };
    }
  ),
  Class(function AntimatterPass(_shader, _uni, _clone) {
    function prepareShader(code, type) {
      if ("vs" == type) return code;
      let header = [
          "uniform sampler2D tInput;",
          "uniform float fSize;",
          "vec2 getUV() { return (gl_FragCoord.xy / fSize); }",
          Shaders.getShader("antimatter.glsl"),
        ].join("\n"),
        mainAt = code.indexOf("void main()");
      return (
        (code = code.slice(0, mainAt) + header + code.slice(mainAt)),
        _this.onCreateShader && (code = _this.onCreateShader(code)),
        code
      );
    }
    function initRT(size) {
      var type = "ios" == Device.system.os ? Texture.HALF_FLOAT : Texture.FLOAT,
        parameters = {
          minFilter: Texture.NEAREST,
          magFilter: Texture.NEAREST,
          format: Texture.RGBAFormat,
          type: type,
        },
        rt = new RenderTarget(size, size, parameters);
      return (rt.texture.generateMipmaps = !1), rt;
    }
    var _this = this;
    this.UILPrefix = "am_" + _shader;
    const _uniforms = {
      tInput: { type: "t", value: null, ignoreUIL: !0 },
      fSize: { type: "f", value: 64, ignoreUIL: !0 },
    };
    var _rts = [],
      _read = 0,
      _write = 0;
    (this.uniforms = _uniforms),
      (this.output = initRT(64)),
      (this.name = _shader),
      (this.id = Utils.timestamp()),
      (this.ready = !1),
      (function () {
        if (_uni) {
          _uni.unique &&
            ((_this.UILPrefix += "_" + _uni.unique.replace("/", "_")),
            delete _uni.unique),
            _uni.customCompile &&
              ((_this.customCompile = _uni.customCompile || ""),
              delete _uni.customCompile);
          for (var key in _uni) _uniforms[key] = _uni[key];
        }
      })(),
      (this.addInput = function (name, attribute) {
        var uniform =
          "object" != typeof attribute ||
          attribute.height ||
          "string" != typeof attribute.type
            ? attribute instanceof AntimatterAttribute
              ? { type: "t", value: attribute.texture, ignoreUIL: !0 }
              : { type: "t", value: attribute, ignoreUIL: !0 }
            : attribute;
        let lookup = UILStorage.parse(_this.UILPrefix + name);
        return (
          lookup && (uniform.value = lookup.value),
          (_uniforms[name] = uniform),
          (uniform.ignoreUIL = !0),
          _uniforms[name]
        );
      }),
      (this.addUniforms = function (object) {
        for (let key in object) {
          let uniform = object[key],
            lookup = UILStorage.parse(_this.UILPrefix + key);
          if (lookup) {
            if (Array.isArray(lookup.value))
              switch (lookup.value.length) {
                case 2:
                  lookup.value = new Vector2().fromArray(lookup.value);
                  break;
                case 3:
                  lookup.value = new Vector3().fromArray(lookup.value);
                  break;
                case 4:
                  lookup.value = new Vector4().fromArray(lookup.value);
              }
            uniform.value = lookup.value;
          }
          _uniforms[key] = uniform;
        }
      }),
      (this.getRT = function (index) {
        return _rts[index];
      }),
      (this.getRead = function () {
        return _rts[_read];
      }),
      (this.getWrite = function () {
        return _rts[_write];
      }),
      (this.setRead = function (index) {
        _read = index;
      }),
      (this.setWrite = function (index) {
        _write = index;
      }),
      (this.swap = function () {
        ++_write > 2 && ((_write = 0), (_this.ready = !0)),
          ++_read > 2 && (_read = 0);
      }),
      (this.initialize = function (size) {
        if (!_this.init) {
          _this.init = !0;
          for (var i = 0; i < 3; i++) _rts.push(initRT(size));
          _this.output.setSize(size, size),
            _shader instanceof Shader ||
              (((_shader = new Shader("AntimatterPass", _shader, {
                customCompile: _this.customCompile,
              })).preCompile = prepareShader),
              (_shader.uniforms = _uniforms),
              (_shader.UILPrefix = _this.UILPrefix),
              (_shader.id = Utils.timestamp())),
            (_this.shader = _shader),
            (_shader.uniforms.fSize.value = size);
        }
      }),
      (this.setUniform = function (key, value) {
        (_uniforms[key] = { value: value }),
          _shader && _shader.uniforms && (_shader.uniforms[key].value = value);
      }),
      (this.getUniform = function (key) {
        return _shader && _shader.uniforms ? _shader.uniforms[key].value : null;
      }),
      (this.tween = function (key, value, time, ease, delay, callback, update) {
        return tween(
          _shader.uniforms[key],
          { value: value },
          time,
          ease,
          delay,
          callback,
          update
        );
      }),
      (this.clone = function () {
        return new AntimatterPass(_shader, _uni);
      }),
      (this.destroy = function () {
        _rts.forEach(function (rt) {
          rt && rt.destroy && rt.destroy();
        });
      });
  }),
  Class(function AntimatterUtil() {
    function initThread() {
      (_thread = !0), Thread.upload(createBufferArrayAntimatter);
    }
    function createBufferArrayAntimatter(e, id) {
      var size = e.size,
        num = e.num,
        position = new Float32Array(3 * num);
      for (let i = 0; i < num; i++)
        (position[3 * i + 0] = (i % size) / size),
          (position[3 * i + 1] = Math.floor(i / size) / size),
          (position[3 * i + 2] = 0);
      let { w: w, h: h, d: d } = e.dimensions;
      var vertices = new Float32Array(4 * num);
      for (let i = 0; i < num; i++)
        (vertices[4 * i + 0] = Math.random(w[0], w[1], 4)),
          (vertices[4 * i + 1] = Math.random(h[0], h[1], 4)),
          (vertices[4 * i + 2] = Math.random(d[0], d[1], 4)),
          (vertices[4 * i + 3] = 1);
      var attribs = new Float32Array(4 * num);
      for (let i = 0; i < num; i++)
        (attribs[4 * i + 0] = Math.random(0, 1, 4)),
          (attribs[4 * i + 1] = Math.random(0, 1, 4)),
          (attribs[4 * i + 2] = Math.random(0, 1, 4)),
          (attribs[4 * i + 3] = Math.random(0, 1, 4));
      resolve({ array: position, vertices: vertices, attribs: attribs }, id, [
        position.buffer,
        vertices.buffer,
        attribs.buffer,
      ]);
    }
    Inherit(this, Component);
    var _thread,
      _this = this;
    (this.dimensions = { w: [-10, 10], h: [-10, 10], d: [-10, 10] }),
      (this.createBufferArray = function (size, num, config, callback) {
        _thread || initThread(),
          Thread.shared().createBufferArrayAntimatter(
            { size: size, num: num, dimensions: config || _this.dimensions },
            function (data) {
              callback(data.array, data.vertices, data.attribs);
            }
          );
      });
  }, "static"),
  Class(function Canvas(_width, _height, _retina) {
    function resize(w, h, retina) {
      var ratio = retina && Device.system.retina ? 2 : 1;
      _this.div &&
        ((_this.div.width = w * ratio), (_this.div.height = h * ratio)),
        (_this.width = w),
        (_this.height = h),
        (_this.scale = ratio),
        _this.element && _this.element.size(_this.width, _this.height),
        Device.system.retina &&
          retina &&
          (_this.context.scale(ratio, ratio),
          (_this.div.style.width = w + "px"),
          (_this.div.style.height = h + "px"));
    }
    Inherit(this, Component);
    var _imgData,
      _this = this;
    (this.children = []),
      (this.offset = { x: 0, y: 0 }),
      (this.retina = _retina),
      (_this.div = document.createElement("canvas")),
      (_this.context = _this.div.getContext("2d")),
      (_this.element = $(_this.div)),
      (_this.width = _width),
      (_this.height = _height),
      (_this.context._matrix = new Matrix2()),
      resize(_width, _height, _retina),
      (this.toDataURL = function (type, quality) {
        return _this.div.toDataURL(type, quality);
      }),
      (this.sort = function () {
        _objects.sort(function (a, b) {
          return a.z - b.z;
        });
      }),
      (this.render = function (noClear) {
        ("boolean" == typeof noClear && noClear) || _this.clear();
        for (var len = _this.children.length, i = 0; i < len; i++)
          _this.children[i].render();
        _this._rendered = Render.TIME;
      }),
      (this.clear = function () {
        _this.context.clearRect(0, 0, _this.div.width, _this.div.height);
      }),
      (this.add = function (display) {
        display.setCanvas(this),
          (display._parent = this),
          this.children.push(display),
          (display._z = this.children.length);
      }),
      (this.remove = function (display) {
        if (display) {
          (display._canvas = null), (display._parent = null);
          var i = this.children.indexOf(display);
          i > -1 && this.children.splice(i, 1);
        }
      }),
      (this.onDestroy = function () {
        this.stopRender();
        for (var i = 0; i < this.children.length; i++)
          this.children[i].destroy && this.children[i].destroy();
      }),
      (this.start = function () {
        Render.start(_this.render);
      }),
      (this.stop = function () {
        Render.stop(_this.render);
      }),
      (this.getImageData = function (x, y, w, h) {
        return (
          (this.imageData = this.context.getImageData(
            x || 0,
            y || 0,
            w || this.width,
            h || this.height
          )),
          this.imageData
        );
      }),
      (this.getPixel = function (x, y, dirty) {
        (this.imageData && !dirty) ||
          _this.getImageData(0, 0, _this.width, _this.height),
          _imgData || (_imgData = {});
        var index = 4 * (x + y * _this.width),
          pixels = this.imageData.data;
        return (
          (_imgData.r = pixels[index]),
          (_imgData.g = pixels[index + 1]),
          (_imgData.b = pixels[index + 2]),
          (_imgData.a = pixels[index + 3]),
          _imgData
        );
      }),
      (this.texture = function (src) {
        var img = new Image();
        return (img.src = src), img;
      }),
      (this.size = resize);
  }),
  Class(function CanvasTexture(_texture, _w, _h, _force) {
    function initTexture() {
      if ("string" == typeof _texture) {
        let url = _texture;
        (_texture = null),
          Assets.decodeImage(url, !1).then((image) => {
            (_this.texture = _texture = image), setDimensions();
          });
      } else setDimensions(), (_this.texture = _texture);
    }
    function setDimensions() {
      _this.onload && _this.onload(),
        _this.width ||
          _this.height ||
          ((_this.width =
            _texture.width / (_this._canvas && _this._canvas.retina ? 2 : 1)),
          (_this.height =
            _texture.height / (_this._canvas && _this._canvas.retina ? 2 : 1)));
    }
    Inherit(this, CanvasObject);
    var _mask,
      _this = this;
    (this.width = _w || 0),
      (this.height = _h || 0),
      initTexture(),
      this.set("texture", function (img) {
        _texture = img;
      }),
      (this.draw = function (override) {
        var context = this._canvas.context;
        if (this.isMask() && !override) return !1;
        _texture &&
          (this.startDraw(this.anchor.tx, this.anchor.ty, override),
          context.drawImage(
            _texture,
            -this.anchor.tx,
            -this.anchor.ty,
            this.width,
            this.height
          ),
          this.endDraw()),
          _mask &&
            ((context.globalCompositeOperation = "source-in"),
            _mask.render(!0),
            (context.globalCompositeOperation = "source-over"));
      }),
      (this.mask = function (object) {
        if (!object) return (_mask = null);
        if (!this._parent)
          throw "CanvasTexture :: Must add to parent before masking.";
        for (
          var siblings = this._parent.children, canMask = !1, i = 0;
          i < siblings.length;
          i++
        )
          object == siblings[i] && (canMask = !0);
        if (!canMask) throw "CanvasGraphics :: Can only mask a sibling";
        (_mask = object), (object.masked = this);
      });
  }),
  Class(
    function Matrix2() {
      function identity(d) {
        ((d = d || _this.data)[0] = 1),
          (d[1] = 0),
          (d[2] = 0),
          (d[3] = 0),
          (d[4] = 1),
          (d[5] = 0),
          (d[6] = 0),
          (d[7] = 0),
          (d[8] = 1);
      }
      function noE(n) {
        return (n = Math.abs(n) < 1e-6 ? 0 : n);
      }
      var a11,
        a12,
        a13,
        a21,
        a22,
        a23,
        a31,
        a32,
        a33,
        b11,
        b12,
        b13,
        b21,
        b22,
        b23,
        b31,
        b32,
        b33,
        _this = this,
        prototype = Matrix2.prototype;
      (this.type = "matrix2"),
        (this.data = new Float32Array(9)),
        identity(),
        void 0 === prototype.identity &&
          ((prototype.identity = function (d) {
            return identity(d), this;
          }),
          (prototype.transformVector = function (v) {
            var d = this.data,
              x = v.x,
              y = v.y;
            return (
              (v.x = d[0] * x + d[1] * y + d[2]),
              (v.y = d[3] * x + d[4] * y + d[5]),
              v
            );
          }),
          (prototype.setTranslation = function (tx, ty, m) {
            var d = m || this.data;
            return (
              (d[0] = 1),
              (d[1] = 0),
              (d[2] = tx),
              (d[3] = 0),
              (d[4] = 1),
              (d[5] = ty),
              (d[6] = 0),
              (d[7] = 0),
              (d[8] = 1),
              this
            );
          }),
          (prototype.getTranslation = function (v) {
            var d = this.data;
            return (v = v || new Vector2()), (v.x = d[2]), (v.y = d[5]), v;
          }),
          (prototype.setScale = function (sx, sy, m) {
            var d = m || this.data;
            return (
              (d[0] = sx),
              (d[1] = 0),
              (d[2] = 0),
              (d[3] = 0),
              (d[4] = sy),
              (d[5] = 0),
              (d[6] = 0),
              (d[7] = 0),
              (d[8] = 1),
              this
            );
          }),
          (prototype.setShear = function (sx, sy, m) {
            var d = m || this.data;
            return (
              (d[0] = 1),
              (d[1] = sx),
              (d[2] = 0),
              (d[3] = sy),
              (d[4] = 1),
              (d[5] = 0),
              (d[6] = 0),
              (d[7] = 0),
              (d[8] = 1),
              this
            );
          }),
          (prototype.setRotation = function (a, m) {
            var d = m || this.data,
              r0 = Math.cos(a),
              r1 = Math.sin(a);
            return (
              (d[0] = r0),
              (d[1] = -r1),
              (d[2] = 0),
              (d[3] = r1),
              (d[4] = r0),
              (d[5] = 0),
              (d[6] = 0),
              (d[7] = 0),
              (d[8] = 1),
              this
            );
          }),
          (prototype.setTRS = function (tx, ty, a, sx, sy) {
            var d = this.data,
              r0 = Math.cos(a),
              r1 = Math.sin(a);
            return (
              (d[0] = r0 * sx),
              (d[1] = -r1 * sy),
              (d[2] = tx),
              (d[3] = r1 * sx),
              (d[4] = r0 * sy),
              (d[5] = ty),
              (d[6] = 0),
              (d[7] = 0),
              (d[8] = 1),
              this
            );
          }),
          (prototype.translate = function (tx, ty) {
            return (
              this.identity(Matrix2.__TEMP__),
              this.setTranslation(tx, ty, Matrix2.__TEMP__),
              this.multiply(Matrix2.__TEMP__)
            );
          }),
          (prototype.rotate = function (a) {
            return (
              this.identity(Matrix2.__TEMP__),
              this.setTranslation(a, Matrix2.__TEMP__),
              this.multiply(Matrix2.__TEMP__)
            );
          }),
          (prototype.scale = function (sx, sy) {
            return (
              this.identity(Matrix2.__TEMP__),
              this.setScale(sx, sy, Matrix2.__TEMP__),
              this.multiply(Matrix2.__TEMP__)
            );
          }),
          (prototype.shear = function (sx, sy) {
            return (
              this.identity(Matrix2.__TEMP__),
              this.setRotation(sx, sy, Matrix2.__TEMP__),
              this.multiply(Matrix2.__TEMP__)
            );
          }),
          (prototype.multiply = function (m) {
            var a = this.data,
              b = m.data || m;
            return (
              (a11 = a[0]),
              (a12 = a[1]),
              (a13 = a[2]),
              (a21 = a[3]),
              (a22 = a[4]),
              (a23 = a[5]),
              (a31 = a[6]),
              (a32 = a[7]),
              (a33 = a[8]),
              (b11 = b[0]),
              (b12 = b[1]),
              (b13 = b[2]),
              (b21 = b[3]),
              (b22 = b[4]),
              (b23 = b[5]),
              (b31 = b[6]),
              (b32 = b[7]),
              (b33 = b[8]),
              (a[0] = a11 * b11 + a12 * b21 + a13 * b31),
              (a[1] = a11 * b12 + a12 * b22 + a13 * b32),
              (a[2] = a11 * b13 + a12 * b23 + a13 * b33),
              (a[3] = a21 * b11 + a22 * b21 + a23 * b31),
              (a[4] = a21 * b12 + a22 * b22 + a23 * b32),
              (a[5] = a21 * b13 + a22 * b23 + a23 * b33),
              this
            );
          }),
          (prototype.inverse = function (m) {
            var a = (m = m || this).data,
              b = this.data;
            (a11 = a[0]),
              (a12 = a[1]),
              (a13 = a[2]),
              (a21 = a[3]),
              (a22 = a[4]),
              (a23 = a[5]),
              (a31 = a[6]),
              (a32 = a[7]),
              (a33 = a[8]);
            var det = m.determinant();
            Math.abs(det);
            var invdet = 1 / det;
            return (
              (b[0] = (a22 * a33 - a32 * a23) * invdet),
              (b[1] = (a13 * a32 - a12 * a33) * invdet),
              (b[2] = (a12 * a23 - a13 * a22) * invdet),
              (b[3] = (a23 * a31 - a21 * a33) * invdet),
              (b[4] = (a11 * a33 - a13 * a31) * invdet),
              (b[5] = (a21 * a13 - a11 * a23) * invdet),
              (b[6] = (a21 * a32 - a31 * a22) * invdet),
              (b[7] = (a31 * a12 - a11 * a32) * invdet),
              (b[8] = (a11 * a22 - a21 * a12) * invdet),
              m
            );
          }),
          (prototype.determinant = function () {
            var a = this.data;
            return (
              (a11 = a[0]),
              (a12 = a[1]),
              (a13 = a[2]),
              (a21 = a[3]),
              (a22 = a[4]),
              (a23 = a[5]),
              (a31 = a[6]),
              (a32 = a[7]),
              (a33 = a[8]),
              a11 * (a22 * a33 - a32 * a23) -
                a12 * (a21 * a33 - a23 * a31) +
                a13 * (a21 * a32 * a22 * a31)
            );
          }),
          (prototype.copyTo = function (m) {
            var a = this.data,
              b = m.data || m;
            return (
              (b[0] = a[0]),
              (b[1] = a[1]),
              (b[2] = a[2]),
              (b[3] = a[3]),
              (b[4] = a[4]),
              (b[5] = a[5]),
              (b[6] = a[6]),
              (b[7] = a[7]),
              (b[8] = a[8]),
              m
            );
          }),
          (prototype.copyFrom = function (m) {
            var a = this.data,
              b = m.data || m;
            return (
              (b[0] = a[0]),
              (b[1] = a[1]),
              (b[2] = a[2]),
              (b[3] = a[3]),
              (b[4] = a[4]),
              (b[5] = a[5]),
              (b[6] = a[6]),
              (b[7] = a[7]),
              (b[8] = a[8]),
              this
            );
          }),
          (prototype.getCSS = function (force2D) {
            var d = this.data;
            return Device.tween.css3d && !force2D
              ? "matrix3d(" +
                  noE(d[0]) +
                  ", " +
                  noE(d[3]) +
                  ", 0, 0, " +
                  noE(d[1]) +
                  ", " +
                  noE(d[4]) +
                  ", 0, 0, 0, 0, 1, 0, " +
                  noE(d[2]) +
                  ", " +
                  noE(d[5]) +
                  ", 0, 1)"
              : "matrix(" +
                  noE(d[0]) +
                  ", " +
                  noE(d[3]) +
                  ", " +
                  noE(d[1]) +
                  ", " +
                  noE(d[4]) +
                  ", " +
                  noE(d[2]) +
                  ", " +
                  noE(d[5]) +
                  ")";
          }));
    },
    function () {
      Matrix2.__TEMP__ = new Matrix2().data;
    }
  ),
  Class(function SplitTextfield() {
    function splitLetter($obj) {
      var _array = [],
        split = $obj.div.innerHTML.split("");
      $obj.div.innerHTML = "";
      for (var i = 0; i < split.length; i++) {
        " " == split[i] && (split[i] = "&nbsp;");
        var letter = $("t", "span");
        letter.html(split[i], !0).css(_style),
          _array.push(letter),
          $obj.add(letter);
      }
      return _array;
    }
    function splitWord($obj) {
      var _array = [],
        text = $obj.div.innerHTML,
        split = (text = text.replace("&nbsp;", " ")).split(" ");
      $obj.empty();
      for (var i = 0; i < split.length; i++) {
        var word = $("t", "span"),
          empty = $("t", "span");
        word.html(split[i]).css(_style),
          empty.html("&nbsp", !0).css(_style),
          _array.push(word),
          _array.push(empty),
          $obj.add(word),
          $obj.add(empty);
      }
      return _array;
    }
    var _style = {
      padding: 0,
      margin: 0,
      position: "relative",
      float: "",
      cssFloat: "",
      styleFloat: "",
      display: "inline-block",
      width: "auto",
      height: "auto",
    };
    this.split = function ($obj, by) {
      return "word" == by ? splitWord($obj) : splitLetter($obj);
    };
  }, "Static");
class CubicPoly {
  constructor(x0, x1, t0, t1) {
    this.init(x0, x1, t0, t1);
  }
  init(x0, x1, t0, t1) {
    (this.c0 = x0),
      (this.c1 = t0),
      (this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1),
      (this.c3 = 2 * x0 - 2 * x1 + t0 + t1);
  }
  initCatmullRom(x0, x1, x2, x3, tension) {
    this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
  }
  initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
    let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1,
      t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
    (t1 *= dt1), (t2 *= dt1), this.init(x1, x2, t1, t2);
  }
  calc(t) {
    let t2 = t * t,
      t3 = t2 * t;
    return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
  }
}
Class(function Curve(_input) {
  function initFromArray() {
    let points = [];
    for (let i = 0; i < _input.length; i++)
      points.push(new Vector3().fromArray(_input[i]));
    _curve = new CatmullRomCurve(points);
  }
  function initFromObj(obj) {
    if ("string" == typeof obj) {
      let name = obj;
      if (!(obj = Assets.JSON[obj])) throw `No curve ${name} found`;
      obj.curves = obj.curves[0];
    } else obj.curves = Array.isArray(obj.curves[0]) ? obj.curves[0] : obj.curves;
    for (var data = obj.curves, points = [], j = 0; j < data.length; j += 3)
      points.push(new Vector3(data[j + 0], data[j + 1], data[j + 2]));
    _curve = new CatmullRomCurve(points);
  }
  Inherit(this, Component);
  const _this = this;
  var _curve;
  (this.root = new Group()),
    Array.isArray(_input) && Array.isArray(_input[0])
      ? initFromArray()
      : initFromObj(_input),
    (this.debug = function () {
      let points = _curve.getPoints(50),
        geometry = new Geometry().setFromPoints(points),
        shader = Utils3D.getTestShader(4095),
        curveObject = new Line(geometry, shader);
      return _this.root.add(curveObject), _this.root;
    }),
    (this.getPointAt = function (t) {
      (t = Math.max(0, Math.min(1, t))), this.root.updateMatrixWorld();
      let pos = _curve.getPointAt(t);
      return pos.applyMatrix4(this.root.matrixWorld), pos;
    }),
    (this.getPoint = function (t) {
      (t = Math.max(0, Math.min(1, t))), this.root.updateMatrixWorld();
      let pos = _curve.getPoint(t);
      return pos.applyMatrix4(this.root.matrixWorld), pos;
    }),
    (this.getTangent = function (t) {
      (t = Math.max(0, Math.min(1, t))), this.root.updateMatrixWorld();
      let pos = _curve.getTangent(t);
      return pos.applyMatrix4(this.root.matrixWorld), pos;
    });
});
class Curve3D {
  constructor() {
    this.arcLengthDivisions = 200;
  }
  getPointAt(u) {
    let t = this.getUtoTmapping(u);
    return this.getPoint(t);
  }
  getPoints(divisions = 5) {
    let points = [];
    for (let d = 0; d <= divisions; d++)
      points.push(this.getPoint(d / divisions));
    return points;
  }
  getSpacedPoints(divisions = 5) {
    let points = [];
    for (let d = 0; d <= divisions; d++)
      points.push(this.getPointAt(d / divisions));
    return points;
  }
  getLength() {
    let lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  getLengths(divisions = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === divisions + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    let current,
      p,
      cache = [],
      last = this.getPoint(0),
      sum = 0;
    for (cache.push(0), p = 1; p <= divisions; p++)
      (sum += (current = this.getPoint(p / divisions)).distanceTo(last)),
        cache.push(sum),
        (last = current);
    return (this.cacheArcLengths = cache), cache;
  }
  updateArtLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(u, distance) {
    let targetArcLength,
      arcLengths = this.getLengths(),
      i = 0,
      il = arcLengths.length;
    targetArcLength = distance || u * arcLengths[il - 1];
    let comparison,
      low = 0,
      high = il - 1;
    for (; low <= high; )
      if (
        ((i = Math.floor(low + (high - low) / 2)),
        (comparison = arcLengths[i] - targetArcLength) < 0)
      )
        low = i + 1;
      else {
        if (!(comparison > 0)) {
          high = i;
          break;
        }
        high = i - 1;
      }
    if (((i = high), arcLengths[i] === targetArcLength)) return i / (il - 1);
    let lengthBefore = arcLengths[i];
    return (
      (i +
        (targetArcLength - lengthBefore) / (arcLengths[i + 1] - lengthBefore)) /
      (il - 1)
    );
  }
  getTangent(t) {
    let t1 = t - 1e-4,
      t2 = t + 1e-4;
    t1 < 0 && (t1 = 0), t2 > 1 && (t2 = 1);
    let pt1 = this.getPoint(t1);
    return this.getPoint(t2).clone().sub(pt1).normalize();
  }
  getTangentAt(u) {
    let t = this.getUtoTmapping(u);
    return this.getTangent(t);
  }
  computeFrenetFrames(segments, closed) {
    let i,
      u,
      theta,
      normal = new Vector3(),
      tangents = [],
      normals = [],
      binormals = [],
      vec = new Vector3(),
      mat = new Matrix4();
    for (i = 0; i <= segments; i++)
      (u = i / segments),
        (tangents[i] = this.getTangentAt(u)),
        tangents[i].normalize();
    (normals[0] = new Vector3()), (binormals[0] = new Vector3());
    let min = Number.MAX_VALUE,
      tx = Math.abs(tangents[0].x),
      ty = Math.abs(tangents[0].y),
      tz = Math.abs(tangents[0].z);
    for (
      tx <= min && ((min = tx), normal.set(1, 0, 0)),
        ty <= min && ((min = ty), normal.set(0, 1, 0)),
        tz <= min && normal.set(0, 0, 1),
        vec.crossVectors(tangents[0], normal).normalize(),
        normals[0].crossVectors(tangents[0], vec),
        binormals[0].crossVectors(tangents[0], normals[0]),
        i = 1;
      i <= segments;
      i++
    )
      (normals[i] = normals[i - 1].clone()),
        (binormals[i] = binormals[i - 1].clone()),
        vec.crossVectors(tangents[i - 1], tangents[i]),
        vec.length() > Number.EPSILON &&
          (vec.normalize(),
          (theta = Math.acos(
            Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)
          )),
          normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta))),
        binormals[i].crossVectors(tangents[i], normals[i]);
    if (!0 === closed)
      for (
        theta = Math.acos(Math.clamp(normals[0].dot(normals[segments]), -1, 1)),
          theta /= segments,
          tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) >
            0 && (theta = -theta),
          i = 1;
        i <= segments;
        i++
      )
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i)),
          binormals[i].crossVectors(tangents[i], normals[i]);
    return { tangents: tangents, normals: normals, binormals: binormals };
  }
}
class CatmullRomCurve extends Curve3D {
  constructor(points = []) {
    if (
      (super(),
      (this.tmp = new Vector3()),
      (this.px = new CubicPoly()),
      (this.py = new CubicPoly()),
      (this.pz = new CubicPoly()),
      points.length < 2)
    )
      throw "CatmullRomCurve: Points array needs at least two entries.";
    (this.points = points), (this.closed = !1);
  }
  getLength() {
    const tmp = this.tmp;
    let length = 0;
    return (
      this.points.forEach((p, i) => {
        0 !== i &&
          (tmp.subVectors(p, this.points[i - 1]), (length += tmp.length()));
      }),
      length
    );
  }
  getPoint(t, target) {
    let tmp = this.tmp,
      px = this.px,
      py = this.py,
      pz = this.pz,
      points = this.points,
      l = points.length,
      point = (l - (this.closed ? 0 : 1)) * t,
      intPoint = Math.floor(point),
      weight = point - intPoint;
    this.closed
      ? (intPoint +=
          intPoint > 0
            ? 0
            : (Math.floor(Math.abs(intPoint) / points.length) + 1) *
              points.length)
      : 0 === weight &&
        intPoint === l - 1 &&
        ((intPoint = l - 2), (weight = 1));
    let p0, p1, p2, p3;
    if (
      (this.closed || intPoint > 0
        ? (p0 = points[(intPoint - 1) % l])
        : (tmp.subVectors(points[0], points[1]).add(points[0]), (p0 = tmp)),
      (p1 = points[intPoint % l]),
      (p2 = points[(intPoint + 1) % l]),
      this.closed || intPoint + 2 < l
        ? (p3 = points[(intPoint + 2) % l])
        : (tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]),
          (p3 = tmp)),
      void 0 === this.type ||
        "centripetal" === this.type ||
        "chordal" === this.type)
    ) {
      let pow = "chordal" === this.type ? 0.5 : 0.25,
        dt0 = Math.pow(p0.distanceToSquared(p1), pow),
        dt1 = Math.pow(p1.distanceToSquared(p2), pow),
        dt2 = Math.pow(p2.distanceToSquared(p3), pow);
      dt1 < 1e-4 && (dt1 = 1),
        dt0 < 1e-4 && (dt0 = dt1),
        dt2 < 1e-4 && (dt2 = dt1),
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2),
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2),
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if ("catmullrom" === this.type) {
      let tension = void 0 !== this.tension ? this.tension : 0.5;
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension),
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension),
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
    }
    if (!target)
      return new Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
    target.set(px.calc(weight), py.calc(weight), pz.calc(weight));
  }
  getPoints(num) {
    const tmp = this.tmp,
      points = [];
    for (let i = 0; i < num; i++)
      this.getPoint(i / (num - 1), tmp), points.push(tmp.x, tmp.y, tmp.z);
    return points;
  }
}
Class(function ImageDecoder() {
  function decodeImage(data, id) {
    (async (_) => {
      let e = await fetch(data.path, { mode: "cors" });
      if (200 != e.status) throw `Image not found :: ${data.path}`;
      try {
        let blob = await e.blob(),
          obj = { imageOrientation: "flipY", crossOrigin: "anonymous" };
        data.params &&
          !1 === data.params.premultiplyAlpha &&
          (obj.premultiplyAlpha = "none"),
          (obj.imageOrientation =
            data.params && !1 === data.params.flipY ? void 0 : "flipY");
        let bitmap = await createImageBitmap(blob, obj),
          message = { post: !0, id: id, message: bitmap };
        self.postMessage(message, [bitmap]);
      } catch (e) {
        throw `${data.path} could not be decoded`;
      }
    })();
  }
  function decodeCompressedImage(data, id) {
    (async (_) => {
      let config = await get(data.path + "/image.json"),
        ext = null;
      for (let key in data.settings)
        ext || (data.settings[key] && (ext = config[key]));
      let fileName = data.path.split("/");
      fileName = fileName[fileName.length - 1];
      let e = await fetch(`${data.path}/${fileName}-${ext}.ktx`);
      if (200 != e.status) throw `Image not found :: ${data.path}`;
      try {
        let arrayBuffer = await e.arrayBuffer(),
          header = new Int32Array(arrayBuffer, 12, 13),
          gliFormat = (header[1], header[2], header[3], header[4]),
          width = (header[5], header[6]),
          height = header[7],
          miplevels = header[11],
          buffers = [],
          compressedData = [],
          sizes = [],
          dataOffset = 64 + header[12];
        for (let level = 0; level < miplevels; level++) {
          let imageSize = new Int32Array(arrayBuffer, dataOffset, 1)[0];
          dataOffset += 4;
          let byteArray = new Uint8Array(arrayBuffer, dataOffset, imageSize);
          (dataOffset += imageSize),
            (dataOffset += 3 - ((imageSize + 3) % 4)),
            sizes.push(width),
            (width = Math.max(1, 0.5 * width)),
            (height = Math.max(1, 0.5 * height));
          let clone = new Uint8Array(byteArray);
          compressedData.push(clone), buffers.push(clone.buffer);
        }
        resolve(
          {
            gliFormat: gliFormat,
            compressedData: compressedData,
            sizes: sizes,
          },
          id,
          buffers
        );
      } catch (e) {
        throw `${data.path} could not be decoded`;
      }
    })();
  }
  function process(bitmap, scale) {
    if (1 == scale * _this.scale) return bitmap;
    let pow2 = Math.isPowerOf2(bitmap.width, bitmap.height),
      canvas = document.createElement("canvas");
    return (
      (canvas.context = canvas.getContext("2d")),
      (canvas.width = Math.round(bitmap.width * _this.scale * scale)),
      (canvas.height = Math.round(bitmap.height * _this.scale * scale)),
      pow2 &&
        scale * _this.scale < 1 &&
        ((canvas.width = Math.floorPowerOf2(canvas.width)),
        (canvas.height = Math.floorPowerOf2(canvas.height))),
      canvas.context.drawImage(bitmap, 0, 0, canvas.width, canvas.height),
      canvas
    );
  }
  Inherit(this, Component);
  var _compressed,
    _this = this;
  const ACTIVE = !(
    !(
      window.fetch &&
      window.createImageBitmap &&
      Device.system.browser.includes("chrome")
    ) || window.AURA
  );
  (this.scale = 1),
    (async function () {
      await Hydra.ready(),
        Thread.upload(decodeImage),
        Thread.upload(decodeCompressedImage);
    })(),
    (this.decode = async function (path, params = {}) {
      return (path = Thread.absolutePath(Assets.getPath(path))).includes(
        "-compressedKtx"
      )
        ? (_compressed ||
            (_compressed = {
              dxt: !!Renderer.extensions.s3tc,
              etc: !!Renderer.extensions.etc1,
              pvrtc: !!Renderer.extensions.pvrtc,
              astc: !!Renderer.extensions.astc,
            }),
          (path = path.split(".")[0]),
          await Thread.shared().decodeCompressedImage({
            path: path,
            params: params,
            settings: _compressed,
          }))
        : process(
            await (ACTIVE
              ? Thread.shared().decodeImage({ path: path, params: params })
              : Assets.decodeImage(path, params)),
            params.scale || 1
          );
    });
}, "static"),
  Class(function BaseCamera() {
    Inherit(this, Object3D);
    const _this = this;
    (this.camera = new PerspectiveCamera(
      30,
      Stage.width / Stage.height,
      0.1,
      1e3
    )),
      this.group.add(this.camera),
      this.startRender((_) => {
        _this.group.updateMatrixWorld(!0);
      }),
      this.onResize((_) => {
        (_this.camera.aspect = Stage.width / Stage.height),
          _this.camera.updateProjectionMatrix();
      }),
      (this.playgroundLock = function (camera = Camera.instance()) {
        Global.PLAYGROUND &&
          Utils.getConstructorName(_this.parent).includes(
            Global.PLAYGROUND.split("/")[0]
          ) &&
          RenderManager.type == RenderManager.NORMAL &&
          camera.lock(_this.camera);
      }),
      (this.lock = function (camera = Camera.instance()) {
        RenderManager.type == RenderManager.NORMAL && camera.lock(_this.camera);
      }),
      (this.transition = function (
        time,
        ease,
        delay,
        camera = Camera.instance()
      ) {
        return (
          "object" == typeof delay && ((camera = delay), (delay = 0)),
          camera.transition(_this.camera, time, ease, delay || 0)
        );
      }),
      (this.setFOV = function (fov) {
        (this.camera.fov = fov), this.camera.updateProjectionMatrix();
      }),
      (this.getFOV = function () {
        return this.camera.fov;
      });
  }),
  Class(function Camera(_worldCamera) {
    function initDebug() {
      (_debug = new Mesh(
        new BoxGeometry(0.25, 0.25, 0.5),
        new Shader("DebugCamera")
      )),
        World.SCENE.add(_debug),
        (_worldCamera = new PerspectiveCamera());
      let p = Global.PLAYGROUND || "m",
        pos =
          Storage.get(`debugCameraPos_${p}`) || World.CAMERA.position.toArray();
      World.CAMERA.position.fromArray(pos);
      World.CONTROLS.onChange = (_) =>
        Storage.set(`debugCameraPos_${p}`, World.CAMERA.position.toArray());
    }
    function loop() {
      if (
        (_debug && (_debug.visible = !_debug.position.equals(_center)),
        (_anim.weight += (_anim.weight2 - _anim.weight) * _this.lerp),
        _prevCamera)
      ) {
        if (_this.curve) {
          let pos = _this.curve.getPoint(_anim.weight);
          pos.lerp(
            _prevCamera.getWorldPosition(),
            Math.range(_anim.weight, 0, 0.1, 1, 0, !0)
          ),
            pos.lerp(
              _lockCamera.getWorldPosition(),
              Math.range(_anim.weight, 0.6, 1, 0, 1, !0)
            ),
            _this.curve.lerpPos ||
              ((_this.curve.lerpPos = new Vector3().copy(
                _prevCamera.getWorldPosition()
              )),
              (_this.curve.lerpBlend = { value: 0 }));
          let lerp = Math.mix(
            _this.curveLerp || 1,
            1,
            _this.curve.lerpBlend.value
          );
          _this.curve.lerpPos.lerp(pos, lerp),
            0 == _this.curve.lerpBlend.value &&
              _calc
                .subVectors(
                  _worldCamera.position,
                  _lockCamera.getWorldPosition()
                )
                .length() < 0.01 &&
              ((_this.curve.lerpBlend.value = 0.001),
              tween(_this.curve.lerpBlend, { value: 1 }, 1e3, "linear"),
              _this.onCurveComplete && _this.onCurveComplete()),
            _worldCamera.position.copy(_this.curve.lerpPos);
        } else
          _worldCamera.position
            .copy(_prevCamera.getWorldPosition())
            .lerp(_lockCamera.getWorldPosition(), _anim.weight);
        _worldCamera.quaternion
          .copy(_prevCamera.getWorldQuaternion())
          .slerp(_lockCamera.getWorldQuaternion(), _anim.weight),
          _this.tweenFOV &&
            ((_worldCamera.fov +=
              (_lockCamera.fov - _worldCamera.fov) * _anim.weight),
            _worldCamera.updateProjectionMatrix());
      } else _lockCamera && Utils3D.decompose(_lockCamera, _worldCamera);
      _debug &&
        (_debug.position.copy(_worldCamera.position),
        _debug.quaternion.copy(_worldCamera.quaternion));
    }
    Inherit(this, Component);
    const _this = this;
    var _debug,
      _prevCamera,
      _lockCamera,
      _calc = new Vector3(),
      _anim = { weight: 0, weight2: 0 },
      _center = new Vector3();
    (this.tweenFOV = !1),
      (this.lerp = 1),
      Utils.query("orbit")
        ? initDebug()
        : World.CONTROLS && (World.CONTROLS.enabled = !1),
      _this.startRender(loop),
      (this.lock = function (camera) {
        (_lockCamera = camera),
          (_worldCamera.fov = _lockCamera.fov),
          _worldCamera.updateProjectionMatrix();
      }),
      (this.transition = function (
        camera,
        duration = 1e3,
        ease = "easeInOutCubic"
      ) {
        return (
          _this.curve && (_this.curve.lerpPos = _this.curve.lerpBlend = null),
          _prevCamera === camera
            ? ((duration *= 0.5 * Math.smoothStep(0.5, 1, _anim.weight) + 0.5),
              (_anim.weight = 1 - _anim.weight))
            : (_anim.weight = 0),
          (_anim.weight2 = _anim.weight),
          (_prevCamera = _lockCamera),
          (_lockCamera = camera),
          tween(_anim, { weight2: 1 }, duration, ease)
        );
      }),
      this.get("worldCamera", (_) => _worldCamera),
      this.set("debugScale", (s) => {
        _debug && _debug.scale.setScalar(s);
      }),
      (this.createLocal = function (camera) {
        return new Camera(camera.camera || camera);
      });
  }, "singleton"),
  Class(function GazeCamera() {
    function loop() {
      Device.mobile
        ? ((_move.x =
            _this.position.x +
            Math.range(Mobile.Accelerometer.x, -2, 2, -1, 1, !0) *
              _strength.v *
              _this.moveXY.x *
              0.5),
          (_move.y =
            _this.position.y +
            Math.range(Mobile.Accelerometer.y, -2, 2, -1, 1, !0) *
              _strength.v *
              _this.moveXY.y *
              0.5))
        : ((_move.x =
            _this.position.x +
            Math.range(Mouse.x, 0, Stage.width, -1, 1, !0) *
              _strength.v *
              _this.moveXY.x),
          (_move.y =
            _this.position.y +
            Math.range(Mouse.y, 0, Stage.height, -1, 1, !0) *
              _strength.v *
              _this.moveXY.y)),
        (_move.z = _this.position.z),
        _position.lerp(_move, _this.lerpSpeed2),
        _this.camera.position.lerp(_position, _this.lerpSpeed),
        _this.camera.lookAt(_this.lookAt);
    }
    Inherit(this, BaseCamera);
    const _this = this;
    var _strength = { v: 1 },
      _move = new Vector3(),
      _position = new Vector3();
    (this.moveXY = new Vector2(4, 4)),
      (this.position = new (function Position() {
        Inherit(this, Component);
        var _x = 0,
          _y = 0,
          _z = 0;
        this.get("x", (_) => _x),
          this.get("y", (_) => _y),
          this.get("z", (_) => _z),
          this.set("x", (x) => {
            _x = x;
          }),
          this.set("y", (y) => {
            _y = y;
          }),
          this.set("z", (z) => {
            (_z = z),
              (_move.z = _z),
              _this.camera.position.copy(_move),
              _position.copy(_move);
          }),
          (this.set = function (x, y, z) {
            (_x = x),
              (_y = y),
              (_z = z),
              (_move.z = z),
              _this.camera.position.copy(_move),
              _position.copy(_move);
          }),
          (this.toArray = function () {
            return [_x, _y, _z];
          }),
          (this.fromArray = function (array) {
            (_x = array[0]),
              (_y = array[1]),
              (_z = array[2]),
              _move.set(_x, _y, _z),
              _this.camera.position.copy(_move),
              _position.copy(_move);
          });
      })()),
      (this.position2 = _position),
      (this.lerpSpeed = 0.04),
      (this.lerpSpeed2 = 1),
      (this.lookAt = new Vector3(0, 0, 0)),
      Mobile.Accelerometer.capture(),
      _this.startRender(loop),
      (this.orbit = function (time = 1e3, ease = "easeInOutSine") {
        return tween(_strength, { v: 1 }, time, ease);
      }),
      (this.still = function (time = 300, ease = "easeInOutSine") {
        return tween(_strength, { v: 0 }, time, ease);
      });
  });
class Base3D {
  constructor() {
    (this.position = new Vector3D()),
      (this.rotation = new Euler()),
      (this.quaternion = new Quaternion()),
      (this.scale = new Vector3D(1, 1, 1)),
      (this._parent = null),
      (this.up = new Vector3(0, 1, 0)),
      (this.isObject3D = !0),
      (this.children = []),
      (this.childrenLength = 0),
      (this.modelViewMatrix = new Matrix4()),
      (this.normalMatrix = new Matrix3()),
      (this.matrix = new Matrix4()),
      (this.matrixWorld = new Matrix4()),
      (this.matrixAutoUpdate = !0),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixDirty = !0),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.frustumCulled = !0),
      (this._renderOrder = 0),
      (this.worldPos = new Vector3());
    const _this = this;
    this.quaternion.onChange((_) => {
      (_this.matrixDirty = !0),
        _this.rotation.setFromQuaternion(_this.quaternion, void 0, !1);
    }),
      this.rotation.onChange((_) => {
        (_this.matrixDirty = !0),
          _this.quaternion.setFromEuler(_this.rotation, !1);
      }),
      this.scale.onChange((_) => {
        _this.matrixDirty = !0;
      }),
      this.position.onChange((_) => {
        _this.matrixDirty = !0;
      });
  }
  get renderOrder() {
    return this._renderOrder;
  }
  set renderOrder(value) {
    this._renderOrder = value;
    let p = this._parent;
    for (; p; )
      p instanceof Scene && (p.displayNeedsUpdate = !0), (p = p._parent);
  }
  applyMatrix(matrix) {
    return (
      this.matrix.multiplyMatrices(matrix, this.matrix),
      this.matrix.decompose(this.position, this.quaternion, this.scale),
      this
    );
  }
  applyQuaternion(q) {
    return this.quaternion.premultiply(q), this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  localToWorld(v) {
    return v.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(v) {
    let m1 = this.M1 || new Matrix4();
    (this.M1 = m1), v.applyMatrix4(m1.getInverse(this.matrixWorld));
  }
  lookAt(x, y, z) {
    let m1 = this.M1 || new Matrix4();
    this.M1 = m1;
    let v = this.V1 || new Vector3();
    (this.V1 = v),
      x.isVector3 ? v.copy(x) : v.set(x, y, z),
      this.isCamera
        ? m1.lookAt(this.position, v, this.up)
        : m1.lookAt(v, this.position, this.up),
      this.quaternion.setFromRotationMatrix(m1);
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
      return this;
    }
    if (object === this) return this;
    if (
      (object && object.isObject3D
        ? (null !== object._parent && object._parent.remove(object),
          (object._parent = this),
          this.children.push(object),
          (this.childrenLength = this.children.length))
        : console.error("Object is not instance of Object3D", object),
      this.isScene)
    )
      this.displayNeedsUpdate = !0;
    else {
      let p = this._parent;
      for (; p; )
        p instanceof Scene && (p.displayNeedsUpdate = !0), (p = p._parent);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    if (this.isScene) this.displayNeedsUpdate = !0;
    else {
      let p = this._parent;
      for (; p; )
        p instanceof Scene && (p.displayNeedsUpdate = !0), (p = p._parent);
    }
    this.children.remove(object), (this.childrenLength = this.children.length);
  }
  getWorldPosition(target) {
    let v = this.V1 || new Vector3();
    return (
      (this.V1 = v),
      target || (target = v),
      this.updateMatrixWorld(),
      target.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldScale(target) {
    let v = this.V1 || new Vector3();
    this.V1 = v;
    let v2 = this.V12 || new Vector3();
    this.V2 = v2;
    let q = this.Q1 || new Quaternion();
    return (
      (this.Q1 = q),
      target || (target = v2),
      this.updateMatrixWorld(),
      this.matrixWorld.decompose(v, q, target),
      target
    );
  }
  getWorldQuaternion(target) {
    let v = this.V1 || new Vector3();
    this.V1 = v;
    let q = this.Q1 || new Quaternion();
    return (
      (this.Q1 = q),
      target || (target = q),
      this.updateMatrixWorld(),
      this.matrixWorld.decompose(v, target, v),
      target
    );
  }
  traverse(callback) {
    callback(this);
    let children = this.children;
    for (let i = 0; i < children.length; i++) children[i].traverse(callback);
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(force) {
    if (!force && !this.determineVisible()) return;
    (this.determineDirty() || force) &&
      !0 === this.matrixAutoUpdate &&
      this.updateMatrix(),
      (!0 !== this.matrixWorldNeedsUpdate && !0 !== force) ||
        (null === this._parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this._parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1));
    let children = this.children;
    for (let i = this.childrenLength - 1; i > -1; i--)
      children[i].updateMatrixWorld(force);
    this.matrixDirty = !1;
  }
  clone(recursive) {
    new this.constructor().copy(this, recursive);
  }
  copy(source, recursive) {
    if (
      ((this.name = source.name),
      this.up.copy(source.up),
      this.position.copy(source.position),
      this.quaternion.copy(source.quaternion),
      this.scale.copy(source.scale),
      this.matrix.copy(source.matrix),
      this.matrixWorld.copy(source.matrixWorld),
      (this.matrixAutoUpdate = source.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate),
      (this.visible = source.visible),
      (this.castShadow = source.castShadow),
      (this.receiveShadow = source.receiveShadow),
      (this.frustumCulled = source.frustumCulled),
      (this.renderOrder = source.renderOrder),
      !0 === recursive)
    )
      for (let i = 0; i < source.children.length; i++) {
        let child = source.children[i];
        this.add(child.clone());
      }
    return this;
  }
  render() {}
  determineVisible() {
    if (
      this.determineVisibleCacheTime > 0 &&
      Render.TIME - this.determineVisibleCacheTime < 8
    )
      return this.determineVisibleCache;
    if (!this.visible) return (this.determineVisibleCache = !1), !1;
    let p = this._parent;
    for (; p; ) {
      if (!p.visible) return (this.determineVisibleCache = !1), !1;
      p = p._parent;
    }
    return (this.determineVisibleCache = !0), !0;
  }
  determineDirty() {
    let p = this._parent;
    for (; p; ) {
      if (p.matrixDirty) return !0;
      p = p._parent;
    }
    return this.matrixDirty;
  }
  upload() {
    this &&
      !this._gl &&
      (this.shader && this.shader.upload(this, this.geometry),
      this.geometry && this.geometry.upload(this, this.shader));
  }
  destroy() {
    this.geometry && this.geometry.destroy && this.geometry.destroy(this),
      this.shader && this.shader.destroy && this.shader.destroy(this),
      this.hitDestroy && this.hitDestroy(),
      this._gl && this._gl.ubo && this._gl.ubo.destroy(),
      this._gl && this._gl.vao && this._gl.vao.destroy(),
      this._gl && (this._gl = null),
      this._parent && this._parent.remove(this),
      this.parent &&
        this.parent.__destroyChild &&
        this.parent.__destroyChild(this.__id);
  }
}
Class(
  function Renderer(_params = {}) {
    function setExtensions() {
      (_this.extensions = {}),
        _this.type != Renderer.WEBGL2
          ? ((_this.extensions.VAO = _gl.getExtension(
              "OES_vertex_array_object"
            )),
            (_this.extensions.instancedArrays = _gl.getExtension(
              "ANGLE_instanced_arrays"
            )),
            (_this.extensions.standardDerivatives = _gl.getExtension(
              "OES_standard_derivatives"
            )),
            (_this.extensions.depthTextures = _gl.getExtension(
              "WEBGL_depth_texture"
            )),
            (_this.extensions.drawBuffers =
              _gl.getExtension("WEBGL_draw_buffers")),
            (_this.extensions.halfFloat = _gl.getExtension(
              "OES_texture_half_float"
            )),
            (_this.extensions.float = _gl.getExtension("OES_texture_float")),
            (_this.extensions.colorBufferFloat = _gl.getExtension(
              "WEBGL_color_buffer_float"
            )))
          : (_this.extensions.colorBufferFloat = _gl.getExtension(
              "EXT_color_buffer_float"
            )),
        (_this.extensions.filterFloat = _gl.getExtension(
          "OES_texture_float_linear"
        )),
        (_this.extensions.anisotropy = _gl.getExtension(
          "EXT_texture_filter_anisotropic"
        )),
        (_this.extensions.astc = _gl.getExtension(
          "WEBGL_compressed_texture_astc"
        )),
        (_this.extensions.atc = _gl.getExtension(
          "WEBGL_compressed_texture_atc"
        )),
        (_this.extensions.etc = _gl.getExtension(
          "WEBGL_compressed_texture_etc"
        )),
        (_this.extensions.etc1 = _gl.getExtension(
          "WEBGL_compressed_texture_etc1"
        )),
        (_this.extensions.pvrtc = _gl.getExtension(
          "WEBGL_compressed_texture_pvrtc"
        )),
        (_this.extensions.s3tc = _gl.getExtension(
          "WEBGL_compressed_texture_s3tc"
        )),
        (_this.extensions.s3tc_srgb = _gl.getExtension(
          "WEBGL_compressed_texture_s3tc_srgb"
        )),
        (Renderer.extensions = _this.extensions);
    }
    function initUBO() {
      _this.type == Renderer.WEBGL2 && (_ubo = !0), (Renderer.UBO = _ubo);
    }
    function initCameraUBO(camera) {
      (camera._ubo = new UBO(0, _gl)),
        camera._ubo.push({ value: camera.projectionMatrix }),
        camera._ubo.push({ value: camera.matrixWorldInverse }),
        camera._ubo.push({ value: camera.worldPos }),
        camera._ubo.push({ value: _resolution }),
        camera._ubo.push(_time),
        camera._ubo.upload();
    }
    function initRenderers() {
      (Geometry.renderer = new GeometryRendererWebGL(_gl)),
        (Texture.renderer = new TextureRendererWebGL(_gl)),
        (Shader.renderer = new ShaderRendererWebGL(_gl)),
        (RenderTarget.renderer = new FBORendererWebGL(_gl));
    }
    function initMath() {
      (_projScreenMatrix = new Matrix4()),
        (_vector3 = new Vector3()),
        (_frustum = new Frustum());
    }
    function sortOpaque(array) {
      for (let i = array.length - 1; i > -1; i--) {
        let obj = array[i];
        obj.shader._gl || obj.shader.upload();
      }
      array.sort((a, b) => {
        if (a.renderOrder !== b.renderOrder)
          return a.renderOrder - b.renderOrder;
        let aid = a.shader._gl._id,
          bid = b.shader._gl._id;
        return aid !== bid ? aid - bid : a.id - b.id;
      });
    }
    function sortTransparent(array) {
      array.sort((a, b) =>
        a.renderOrder !== b.renderOrder
          ? a.renderOrder - b.renderOrder
          : a.worldPos.z !== b.worldPos.z
          ? a.worldPos.z - b.worldPos.z
          : a.id - b.id
      );
    }
    function projectObject(object, camera, scene) {
      if (void 0 !== object.shader) {
        let visible = object.determineVisible() && object.shader.visible;
        visible &&
          (object.modelViewMatrix.multiplyMatrices(
            camera.matrixWorldInverse,
            object.matrixWorld
          ),
          object.normalMatrix.getNormalMatrix(object.modelViewMatrix)),
          (scene.displayNeedsUpdate ||
            (object.shader.transparent && !scene.disableAutoSort && visible)) &&
            object.getWorldPosition(object.worldPos),
          scene.displayNeedsUpdate &&
            scene.toRender[object.shader.transparent ? 1 : 0].push(object);
      }
      if (!0 === object.visible || scene.displayNeedsUpdate)
        for (let i = object.childrenLength - 1; i > -1; i--)
          projectObject(object.children[i], camera, scene);
    }
    function attachSceneUniforms(object, scene, camera) {
      if (
        (Shader.renderer.appendUniform(
          object.shader,
          "normalMatrix",
          object.normalMatrix
        ),
        Shader.renderer.appendUniform(
          object.shader,
          "modelMatrix",
          object.matrixWorld
        ),
        Shader.renderer.appendUniform(
          object.shader,
          "modelViewMatrix",
          object.modelViewMatrix
        ),
        _ubo
          ? camera._ubo.bind(object.shader._gl.program, "global")
          : (Shader.renderer.appendUniform(
              object.shader,
              "projectionMatrix",
              camera.projectionMatrix
            ),
            Shader.renderer.appendUniform(
              object.shader,
              "viewMatrix",
              camera.matrixWorldInverse
            ),
            Shader.renderer.appendUniform(
              object.shader,
              "cameraPosition",
              camera.worldPos
            ),
            Shader.renderer.appendUniform(
              object.shader,
              "resolution",
              _resolution
            ),
            Shader.renderer.appendUniform(object.shader, "time", _time.value)),
        _this.shadows &&
          object.shader.receiveShadow &&
          !_this.overridePreventShadows)
      ) {
        let lights = Lighting.getShadowLights();
        object._gl || (object._gl = {}),
          object._gl.shadowData ||
            (object._gl.shadowData = {
              combined: new Float32Array(16 * lights.length),
            });
        for (let i = 0; i < lights.length; i++) {
          let light = lights[i];
          _m1.multiplyMatrices(
            light.shadow.camera.matrixWorldInverse,
            object.matrixWorld
          ),
            _m0.multiplyMatrices(light.shadow.camera.projectionMatrix, _m1),
            _m0.toArray(object._gl.shadowData.combined, 16 * i);
        }
        scene._shadowData &&
          (Shader.renderer.appendUniform(
            object.shader,
            "shadowMap",
            scene._shadowData[
              _this.overridePreventShadows ? "emptyMaps" : "maps"
            ]
          ),
          Shader.renderer.appendUniform(
            object.shader,
            "shadowMatrix",
            object._gl.shadowData.combined,
            "matrix"
          ),
          Shader.renderer.appendUniform(
            object.shader,
            "shadowLightPos",
            scene._shadowData.pos,
            "vec3"
          ),
          Shader.renderer.appendUniform(
            object.shader,
            "shadowSize",
            scene._shadowData.size,
            "float"
          ));
      }
    }
    function attachShadowUniforms(object, scene, light) {
      light._mvm || (light._mvm = new Matrix4()),
        light._nm || (light._nm = new Matrix3()),
        light._mvm.multiplyMatrices(
          light.shadow.camera.matrixWorldInverse,
          object.matrixWorld
        ),
        light._nm.getNormalMatrix(object.modelViewMatrix),
        Shader.renderer.appendUniform(
          object.shader.shadow,
          "normalMatrix",
          light._nm
        ),
        Shader.renderer.appendUniform(
          object.shader.shadow,
          "modelMatrix",
          object.matrixWorld
        ),
        Shader.renderer.appendUniform(
          object.shader.shadow,
          "modelViewMatrix",
          light._mvm
        ),
        _ubo
          ? light.shadow.camera._ubo.bind(object.shader._gl.program, "global")
          : (Shader.renderer.appendUniform(
              object.shader.shadow,
              "projectionMatrix",
              light.shadow.camera.projectionMatrix
            ),
            Shader.renderer.appendUniform(
              object.shader.shadow,
              "viewMatrix",
              light.shadow.camera.matrixWorldInverse
            ));
    }
    function loop(t, dt) {
      _time.value += 0.001 * dt;
    }
    function render(scene, camera, rt) {
      rt
        ? (_resolution.set(rt.width, rt.height), RenderTarget.renderer.bind(rt))
        : (Renderer.overrideViewport ||
            (_gl.viewport(0, 0, _width * _dpr, _height * _dpr),
            _resolution.set(_canvas.width, _canvas.height)),
          _this.autoClear &&
            (_gl.clearColor(
              Renderer.CLEAR[0],
              Renderer.CLEAR[1],
              Renderer.CLEAR[2],
              Renderer.CLEAR[3]
            ),
            _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT))),
        camera.parent || camera.updateMatrixWorld(),
        camera.getWorldPosition(camera.worldPos),
        _frustum.setFromCamera(camera),
        _ubo && (camera._ubo ? camera._ubo.update() : initCameraUBO(camera));
      for (let l = 0; l < 2; l++)
        for (let i = 0; i < scene.toRender[l].length; i++) {
          let object = scene.toRender[l][i];
          object.onBeforeRender && object.onBeforeRender(),
            object.determineVisible() &&
              object.shader.visible &&
              ((!1 !== object.frustumCulled &&
                !0 !== _frustum.intersectsObject(object)) ||
                (object.shader.draw(object, object.geometry),
                attachSceneUniforms(object, scene, camera),
                object.geometry.draw(object, object.shader),
                _ubo && camera._ubo.unbind()));
        }
      rt && RenderTarget.renderer.unbind();
    }
    function renderShadows(scene, camera) {
      let lights = Lighting.getShadowLights();
      scene._shadowData ||
        (scene._shadowData = {
          maps: [],
          emptyMaps: [],
          size: new Float32Array(lights.length),
          pos: new Float32Array(3 * lights.length),
          count: lights.length,
        }),
        scene._shadowData.count != lights.length &&
          ((scene._shadowData.size = new Float32Array(lights.length)),
          (scene._shadowData.pos = new Float32Array(3 * lights.length)),
          (scene._shadowData.count = lights.length));
      for (let i = 0; i < lights.length; i++) {
        let light = lights[i];
        light.prepareRender(),
          (scene._shadowData.maps[i] = light.shadow.rt.depth),
          (scene._shadowData.emptyMaps[i] = Utils3D.getEmptyTexture()),
          (scene._shadowData.size[i] = light.shadow.size),
          light.position.toArray(scene._shadowData.pos, 3 * i);
      }
      for (let i = 0; i < lights.length; i++) {
        let light = lights[i];
        light.shadow.frozen ||
          ((light) => {
            RenderTarget.renderer.bind(light.shadow.rt),
              light.shadow.camera.updateMatrixWorld(),
              camera.getWorldPosition(camera.worldPos),
              _frustum.setFromCamera(camera),
              _ubo &&
                (light.shadow.camera._ubo
                  ? light.shadow.camera._ubo.update()
                  : initCameraUBO(light.shadow.camera));
            for (let l = 0; l < 2; l++)
              for (let i = 0; i < scene.toRender[l].length; i++) {
                let object = scene.toRender[l][i];
                !0 === object.castShadow &&
                  object.determineVisible() &&
                  object.shader.visible &&
                  ((!1 !== object.frustumCulled &&
                    !0 !== _frustum.intersectsObject(object)) ||
                    (object.shader.shadow || Lighting.initShadowShader(object),
                    object.shader.shadow.draw(object, object.geometry),
                    attachShadowUniforms(object, scene, light),
                    object.geometry.draw(object, object.shader),
                    _ubo && light.shadow.camera._ubo.unbind()));
              }
            RenderTarget.renderer.unbind(light.shadow.rt);
          })(light);
      }
    }
    Inherit(this, Component);
    const _this = this;
    var _canvas,
      _gl,
      _width,
      _height,
      _anisotropy,
      _projScreenMatrix,
      _vector3,
      _frustum,
      _ubo,
      _dpr = 1,
      _resolution = new Vector2(),
      _m0 = new Matrix4(),
      _m1 = new Matrix4(),
      _time = { value: 0 };
    (this.autoClear = !0),
      (this.shadows = !1),
      (Renderer.instance = _this),
      (Renderer.CLEAR = [0, 0, 0, 1]),
      (function initContext() {
        let contextAttributes = {
          antialias: void 0 !== _params.antialias && _params.antialias,
          powerPreference: _params.powerPreference,
          preserveDrawingBuffer: _params.preserveDrawingBuffer,
          compatibleXRDevice: _params.compatibleXRDevice,
        };
        if (
          ((_canvas = _params.canvas || document.createElement("canvas")),
          _params.gl
            ? ((_gl = _params.gl),
              (_this.type = Device.graphics.webgl.version.includes([
                "webgl 2",
                "webgl2",
              ])
                ? Renderer.WEBGL2
                : Renderer.WEBGL1))
            : ["webgl2", "webgl", "experimental-webgl"].forEach((name) => {
                _gl ||
                  ("webgl2" == name && _params.forceWebGL1) ||
                  ((_gl = _canvas.getContext(name, contextAttributes)),
                  (_this.type =
                    _gl && "webgl2" == name
                      ? Renderer.WEBGL2
                      : Renderer.WEBGL1));
              }),
          !_gl)
        )
          throw "Error! Could not create WebGL context";
        (_this.domElement = _canvas),
          (Renderer.type = _this.type),
          (Renderer.context = _this.context = _gl);
      })(),
      setExtensions(),
      initRenderers(),
      initMath(),
      initUBO(),
      _this.startRender(loop),
      (this.render = function (scene, camera, rt, forceToScreen) {
        scene.displayNeedsUpdate &&
          ((scene.toRender[0].length = 0), (scene.toRender[1].length = 0)),
          scene.updateMatrixWorld(),
          projectObject(scene, camera, scene),
          scene.displayNeedsUpdate && sortOpaque(scene.toRender[0]),
          (scene.displayNeedsUpdate ||
            (scene.toRender[1].length && !scene.disableAutoSort)) &&
            sortTransparent(scene.toRender[1]),
          _this.shadows &&
            !_this.overridePreventShadows &&
            !_this.pauseShadowRendering &&
            scene.hasShadowLight &&
            renderShadows(scene, camera),
          rt || !_this.vrRenderingPath || forceToScreen
            ? rt || !_this.arRenderingPath || forceToScreen
              ? render(scene, camera, rt)
              : _this.arRenderingPath(render, scene, camera)
            : _this.vrRenderingPath(
                scene,
                camera,
                _projScreenMatrix,
                _frustum,
                attachSceneUniforms
              ),
          (scene.displayNeedsUpdate = !1),
          Shader.renderer.resetState();
      }),
      (this.renderSingle = function (object, camera, rt) {
        rt
          ? (_resolution.set(rt.width, rt.height),
            RenderTarget.renderer.bind(rt))
          : (Renderer.overrideViewport ||
              (_gl.viewport(0, 0, _width * _dpr, _height * _dpr),
              _resolution.set(_canvas.width, _canvas.height)),
            _this.autoClear &&
              (_gl.clearColor(
                Renderer.CLEAR[0],
                Renderer.CLEAR[1],
                Renderer.CLEAR[2],
                Renderer.CLEAR[3]
              ),
              _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT))),
          camera.getWorldPosition(camera.worldPos),
          object.modelViewMatrix.multiplyMatrices(
            camera.matrixWorldInverse,
            object.matrixWorld
          ),
          object.normalMatrix.getNormalMatrix(object.modelViewMatrix),
          object.getWorldPosition(object.worldPos),
          _ubo && (camera._ubo || initCameraUBO(camera)),
          object.shader.draw(object, object.geometry),
          object.noMatrices ||
            (Shader.renderer.appendUniform(
              object.shader,
              "normalMatrix",
              object.normalMatrix
            ),
            Shader.renderer.appendUniform(
              object.shader,
              "modelMatrix",
              object.matrixWorld
            ),
            Shader.renderer.appendUniform(
              object.shader,
              "modelViewMatrix",
              object.modelViewMatrix
            )),
          _ubo
            ? camera._ubo.bind(object.shader._gl.program, "global")
            : (Shader.renderer.appendUniform(
                object.shader,
                "projectionMatrix",
                camera.projectionMatrix
              ),
              Shader.renderer.appendUniform(
                object.shader,
                "viewMatrix",
                camera.matrixWorldInverse
              ),
              Shader.renderer.appendUniform(
                object.shader,
                "cameraPosition",
                camera.worldPos
              ),
              Shader.renderer.appendUniform(
                object.shader,
                "resolution",
                _resolution
              ),
              Shader.renderer.appendUniform(
                object.shader,
                "time",
                _time.value
              )),
          object.geometry.draw(object, object.shader),
          _ubo && camera._ubo.unbind(),
          rt && RenderTarget.renderer.unbind(rt),
          Shader.renderer.resetState();
      }),
      (this.setClearColor = function (color, alpha = 1) {
        (_this.clearColor = new Color(color)),
          (Renderer.CLEAR = [
            _this.clearColor.r,
            _this.clearColor.g,
            _this.clearColor.b,
            alpha,
          ]);
      }),
      (this.setClearAlpha = function (alpha) {
        Renderer.CLEAR[3] = alpha;
      }),
      (this.getClearColor = function () {
        return (
          _this.clearColor || (_this.clearColor = new Color(0, 0, 0)),
          _this.clearColor
        );
      }),
      (this.getClearAlpha = function () {
        return Renderer.CLEAR[3];
      }),
      (this.setPixelRatio = function (dpr) {
        (_dpr = dpr), this.setSize(_width, _height);
      }),
      (this.setSize = function (width, height) {
        (_width = width),
          (_height = height),
          (_canvas.width = width * _dpr),
          (_canvas.height = height * _dpr),
          (_canvas.style.width = `${width}px`),
          (_canvas.style.height = `${height}px`),
          _resolution.set(_canvas.width, _canvas.height);
      }),
      (this.getMaxAnisotropy = function () {
        return (
          _anisotropy ||
            (_anisotropy = _gl.getParameter(
              _this.extensions.anisotropy.MAX_TEXTURE_MAX_ANISOTROPY_EXT
            )),
          _anisotropy
        );
      }),
      (this.readPixels = function (rt, x = 0, y = 0, width, height) {
        width || (width = rt.width), height || (height = rt.height);
        let w = width - x,
          h = height - y,
          array = new Uint8Array(w * h * 4);
        return (
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl),
          _gl.readPixels(
            x,
            y,
            width,
            height,
            _gl.RGBA,
            _gl.UNSIGNED_BYTE,
            array
          ),
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, null),
          array
        );
      }),
      this.get("resolution", (_) => _resolution),
      this.get("time", (_) => _time),
      this.get("canvas", (_) => _canvas);
  },
  (_) => {
    (Renderer.WEBGL1 = "webgl1"),
      (Renderer.WEBGL2 = "webgl2"),
      (Renderer.STATIC_SHADOWS = "static_shadows"),
      (Renderer.SHADOWS_LOW = "shadows_low"),
      (Renderer.SHADOWS_MED = "shadows_med"),
      (Renderer.SHADOWS_HIGH = "shadows_high"),
      (Renderer.ID = 0);
  }
);
class CameraBase3D extends Base3D {
  constructor() {
    super(),
      (this.matrixWorldInverse = new Matrix4()),
      (this.projectionMatrix = new Matrix4()),
      (this.isCamera = !0);
  }
  copy(source, recursive) {
    return (
      Base3D.prototype.copy.call(this, source, recursive),
      this.matrixWorldInverse.copy(source.matrixWorldInverse),
      this.projectionMatrix.copy(source.projectionMatrix),
      this
    );
  }
  updateMatrixWorld(force) {
    Base3D.prototype.updateMatrixWorld.call(this, force),
      this.matrixWorldInverse.getInverse(this.matrixWorld);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class CubeCamera extends Base3D {
  constructor(near = 0.1, far = 1e3, cubeResolution = 512) {
    super();
    (this.px = new PerspectiveCamera(90, 1, near, far)),
      this.px.up.set(0, -1, 0),
      this.px.lookAt(new Vector3(1, 0, 0)),
      this.add(this.px),
      (this.nx = new PerspectiveCamera(90, 1, near, far)),
      this.nx.up.set(0, -1, 0),
      this.nx.lookAt(new Vector3(-1, 0, 0)),
      this.add(this.nx),
      (this.py = new PerspectiveCamera(90, 1, near, far)),
      this.py.up.set(0, 0, 1),
      this.py.lookAt(new Vector3(0, 1, 0)),
      this.add(this.py),
      (this.ny = new PerspectiveCamera(90, 1, near, far)),
      this.ny.up.set(0, 0, -1),
      this.ny.lookAt(new Vector3(0, -1, 0)),
      this.add(this.ny),
      (this.pz = new PerspectiveCamera(90, 1, near, far)),
      this.pz.up.set(0, -1, 0),
      this.pz.lookAt(new Vector3(0, 0, 1)),
      this.add(this.pz),
      (this.nz = new PerspectiveCamera(90, 1, near, far)),
      this.nz.up.set(0, -1, 0),
      this.nz.lookAt(new Vector3(0, 0, -1)),
      this.add(this.nz),
      (this.rt = new CubeRenderTarget(cubeResolution, cubeResolution));
  }
  render(scene = World.SCENE, renderer = World.RENDERER) {
    let rt = this.rt;
    (rt.activeFace = 0),
      renderer.render(scene, this.px, rt),
      this.afterRender && this.afterRender(rt),
      (rt.activeFace = 1),
      renderer.render(scene, this.nx, rt),
      this.afterRender && this.afterRender(rt),
      (rt.activeFace = 2),
      renderer.render(scene, this.py, rt),
      this.afterRender && this.afterRender(rt),
      (rt.activeFace = 3),
      renderer.render(scene, this.ny, rt),
      this.afterRender && this.afterRender(rt),
      (rt.activeFace = 4),
      renderer.render(scene, this.pz, rt),
      this.afterRender && this.afterRender(rt),
      (rt.activeFace = 5),
      renderer.render(scene, this.nz, rt),
      this.afterRender && this.afterRender(rt);
  }
}
class OrthographicCamera extends CameraBase3D {
  constructor(left, right, top, bottom, near, far) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.zoom = 1),
      (this.left = left),
      (this.right = right),
      (this.top = top),
      (this.bottom = bottom),
      (this.near = void 0 !== near ? near : 0.1),
      (this.far = void 0 !== far ? far : 2e3),
      (this.position.z = 1),
      this.updateProjectionMatrix();
  }
  clone() {
    return new OrthographicCamera().copy(this);
  }
  copy(source, recursive) {
    return (
      CameraBase3D.prototype.copy.call(this, source, recursive),
      (this.left = source.left),
      (this.right = source.right),
      (this.top = source.top),
      (this.bottom = source.bottom),
      (this.near = source.near),
      (this.far = source.far),
      (this.zoom = source.zoom),
      (this.view =
        null === source.view ? null : Object.assign({}, source.view)),
      this
    );
  }
  updateProjectionMatrix() {
    let dx = (this.right - this.left) / (2 * this.zoom),
      dy = (this.top - this.bottom) / (2 * this.zoom),
      cx = (this.right + this.left) / 2,
      cy = (this.top + this.bottom) / 2,
      left = cx - dx,
      right = cx + dx,
      top = cy + dy,
      bottom = cy - dy;
    this.projectionMatrix.makeOrthographic(
      left,
      right,
      top,
      bottom,
      this.near,
      this.far
    );
  }
  setViewport(width, height) {
    (this.left = width / -2),
      (this.right = width / 2),
      (this.top = height / 2),
      (this.bottom = height / -2),
      this.updateProjectionMatrix();
  }
}
class PerspectiveCamera extends CameraBase3D {
  constructor(fov, aspect, near, far) {
    super(),
      (this.type = "PerspectiveCamera"),
      (this.fov = fov || 50),
      (this.zoom = 1),
      (this.near = near || 0.1),
      (this.far = far || 2e3),
      (this.focus = 10),
      (this.aspect = aspect || 1),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  clone() {
    return new PerspectiveCamera().copy(this);
  }
  copy(source, recursive) {
    return (
      CameraBase3D.prototype.copy.call(this, source, recursive),
      (this.fov = source.fov),
      (this.zoom = source.zoom),
      (this.near = source.near),
      (this.far = source.far),
      (this.focus = source.focus),
      (this.aspect = source.aspect),
      (this.filmGauge = source.filmGauge),
      (this.filmOffset = source.filmOffset),
      this
    );
  }
  setFocalLength(focalLength) {
    let vExtentSlope = (0.5 * this.getFilmHeight()) / focalLength;
    (this.fov = Math.degrees(2 * Math.atan(vExtentSlope))),
      this.updateProjectionMatrix();
  }
  getFocalLength() {
    let vExtentSlope = Math.tan(Math.radians(0.5 * this.fov));
    return (0.5 * this.getFilmHeight()) / vExtentSlope;
  }
  getEffectiveFOV() {
    return Math.degrees(
      2 * Math.atan(Math.tan(Math.radians(0.5 * this.fov)) / this.zoom)
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  updateProjectionMatrix() {
    let near = this.near,
      top = (near * Math.tan(Math.radians(0.5 * this.fov))) / this.zoom,
      height = 2 * top,
      width = this.aspect * height,
      left = -0.5 * width,
      skew = (this.view, this.filmOffset);
    0 !== skew && (left += (near * skew) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        left,
        left + width,
        top,
        top - height,
        near,
        this.far
      );
  }
}
class Geometry {
  constructor() {
    (this.attributes = {}),
      (this.drawRange = { start: 0, end: 0 }),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.index = null),
      (this.maxInstancedCount = void 0),
      (this.keepAlive = !1),
      (this.id = Utils.timestamp());
  }
  draw(mesh, shader) {
    Geometry.renderer.draw(this, mesh, shader);
  }
  upload(mesh, shader) {
    Geometry.renderer.upload(this, mesh, shader);
  }
  destroy(mesh) {
    this.keepAlive || Geometry.renderer.destroy(this, mesh);
  }
  addAttribute(name, attribute) {
    attribute.meshPerAttribute >= 1 &&
      ((this.isInstanced = !0), (this.maxInstancedCount = attribute.count)),
      (this.attributes[name] = attribute);
  }
  setIndex(attribute) {
    this.index = attribute.array || attribute;
  }
  toNonIndexed() {
    let geometry2 = new Geometry(),
      indices = this.index,
      attributes = this.attributes;
    for (let name in attributes) {
      let attribute = attributes[name],
        array = attribute.array,
        itemSize = attribute.itemSize,
        array2 = new array.constructor(indices.length * itemSize),
        index = 0,
        index2 = 0;
      for (let i = 0, l = indices.length; i < l; i++) {
        index = indices[i] * itemSize;
        for (let j = 0; j < itemSize; j++) array2[index2++] = array[index++];
      }
      geometry2.addAttribute(name, new GeometryAttribute(array2, itemSize));
    }
    return geometry2;
  }
  normalizeNormals() {
    let vector = this._V1 || new Vector3();
    this._V1 = vector;
    let x,
      y,
      z,
      normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++)
      (x = 3 * i + 0),
        (y = 3 * i + 1),
        (z = 3 * i + 2),
        (vector.x = normals.array[x]),
        (vector.y = normals.array[y]),
        (vector.z = normals.array[z]),
        vector.normalize(),
        (normals.array[x] = vector.x),
        (normals.array[y] = vector.y),
        (normals.array[z] = vector.z);
  }
  computeFaceNormals() {
    let cb = new Vector3(),
      ab = new Vector3();
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      let face = this.faces[f],
        vA = this.vertices[face.a],
        vB = this.vertices[face.b],
        vC = this.vertices[face.c];
      cb.subVectors(vC, vB),
        ab.subVectors(vA, vB),
        cb.cross(ab),
        cb.normalize(),
        face.normal.copy(cb);
    }
  }
  computeVertexNormals() {
    let index = this.index,
      attributes = this.attributes,
      groups = this.groups;
    if (attributes.position) {
      let positions = attributes.position.array;
      if (void 0 === attributes.normal)
        this.addAttribute(
          "normal",
          new BufferAttribute(new Float32Array(positions.length), 3)
        );
      else {
        let array = attributes.normal.array;
        for (let i = 0, il = array.length; i < il; i++) array[i] = 0;
      }
      let vA,
        vB,
        vC,
        normals = attributes.normal.array,
        pA = new Vector3(),
        pB = new Vector3(),
        pC = new Vector3(),
        cb = new Vector3(),
        ab = new Vector3();
      if (index) {
        let indices = index.array;
        0 === groups.length && this.addGroup(0, indices.length);
        for (let j = 0, jl = groups.length; j < jl; ++j) {
          let group = groups[j],
            start = group.start;
          for (let i = start, il = start + group.count; i < il; i += 3)
            (vA = 3 * indices[i + 0]),
              (vB = 3 * indices[i + 1]),
              (vC = 3 * indices[i + 2]),
              pA.fromArray(positions, vA),
              pB.fromArray(positions, vB),
              pC.fromArray(positions, vC),
              cb.subVectors(pC, pB),
              ab.subVectors(pA, pB),
              cb.cross(ab),
              (normals[vA] += cb.x),
              (normals[vA + 1] += cb.y),
              (normals[vA + 2] += cb.z),
              (normals[vB] += cb.x),
              (normals[vB + 1] += cb.y),
              (normals[vB + 2] += cb.z),
              (normals[vC] += cb.x),
              (normals[vC + 1] += cb.y),
              (normals[vC + 2] += cb.z);
        }
      } else
        for (let i = 0, il = positions.length; i < il; i += 9)
          pA.fromArray(positions, i),
            pB.fromArray(positions, i + 3),
            pC.fromArray(positions, i + 6),
            cb.subVectors(pC, pB),
            ab.subVectors(pA, pB),
            cb.cross(ab),
            (normals[i] = cb.x),
            (normals[i + 1] = cb.y),
            (normals[i + 2] = cb.z),
            (normals[i + 3] = cb.x),
            (normals[i + 4] = cb.y),
            (normals[i + 5] = cb.z),
            (normals[i + 6] = cb.x),
            (normals[i + 7] = cb.y),
            (normals[i + 8] = cb.z);
      this.normalizeNormals(), (attributes.normal.needsUpdate = !0);
    }
  }
  computeBoundingBox() {
    this.boundingBox || (this.boundingBox = new Box3());
    let position = this.attributes.position;
    position
      ? this.boundingBox.setFromBufferAttribute(position)
      : this.boundingBox.makeEmpty();
  }
  computeBoundingSphere() {
    let box = new Box3(),
      vector = new Vector3();
    this.boundingSphere || (this.boundingSphere = new Sphere());
    let position = this.attributes.position;
    if (position) {
      let center = this.boundingSphere.center;
      box.setFromBufferAttribute(position), box.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = position.count; i < il; i++)
        (vector.x = position.array[3 * i + 0]),
          (vector.y = position.array[3 * i + 1]),
          (vector.z = position.array[3 * i + 2]),
          (maxRadiusSq = Math.max(
            maxRadiusSq,
            center.distanceToSquared(vector)
          ));
      (this.boundingSphere.radius = Math.sqrt(maxRadiusSq)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            "Bounding Sphere came up NaN, broken position buffer.",
            this
          );
    }
  }
  merge(geometry) {
    let attributes = this.attributes;
    if (this.index) {
      let indices = geometry.index,
        offset = attributes.position.count;
      for (let i = 0, il = indices.length; i < il; i++)
        indices[i] = offset + indices[i];
      this.index = ((first, second) => {
        let firstLength = first.length,
          result = new Uint16Array(firstLength + second.length);
        return result.set(first), result.set(second, firstLength), result;
      })(this.index, indices);
    }
    for (let key in attributes)
      void 0 !== geometry.attributes[key] &&
        ((attributes[key].array = ((first, second) => {
          let firstLength = first.length,
            result = new Float32Array(firstLength + second.length);
          return result.set(first), result.set(second, firstLength), result;
        })(attributes[key].array, geometry.attributes[key].array)),
        (attributes[key].count =
          attributes[key].array.length / attributes[key].itemSize));
    return this;
  }
  clone() {
    return new Geometry().copy(this);
  }
  copy(source) {
    (this.index = null),
      (this.attributes = {}),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.index = source.index);
    let attributes = source.attributes;
    for (let name in attributes)
      this.addAttribute(name, attributes[name].clone());
    let boundingBox = source.boundingBox;
    boundingBox && (this.boundingBox = boundingBox.clone());
    let boundingSphere = source.boundingSphere;
    return (
      boundingSphere && (this.boundingSphere = boundingSphere.clone()), this
    );
  }
  center() {
    let offset = new Vector3();
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(offset).negate(),
      this.applyMatrix(
        new Matrix4().makeTranslation(offset.x, offset.y, offset.z)
      ),
      this
    );
  }
  applyMatrix(matrix) {
    let position = this.attributes.position;
    position &&
      (matrix.applyToBufferAttribute(position), (position.needsUpdate = !0));
    let normal = this.attributes.normal;
    return (
      normal &&
        (new Matrix3().getNormalMatrix(matrix).applyToBufferAttribute(normal),
        (normal.needsUpdate = !0)),
      this.boundingBox && this.computeBoundingBox(),
      this.boundingSphere && this.computeBoundingSphere(),
      this
    );
  }
  scale(x, y, z) {
    this.applyMatrix(new Matrix4().makeScale(x, y, z));
  }
  setFromPoints(points) {
    let position = [];
    for (let i = 0, l = points.length; i < l; i++) {
      let point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }
    return (
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(position), 3)
      ),
      this
    );
  }
  instanceFrom(geom) {
    geom.index && (geom = geom.toNonIndexed());
    for (let key in geom.attributes)
      this.addAttribute(key, geom.attributes[key]);
    return this;
  }
}
class GeometryAttribute {
  constructor(_array, _itemSize, _meshPerAttribute) {
    (this.array = _array),
      (this.itemSize = _itemSize),
      (this.count = void 0 !== _array ? _array.length / _itemSize : 0),
      (this.dynamic = !1),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.meshPerAttribute = _meshPerAttribute);
  }
  setArray(array) {
    (this.array = array),
      (this.count = void 0 !== array ? array.length / this.itemSize : 0),
      (this.needsUpdate = !0);
  }
  clone() {
    return new GeometryAttribute(
      new Float32Array(this.array),
      this.itemSize,
      this.meshPerAttribute
    );
  }
  getX(index) {
    return this.array[index * this.itemSize];
  }
  setX(index, x) {
    return (this.array[index * this.itemSize] = x), this;
  }
  getY(index) {
    return this.array[index * this.itemSize + 1];
  }
  setY(index, y) {
    return (this.array[index * this.itemSize + 1] = y), this;
  }
  getZ(index) {
    return this.array[index * this.itemSize + 2];
  }
  setZ(index, z) {
    return (this.array[index * this.itemSize + 2] = z), this;
  }
  getW(index) {
    return this.array[index * this.itemSize + 3];
  }
  setW(index, w) {
    return (this.array[index * this.itemSize + 3] = w), this;
  }
  setXY(index, x, y) {
    return (
      (index *= this.itemSize),
      (this.array[index + 0] = x),
      (this.array[index + 1] = y),
      this
    );
  }
  setXYZ(index, x, y, z) {
    return (
      (index *= this.itemSize),
      (this.array[index + 0] = x),
      (this.array[index + 1] = y),
      (this.array[index + 2] = z),
      this
    );
  }
  setXYZW(index, x, y, z, w) {
    return (
      (index *= this.itemSize),
      (this.array[index + 0] = x),
      (this.array[index + 1] = y),
      (this.array[index + 2] = z),
      (this.array[index + 3] = w),
      this
    );
  }
}
class Group extends Base3D {
  constructor() {
    super(), (this.isGroup = !0);
  }
}
class BaseLight extends Base3D {
  constructor(color = 16777215, intensity = 1, distance = 9999) {
    super(),
      (this.color = new Color(color)),
      (this.data = new Vector4()),
      (this.data2 = new Vector4()),
      (this.data3 = new Vector4()),
      (this.properties = new Vector4(intensity, distance, 0, 0));
  }
  destroy() {
    this.shadow &&
      (Lighting.removeFromShadowGroup(this), this.shadow.destroy());
  }
  prepareRender() {
    this.shadow.camera.position.copy(this.position),
      this.shadow.camera.lookAt(this.shadow.target);
  }
  set castShadow(bool) {
    (this.shadow || bool) &&
      (this.shadow || (this.shadow = new Shadow(this)),
      (this.shadow.enabled = bool),
      bool
        ? Lighting.addToShadowGroup(this)
        : Lighting.removeFromShadowGroup(this));
  }
  set intensity(v) {
    this.properties.x = v;
  }
  get intensity() {
    return this.properties.x;
  }
  set distance(v) {
    this.properties.y = v;
  }
  get distance() {
    return this.properties.y;
  }
  set bounce(v) {
    this.properties.z = v;
  }
  get bounce() {
    return this.properties.z;
  }
}
class Line extends Base3D {
  constructor(geometry, shader) {
    super(),
      (this.geometry = geometry),
      (this.shader = shader),
      (this.isLine = !0),
      (this.id = Renderer.ID++);
  }
  clone() {
    return new Line(this.geometry, this.shader).copy(this);
  }
}
class Mesh extends Base3D {
  constructor(geometry, shader = Utils3D.getTestShader()) {
    super(),
      (this._geometry = geometry),
      (this._shader = shader && shader.shader ? shader.shader : shader),
      (this.isMesh = !0),
      (this.id = Renderer.ID++);
  }
  clone() {
    return new Mesh(this._geometry, this.shader).copy(this);
  }
  set geometry(g) {
    Geometry.renderer.resetMeshGeom(this), (this._geometry = g);
  }
  get geometry() {
    return this._geometry;
  }
  set shader(shader) {
    this._shader = shader && shader.shader ? shader.shader : shader;
  }
  get shader() {
    return this._shader;
  }
}
class Points extends Base3D {
  constructor(geometry, shader) {
    super(),
      (this._geometry = geometry),
      (this.shader = shader),
      (this.isPoints = !0),
      (this.id = Renderer.ID++);
  }
  clone() {
    return new Points(this._geometry, this.shader).copy(this);
  }
  set geometry(g) {
    Geometry.renderer.resetMeshGeom(this), (this._geometry = g);
  }
  get geometry() {
    return this._geometry;
  }
}
class Scene extends Base3D {
  constructor() {
    super(),
      (this.autoUpdate = !0),
      (this.toRender = [[], []]),
      (this._displayNeedsUpdate = !0),
      (this.isScene = !0),
      (this.changes = []);
  }
  set displayNeedsUpdate(v) {
    !0 === v && this.changes.forEach((cb) => cb()),
      (this._displayNeedsUpdate = v);
  }
  get displayNeedsUpdate() {
    return this._displayNeedsUpdate;
  }
  bindSceneChange(cb) {
    this.changes.push(cb);
  }
}
Class(function FBORendererWebGL(_gl) {
  function prepareTexture(texture) {
    (texture._gl = _gl.createTexture()),
      _gl.bindTexture(_gl.TEXTURE_2D, texture._gl),
      _gl.texParameteri(
        _gl.TEXTURE_2D,
        _gl.TEXTURE_WRAP_S,
        getProperty(texture.wrapS)
      ),
      _gl.texParameteri(
        _gl.TEXTURE_2D,
        _gl.TEXTURE_WRAP_T,
        getProperty(texture.wrapT)
      ),
      _gl.texParameteri(
        _gl.TEXTURE_2D,
        _gl.TEXTURE_MAG_FILTER,
        getProperty(texture.magFilter)
      ),
      _gl.texParameteri(
        _gl.TEXTURE_2D,
        _gl.TEXTURE_MIN_FILTER,
        getProperty(texture.minFilter)
      ),
      (texture.needsUpdate = !1);
  }
  function texImageDB(rt, texture) {
    if (texture.type.includes("float")) {
      let {
        internalformat: internalformat,
        format: format,
        type: type,
      } = getFloatParams(texture);
      _gl.texImage2D(
        _gl.TEXTURE_2D,
        0,
        internalformat,
        rt.width,
        rt.height,
        0,
        format,
        type,
        null
      );
    } else _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(texture), rt.width, rt.height, 0, getFormat(texture), getType(texture), null);
    _gl.bindTexture(_gl.TEXTURE_2D, null);
  }
  function uploadCube(rt) {
    (rt._gl = _gl.createFramebuffer()),
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
    let texture = rt.texture;
    (texture._gl = _gl.createTexture()),
      (texture.cube = !0),
      _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);
    for (let i = 0; i < 6; i++)
      _gl.texImage2D(
        _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
        0,
        getFormat(texture),
        rt.width,
        rt.height,
        0,
        getFormat(texture),
        _gl.UNSIGNED_BYTE,
        null
      );
    _gl.texParameteri(
      _gl.TEXTURE_CUBE_MAP,
      _gl.TEXTURE_WRAP_S,
      getProperty(texture.wrapS)
    ),
      _gl.texParameteri(
        _gl.TEXTURE_CUBE_MAP,
        _gl.TEXTURE_WRAP_T,
        getProperty(texture.wrapT)
      ),
      _gl.texParameteri(
        _gl.TEXTURE_CUBE_MAP,
        _gl.TEXTURE_MAG_FILTER,
        getProperty(texture.magFilter)
      ),
      _gl.texParameteri(
        _gl.TEXTURE_CUBE_MAP,
        _gl.TEXTURE_MIN_FILTER,
        getProperty(texture.minFilter)
      ),
      (rt._depthBuffer = _gl.createRenderbuffer()),
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer),
      _gl.renderbufferStorage(
        _gl.RENDERBUFFER,
        _gl.DEPTH_COMPONENT16,
        rt.width,
        rt.height
      ),
      _gl.framebufferRenderbuffer(
        _gl.FRAMEBUFFER,
        _gl.DEPTH_ATTACHMENT,
        _gl.RENDERBUFFER,
        rt._depthBuffer
      ),
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, null),
      _gl.bindTexture(_gl.TEXTURE_2D, null),
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  const WEBGL2 = Renderer.type == Renderer.WEBGL2,
    {
      getFormat: getFormat,
      getProperty: getProperty,
      getType: getType,
      getFloatParams: getFloatParams,
    } = require("GLTypes");
  (this.upload = function (rt) {
    if (rt.cube) return uploadCube(rt);
    if (
      ((rt._gl = _gl.createFramebuffer()),
      rt.depth ||
        ((rt._depthBuffer = _gl.createRenderbuffer()),
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer),
        _gl.renderbufferStorage(
          _gl.RENDERBUFFER,
          _gl.DEPTH_COMPONENT16,
          rt.width,
          rt.height
        )),
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl),
      rt.multi)
    )
      if (WEBGL2) {
        let colorAttachments = [];
        for (let i = 0; i < rt.attachments.length; i++) {
          let key = "COLOR_ATTACHMENT" + i,
            texture = rt.attachments[i];
          colorAttachments.push(_gl[key]),
            prepareTexture(texture),
            texImageDB(rt, texture),
            _gl.framebufferTexture2D(
              _gl.FRAMEBUFFER,
              _gl[key],
              _gl.TEXTURE_2D,
              texture._gl,
              0
            );
        }
        _gl.drawBuffers(colorAttachments);
      } else {
        let ext = Renderer.extensions.drawBuffers,
          colorAttachments = [];
        for (let i = 0; i < rt.attachments.length; i++) {
          let key = "COLOR_ATTACHMENT" + i + "_WEBGL",
            texture = rt.attachments[i];
          colorAttachments.push(ext[key]),
            prepareTexture(texture),
            texImageDB(rt, texture),
            _gl.framebufferTexture2D(
              _gl.FRAMEBUFFER,
              ext[key],
              _gl.TEXTURE_2D,
              texture._gl,
              0
            );
        }
        ext.drawBuffersWEBGL(colorAttachments);
      }
    else {
      if ((prepareTexture(rt.texture), rt.texture.type.includes("float"))) {
        let {
          internalformat: internalformat,
          format: format,
          type: type,
        } = getFloatParams(rt.texture);
        _gl.texImage2D(
          _gl.TEXTURE_2D,
          0,
          internalformat,
          rt.width,
          rt.height,
          0,
          format,
          type,
          null
        );
      } else
        _gl.texImage2D(
          _gl.TEXTURE_2D,
          0,
          getFormat(rt.texture),
          rt.width,
          rt.height,
          0,
          getFormat(rt.texture),
          getType(rt.texture),
          null
        );
      _gl.framebufferTexture2D(
        _gl.FRAMEBUFFER,
        _gl.COLOR_ATTACHMENT0,
        _gl.TEXTURE_2D,
        rt.texture._gl,
        0
      );
    }
    if (rt.depth) {
      prepareTexture(rt.depth);
      let iformat = WEBGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT,
        type = WEBGL2 ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;
      _gl.texImage2D(
        _gl.TEXTURE_2D,
        0,
        iformat,
        rt.width,
        rt.height,
        0,
        _gl.DEPTH_COMPONENT,
        type,
        null
      ),
        _gl.framebufferTexture2D(
          _gl.FRAMEBUFFER,
          _gl.DEPTH_ATTACHMENT,
          _gl.TEXTURE_2D,
          rt.depth._gl,
          0
        );
    } else
      _gl.framebufferRenderbuffer(
        _gl.FRAMEBUFFER,
        _gl.DEPTH_ATTACHMENT,
        _gl.RENDERBUFFER,
        rt._depthBuffer
      );
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null),
      _gl.bindTexture(_gl.TEXTURE_2D, null),
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }),
    (this.bind = function (rt) {
      rt._gl || this.upload(rt),
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl),
        rt.cube &&
          _gl.framebufferTexture2D(
            _gl.FRAMEBUFFER,
            _gl.COLOR_ATTACHMENT0,
            _gl.TEXTURE_CUBE_MAP_POSITIVE_X + rt.activeFace,
            rt.texture._gl,
            0
          ),
        Renderer.overrideViewport ||
          _gl.viewport(rt.viewport.x, rt.viewport.y, rt.width, rt.height),
        Renderer.instance.autoClear &&
          (_gl.clearColor(
            Renderer.CLEAR[0],
            Renderer.CLEAR[1],
            Renderer.CLEAR[2],
            Renderer.CLEAR[3]
          ),
          _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT));
    }),
    (this.unbind = function () {
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }),
    (this.resize = function (rt) {
      if (rt.texture._gl && rt._gl) {
        if ((_gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl), rt.multi))
          for (let i = 0; i < rt.attachments.length; i++) {
            let texture = rt.attachments[i];
            _gl.bindTexture(_gl.TEXTURE_2D, texture._gl),
              _gl.texImage2D(
                _gl.TEXTURE_2D,
                0,
                getFormat(texture),
                rt.width,
                rt.height,
                0,
                getFormat(texture),
                getType(texture),
                null
              );
          }
        else if (
          (_gl.bindTexture(_gl.TEXTURE_2D, rt.texture._gl),
          rt.texture.type.includes("float"))
        ) {
          let {
            internalformat: internalformat,
            format: format,
            type: type,
          } = getFloatParams(rt.texture);
          _gl.texImage2D(
            _gl.TEXTURE_2D,
            0,
            internalformat,
            rt.width,
            rt.height,
            0,
            format,
            type,
            null
          );
        } else
          _gl.texImage2D(
            _gl.TEXTURE_2D,
            0,
            getFormat(rt.texture),
            rt.width,
            rt.height,
            0,
            getFormat(rt.texture),
            getType(rt.texture),
            null
          );
        if (rt.depth) {
          _gl.bindTexture(_gl.TEXTURE_2D, rt.depth._gl);
          let iformat = WEBGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT,
            type = WEBGL2 ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;
          _gl.texImage2D(
            _gl.TEXTURE_2D,
            0,
            iformat,
            rt.width,
            rt.height,
            0,
            _gl.DEPTH_COMPONENT,
            type,
            null
          ),
            _gl.framebufferTexture2D(
              _gl.FRAMEBUFFER,
              _gl.DEPTH_ATTACHMENT,
              _gl.TEXTURE_2D,
              rt.depth._gl,
              0
            );
        } else
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer),
            _gl.renderbufferStorage(
              _gl.RENDERBUFFER,
              _gl.DEPTH_COMPONENT16,
              rt.width,
              rt.height
            );
        _gl.bindTexture(_gl.TEXTURE_2D, null),
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, null),
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
      }
    }),
    (this.destroy = function (rt) {
      _gl.deleteFramebuffer(rt._gl),
        Texture.renderer.destroy(rt.texture),
        rt.multi && rt.attachments.forEach((t) => Texture.renderer.destroy(t)),
        (rt._gl = null);
    });
}),
  Class(function GeometryRendererWebGL(_gl) {
    function getMode(mesh, shader) {
      return mesh.isPoints
        ? _gl.POINTS
        : mesh.isLine
        ? _gl.LINES
        : shader.wireframe
        ? _gl.LINES
        : _gl.TRIANGLES;
    }
    function updateBuffer(attrib) {
      (attrib.needsUpdate = !1),
        _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer);
      let array = attrib.array,
        updateRange = attrib.updateRange;
      -1 === updateRange.count
        ? _gl.bufferSubData(_gl.ARRAY_BUFFER, 0, array)
        : _gl.bufferSubData(
            _gl.ARRAY_BUFFER,
            updateRange * offset * array.BYTES_PER_ELEMENT,
            array.subarray(
              updatRange.offset,
              updateRange.offset + updateRange.count
            )
          ),
        _gl.bindBuffer(_gl.ARRAY_BUFFER, null);
    }
    var _cache = {};
    const WEBGL2 = Renderer.type == Renderer.WEBGL2;
    (this.draw = function (geom, mesh, shader) {
      (geom._gl && !geom.needsUpdate && mesh._gl && mesh._gl.geomInit) ||
        this.upload(geom, mesh, shader);
      for (let key in geom.attributes) {
        let attrib = geom.attributes[key];
        const LOC = `${key}_loc`;
        mesh._gl.program != shader._gl.program
          ? ((mesh._gl[LOC] = _gl.getAttribLocation(shader._gl.program, key)),
            (mesh._gl.program = shader._gl.program))
          : void 0 === mesh._gl[LOC] &&
            (mesh._gl[LOC] = _gl.getAttribLocation(shader._gl.program, key)),
          -1 !== mesh._gl[LOC] &&
            (attrib.needsUpdate || attrib.dynamic) &&
            updateBuffer(attrib);
      }
      mesh._gl.vao.bind();
      let mode = getMode(mesh, shader),
        drawStart = geom.drawRange.start || 0,
        drawEnd = geom.drawRange.end || geom.attributes.position.count;
      geom.isInstanced
        ? WEBGL2
          ? geom.index
            ? _gl.drawElementsInstanced(
                mode,
                geom.index.length,
                _gl.UNSIGNED_SHORT,
                0,
                geom.maxInstancedCount
              )
            : _gl.drawArraysInstanced(
                mode,
                drawStart,
                drawEnd,
                geom.maxInstancedCount
              )
          : geom.index
          ? Renderer.extensions.instancedArrays.drawElementsInstancedANGLE(
              mode,
              geom.index.length,
              _gl.UNSIGNED_SHORT,
              0,
              geom.maxInstancedCount
            )
          : Renderer.extensions.instancedArrays.drawArraysInstancedANGLE(
              mode,
              0,
              drawEnd,
              geom.maxInstancedCount
            )
        : geom.index
        ? _gl.drawElements(mode, geom.index.length, _gl.UNSIGNED_SHORT, 0)
        : _gl.drawArrays(mode, drawStart, drawEnd),
        mesh._gl.vao.unbind();
    }),
      (this.upload = function (geom, mesh, shader) {
        geom._gl || (geom._gl = { id: Utils.timestamp() }),
          mesh._gl || (mesh._gl = {}),
          (mesh._gl.geomInit = !0);
        const KEY = `${geom._gl.id}_${shader._gl._id}`;
        let cached = _cache[KEY];
        if (cached)
          return (
            cached.count++,
            (mesh._gl.vao = cached.vao),
            void (mesh._gl.lookup = KEY)
          );
        mesh._gl.vao && mesh._gl.vao.destroy(), (mesh._gl.vao = new VAO(_gl));
        for (let key in geom.attributes) {
          let attrib = geom.attributes[key],
            location =
              mesh._gl[`${key}_loc`] ||
              _gl.getAttribLocation(shader._gl.program, key);
          (mesh._gl[`${key}_loc`] = location),
            attrib._gl ||
              ((attrib._gl = {}),
              (attrib._gl.buffer = _gl.createBuffer()),
              _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer),
              _gl.bufferData(
                _gl.ARRAY_BUFFER,
                attrib.array,
                attrib.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW
              ),
              _gl.bindBuffer(_gl.ARRAY_BUFFER, null),
              (attrib.needsUpdate = !1));
        }
        geom.index &&
          (geom._gl.index || (geom._gl.index = _gl.createBuffer()),
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index),
          _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, geom.index, _gl.STATIC_DRAW),
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, null)),
          mesh._gl.vao.bind();
        for (let key in geom.attributes) {
          let attrib = geom.attributes[key],
            location = mesh._gl[`${key}_loc`];
          -1 != location &&
            (_gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer),
            _gl.vertexAttribPointer(
              location,
              attrib.itemSize,
              _gl.FLOAT,
              !1,
              0,
              0
            ),
            _gl.enableVertexAttribArray(location),
            geom.isInstanced &&
              (WEBGL2
                ? _gl.vertexAttribDivisor(location, attrib.meshPerAttribute)
                : Renderer.extensions.instancedArrays.vertexAttribDivisorANGLE(
                    location,
                    attrib.meshPerAttribute
                  )));
        }
        geom.index && _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index),
          mesh._gl.vao.unbind(),
          (_cache[KEY] = { count: 1, vao: mesh._gl.vao });
      }),
      (this.destroy = function (geom, mesh) {
        for (let key in geom.attributes) {
          let attrib = geom.attributes[key];
          attrib._gl && _gl.deleteBuffer(attrib._gl.buffer);
        }
        if (mesh && mesh._gl && mesh._gl.vao) {
          let cache = _cache[mesh._gl.lookup];
          cache
            ? (cache.count--,
              0 == cache.count &&
                (cache.vao.destroy(), delete _cache[mesh._gl.lookup]))
            : mesh._gl.vao.destroy(),
            delete mesh._gl.vao;
        }
        delete geom._gl;
      }),
      (this.resetMeshGeom = function (mesh) {
        mesh._gl && (mesh._gl.geomInit = !1);
      });
  }),
  Class(function ShaderRendererWebGL(_gl) {
    function toTypedArray(uni) {
      uni.value;
      return (
        uni._gl || (uni._gl = {}),
        uni._gl.array && uni._gl.array.length == uni.value.length
          ? uni._gl.array.set(uni.value)
          : (uni._gl.array = new Float32Array(uni.value)),
        uni._gl.array
      );
    }
    function createShader(str, type) {
      let shader = _gl.createShader(type);
      if (
        (_gl.shaderSource(shader, str),
        _gl.compileShader(shader),
        Hydra.LOCAL && !_gl.getShaderParameter(shader, _gl.COMPILE_STATUS))
      ) {
        let error = _gl.getShaderInfoLog(shader);
        _gl.deleteShader(shader);
        let errorString = "";
        str.split("\n").forEach((line, index) => {
          (index = (function () {
            switch (index.toString().length) {
              case 1:
                return "00" + index;
              case 2:
                return "0" + index;
            }
            return index;
          })()),
            (errorString += `${index}: ${line}\n`);
        }),
          console.warn(error, errorString);
      }
      return shader;
    }
    function createProgram(shader) {
      let vsCode = shader.onBeforeCompile(shader.vertexShader, "vs"),
        fsCode = shader.onBeforeCompile(shader.fragmentShader, "fs"),
        vs = createShader(vsCode, _gl.VERTEX_SHADER),
        fs = createShader(fsCode, _gl.FRAGMENT_SHADER),
        program = _gl.createProgram();
      return (
        _gl.attachShader(program, vs),
        _gl.attachShader(program, fs),
        _gl.linkProgram(program),
        Hydra.LOCAL &&
          (_gl.getProgramParameter(program, _gl.LINK_STATUS) ||
            (console.warn(vsCode),
            console.warn(fsCode),
            console.error(
              `Could not compile WebGL program. ${shader.vsName} ${shader.fsName} \n\n` +
                _gl.getProgramInfoLog(program)
            ))),
        _gl.deleteShader(vs),
        _gl.deleteShader(fs),
        program
      );
    }
    function setupShaders(shader) {
      for (let key in shader.uniforms) {
        let uniform = shader.uniforms[key];
        if (void 0 === shader._gl[key])
          if (uniform.ubo)
            if (WEBGL2) {
              if (
                (_uboCache[shader.UILPrefix] &&
                  !shader.ubo &&
                  (shader.ubo = _uboCache[shader.UILPrefix]),
                _uboCache[shader.UILPrefix])
              ) {
                shader._gl[key] = "U";
                continue;
              }
              shader.ubo || (shader.ubo = new UBO(1, _gl)),
                shader.ubo.push(uniform),
                (shader._gl[key] = "U");
            } else
              shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key);
          else
            WEBGL2 && uniform.lightUBO
              ? ((shader._gl[key] = "U"), (shader.uboLight = !0))
              : (shader._gl[key] = _gl.getUniformLocation(
                  shader._gl.program,
                  key
                ));
      }
      shader.ubo &&
        !_uboCache[shader.UILPrefix] &&
        (_uboCache[shader.UILPrefix] = shader.ubo);
    }
    function findUniformType(uniform) {
      return "string" == typeof uniform.type
        ? uniform.type
        : null === uniform.value ||
          uniform.value instanceof Texture ||
          uniform.value.texture ||
          (uniform.value.rt && uniform.value.rt.texture)
        ? "t"
        : uniform.value instanceof Vector2
        ? "v2"
        : uniform.value instanceof Vector3
        ? "v3"
        : uniform.value instanceof Vector3D
        ? "v3"
        : uniform.value instanceof Vector4
        ? "v4"
        : uniform.value instanceof Matrix4
        ? "m4"
        : uniform.value instanceof Matrix3
        ? "m3"
        : uniform.value instanceof Color
        ? "c"
        : uniform.value instanceof Quaternion
        ? "q"
        : Array.isArray(uniform.value) && uniform.value[0] instanceof Texture
        ? "tv"
        : "f";
    }
    function uniformTextureArray(uni, uLoc, shader) {
      let array = shader._gl.texArray || [];
      (array.length = 0), (shader._gl.texArray = array);
      for (let i = 0; i < uni.value.length; i++) {
        array.push(shader._gl.texIndex);
        let texture = uni.value[i];
        !1 === texture.loaded && (texture = Utils3D.getEmptyTexture()),
          (void 0 === texture._gl || texture.needsReupload) &&
            Texture.renderer.upload(texture),
          _gl.activeTexture(_gl[`TEXTURE${shader._gl.texIndex++}`]),
          _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);
      }
      _gl.uniform1iv(uLoc, array);
    }
    var _pool = {},
      _programID = 0,
      _cached = {},
      _uboCache = {};
    const WEBGL2 = Renderer.type == Renderer.WEBGL2;
    (this.upload = function (shader) {
      if (!shader._gl) {
        shader._gl = {};
        let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`,
          cached = _pool[key];
        cached
          ? ((shader._gl.program = cached.program),
            (shader._gl._id = cached.id),
            cached.count++)
          : ((shader._gl.program = createProgram(shader)),
            (shader._gl._id = _programID++),
            (_pool[key] = {
              count: 1,
              program: shader._gl.program,
              id: shader._gl._id,
            }));
      }
      setupShaders(shader), shader.ubo && shader.ubo.upload();
    }),
      (this.findCachedProgram = function (shader) {
        let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`,
          cached = _pool[key];
        return (
          !!cached &&
          ((shader._gl = {}),
          (shader._gl.program = cached.program),
          (shader._gl._id = cached.id),
          _uboCache[shader.UILPrefix] && (shader.ubo = shader.UILPrefix),
          cached.count++,
          !0)
        );
      }),
      (this.draw = function (shader) {
        void 0 === shader._gl && this.upload(shader),
          (shader._gl.texIndex = 0),
          shader._gl.program != _cached.program &&
            (_gl.useProgram(shader._gl.program),
            (_cached.program = shader._gl.program)),
          shader.ubo && shader.ubo.bind(shader._gl.program, "ubo"),
          shader.uboLight && Lighting.bindUBO(shader._gl.program);
        for (let key in shader.uniforms) {
          let uni = shader.uniforms[key];
          void 0 === shader._gl[key] && setupShaders(shader);
          let uLoc = shader._gl[key];
          if (
            (null === uni.value && (uni.value = Utils3D.getEmptyTexture()),
            null !== uLoc && -1 !== uLoc && "U" !== uLoc)
          ) {
            if (void 0 === uni.value)
              throw `Uniform ${key} value is undefined. | ${shader.vsName} ${shader.fsName}`;
            switch ((uni.type || (uni.type = findUniformType(uni)), uni.type)) {
              case "f":
                _gl.uniform1f(uLoc, uni.value);
                break;
              case "v2":
                _gl.uniform2f(uLoc, uni.value.x, uni.value.y);
                break;
              case "v3":
                _gl.uniform3f(uLoc, uni.value.x, uni.value.y, uni.value.z);
                break;
              case "c":
                _gl.uniform3f(uLoc, uni.value.r, uni.value.g, uni.value.b);
                break;
              case "q":
              case "v4":
                _gl.uniform4f(
                  uLoc,
                  uni.value.x,
                  uni.value.y,
                  uni.value.z,
                  uni.value.w
                );
                break;
              case "v3v":
                _gl.uniform3fv(uLoc, toTypedArray(uni));
                break;
              case "v4v":
                _gl.uniform4fv(uLoc, toTypedArray(uni));
                break;
              case "v2v":
                _gl.uniform2fv(uLoc, toTypedArray(uni));
                break;
              case "fv":
                _gl.uniform1fv(uLoc, toTypedArray(uni));
                break;
              case "m4":
                _gl.uniformMatrix4fv(uLoc, !1, uni.value.elements);
                break;
              case "m3":
                _gl.uniformMatrix3fv(uLoc, !1, uni.value.elements);
                break;
              case "tv":
                uniformTextureArray(uni, uLoc, shader);
                break;
              case "t":
                let texture = uni.value;
                texture.isTexture ||
                  (uni.value.rt &&
                    (texture =
                      uni.value.rt.overrideTexture || uni.value.rt.texture),
                  uni.value.texture && (texture = uni.value.texture)),
                  !1 === texture.loaded &&
                    (texture = Utils3D.getEmptyTexture()),
                  Texture.renderer.draw(
                    texture,
                    uLoc,
                    key,
                    shader._gl.texIndex++
                  );
            }
          }
        }
        if (shader.polygonOffset) {
          let key =
            shader.polygonOffsetFactor + "_" + shader.polygonOffsetUnits;
          _cached.polygonOffset != key &&
            (_gl.enable(_gl.POLYGON_OFFSET_FILL),
            _gl.polygonOffset(
              shader.polygonOffsetFactor,
              shader.polygonOffsetUnits
            )),
            (_cached.polygonOffset = key);
        } else
          _cached.polygonOffset && _gl.disable(_gl.POLYGON_OFFSET_FILL),
            (_cached.polygonOffset = !1);
        if (
          (shader.transparent
            ? (_cached.transparent || _gl.enable(_gl.BLEND),
              (_cached.transparent = !0))
            : (_cached.transparent && _gl.disable(_gl.BLEND),
              (_cached.transparent = !1)),
          _cached.blending != shader.blending)
        ) {
          switch (shader.blending) {
            case Shader.ADDITIVE_BLENDING:
              _gl.blendEquation(_gl.FUNC_ADD),
                _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE);
              break;
            default:
              _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD),
                _gl.blendFuncSeparate(
                  _gl.SRC_ALPHA,
                  _gl.ONE_MINUS_SRC_ALPHA,
                  _gl.ONE,
                  _gl.ONE_MINUS_SRC_ALPHA
                );
          }
          _cached.blending = shader.blending;
        }
        switch (
          (shader.depthTest
            ? (_cached.depthTest || _gl.enable(_gl.DEPTH_TEST),
              (_cached.depthTest = !0))
            : (_cached.depthTest && _gl.disable(_gl.DEPTH_TEST),
              (_cached.depthTest = !1)),
          shader.side)
        ) {
          case Shader.BACK_SIDE:
            _cached.side != Shader.BACK_SIDE &&
              (_gl.enable(_gl.CULL_FACE),
              _gl.cullFace(_gl.FRONT),
              (_cached.side = Shader.BACK_SIDE));
            break;
          case Shader.DOUBLE_SIDE:
            _cached.side != Shader.DOUBLE_SIDE &&
              (_gl.disable(_gl.CULL_FACE), (_cached.side = Shader.DOUBLE_SIDE));
            break;
          default:
            _cached.side != Shader.FRONT_SIDE &&
              (_gl.enable(_gl.CULL_FACE),
              _gl.cullFace(_gl.BACK),
              (_cached.side = Shader.FRONT_SIDE));
        }
        switch (
          (_cached.depthMask != shader.depthWrite &&
            (_gl.depthMask(!!shader.depthWrite),
            (_cached.depthMask = shader.depthWrite)),
          shader.colorMask)
        ) {
          case Shader.COLOR_MASK_NONE:
            _cached.colorMask != shader.colorMask &&
              (_gl.colorMask(!0, !0, !0, !0),
              (_cached.colorMask = shader.colorMask));
            break;
          case Shader.COLOR_MASK_RGB:
            _cached.colorMask != shader.colorMask &&
              (_gl.colorMask(!1, !1, !1, !0),
              (_cached.colorMask = shader.colorMask));
            break;
          case Shader.COLOR_MASK_RGBA:
            _cached.colorMask != shader.colorMask &&
              (_gl.colorMask(!1, !1, !1, !1),
              (_cached.colorMask = shader.colorMask));
        }
      }),
      (this.destroy = function (shader) {
        shader.ubo && shader.ubo.destroy();
        let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`,
          cached = _pool[key];
        cached &&
          !ShaderRendererWebGL.persistPrograms &&
          0 == --cached.count &&
          _gl.deleteProgram(cached.program),
          (shader._gl = void 0);
      }),
      (this.appendUniform = function (shader, key, value, hint) {
        if (
          (void 0 === shader._gl[key] &&
            (shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key)),
          null !== shader._gl[key])
        )
          if (value instanceof Matrix4)
            _gl.uniformMatrix4fv(shader._gl[key], !1, value.elements);
          else if (value instanceof Matrix3)
            _gl.uniformMatrix3fv(shader._gl[key], !1, value.elements);
          else if (value instanceof Vector3)
            _gl.uniform3f(shader._gl[key], value.x, value.y, value.z);
          else if (value instanceof Vector2)
            _gl.uniform2f(shader._gl[key], value.x, value.y);
          else if (value instanceof Float32Array)
            switch (hint) {
              case "matrix":
                _gl.uniformMatrix4fv(shader._gl[key], !1, value);
                break;
              case "float":
                _gl.uniform1fv(shader._gl[key], value);
                break;
              case "vec3":
                _gl.uniform3fv(shader._gl[key], value);
            }
          else if (Array.isArray(value)) {
            let array = shader._gl.texArray || [];
            (array.length = 0), (shader._gl.texArray = array);
            for (let i = 0; i < value.length; i++)
              array.push(shader._gl.texIndex),
                _gl.activeTexture(_gl[`TEXTURE${shader._gl.texIndex++}`]),
                _gl.bindTexture(_gl.TEXTURE_2D, value[i]._gl);
            _gl.uniform1iv(shader._gl[key], array);
          } else _gl.uniform1f(shader._gl[key], value);
      }),
      (this.resetState = function () {
        _cached.depthMask || (_gl.depthMask(!0), (_cached.depthMask = !0)),
          _cached.depthTest || _gl.enable(_gl.DEPTH_TEST),
          (_cached.depthTest = !0),
          _cached.colorMask != Shader.COLOR_MASK_NONE &&
            (_gl.colorMask(!0, !0, !0, !0),
            (_cached.colorMask = Shader.COLOR_MASK_NONE)),
          (_cached.program = null);
      }),
      (this.clearState = function () {
        _cached = {};
      });
  }),
  Class(function TextureRendererWebGL(_gl) {
    function uploadCube(texture) {
      void 0 === texture._gl &&
        ((texture._gl = _gl.createTexture()),
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl),
        _state.flipY ||
          (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0), (_state.flipY = !0)),
        setTextureParams(texture, _gl.TEXTURE_CUBE_MAP));
      let format = getFormat(texture);
      for (let i = 0; i < 6; i++)
        _gl.texImage2D(
          _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
          0,
          format,
          format,
          getType(texture),
          texture.cube[i]
        );
      _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP),
        (texture.needsUpdate = texture.needsReupload = !1),
        texture.onUpdate && texture.onUpdate();
    }
    function setTextureParams(texture, textureType = _gl.TEXTURE_2D) {
      let format = getFormat(texture);
      textureType != _gl.TEXTURE_2D ||
        texture.compressed ||
        _gl.texImage2D(
          textureType,
          0,
          format,
          1,
          1,
          0,
          format,
          _gl.UNSIGNED_BYTE,
          DATA
        ),
        _gl.texParameteri(
          textureType,
          _gl.TEXTURE_WRAP_S,
          getProperty(texture.wrapS)
        ),
        _gl.texParameteri(
          textureType,
          _gl.TEXTURE_WRAP_T,
          getProperty(texture.wrapT)
        ),
        _gl.texParameteri(
          textureType,
          _gl.TEXTURE_MAG_FILTER,
          getProperty(texture.magFilter)
        ),
        _gl.texParameteri(
          textureType,
          _gl.TEXTURE_MIN_FILTER,
          getProperty(texture.minFilter)
        ),
        texture.data || texture.format != Texture.RGBAFormat
          ? 1 == _state.premultiply &&
            (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            (_state.premultiply = !1))
          : !1 === texture.premultiplyAlpha
          ? (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            (_state.premultiply = !1))
          : (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0),
            (_state.premultiply = !0)),
        texture.anisotropy > 1 &&
          _gl.texParameterf(
            _gl.TEXTURE_2D,
            Renderer.extensions.anisotropy.TEXTURE_MAX_ANISOTROPY_EXT,
            texture.anisotropy
          );
    }
    function updateDynamic(texture) {
      if (texture.type.includes("float")) {
        _state.flipY &&
          (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !1), (_state.flipY = !1)),
          _state.premultiply &&
            (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            (_state.premultiply = !1));
        let { format: format, type: type } = getFloatParams(texture);
        _gl.texSubImage2D(
          _gl.TEXTURE_2D,
          0,
          0,
          0,
          texture.width,
          texture.height,
          format,
          type,
          texture.data
        );
      } else {
        _state.flipY ||
          (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0), (_state.flipY = !0)),
          texture.format == Texture.RGBAFormat
            ? !1 === texture.premultiplyAlpha
              ? (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                (_state.premultiply = !1))
              : (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0),
                (_state.premultiply = !0))
            : _state.premultiply &&
              (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
              (_state.premultiply = !1));
        let format = getFormat(texture);
        _gl.texImage2D(
          _gl.TEXTURE_2D,
          0,
          format,
          format,
          getType(texture),
          texture.image
        );
      }
    }
    var _state = {};
    const DATA = new Uint8Array([0, 0, 0, 0]),
      {
        getFormat: getFormat,
        getProperty: getProperty,
        getType: getType,
        getFloatParams: getFloatParams,
      } = require("GLTypes");
    (this.draw = function (texture, loc, key, id) {
      if (
        ((void 0 === texture._gl || texture.needsReupload) &&
          this.upload(texture),
        _gl.activeTexture(_gl[`TEXTURE${id}`]),
        texture.cube)
      )
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);
      else {
        let texType = texture.EXT_OES
          ? _gl.TEXTURE_EXTERNAL_OES
          : _gl.TEXTURE_2D;
        _gl.bindTexture(texType, texture._gl);
      }
      _gl.uniform1i(loc, id),
        (texture.dynamic || texture.needsUpdate) && updateDynamic(texture),
        (texture.needsUpdate = !1);
    }),
      (this.upload = function (texture) {
        let format = getFormat(texture);
        if (texture.cube) {
          if (6 != texture.cube.length) throw "Cube texture requires 6 images";
          return uploadCube(texture);
        }
        let texType = texture.EXT_OES
          ? _gl.TEXTURE_EXTERNAL_OES
          : _gl.TEXTURE_2D;
        if (
          (void 0 === texture._gl
            ? ((texture._gl = _gl.createTexture()),
              _gl.bindTexture(texType, texture._gl),
              setTextureParams(texture, texType))
            : _gl.bindTexture(texType, texture._gl),
          texture.type.includes("float"))
        ) {
          _state.flipY &&
            (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !1), (_state.flipY = !1)),
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, 1);
          let {
            internalformat: internalformat,
            format: format,
            type: type,
          } = getFloatParams(texture);
          _gl.texImage2D(
            _gl.TEXTURE_2D,
            0,
            internalformat,
            texture.width,
            texture.height,
            0,
            format,
            type,
            texture.data
          );
        } else if (
          (_state.flipY ||
            (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0), (_state.flipY = !0)),
          texture.image && texture.compressed)
        ) {
          let data = texture.image.compressedData;
          for (let i = 0; i < data.length; i++) {
            let size = texture.image.sizes[i];
            _gl.compressedTexImage2D(
              _gl.TEXTURE_2D,
              i,
              texture.image.gliFormat,
              size,
              size,
              0,
              data[i]
            );
          }
          data.length = 0;
        } else
          texture.image &&
            (texture.image instanceof HTMLVideoElement ||
              _gl.texImage2D(
                _gl.TEXTURE_2D,
                0,
                format,
                format,
                getType(texture),
                texture.image
              ));
        (texture.image || texture.data) &&
          texture.generateMipmaps &&
          !texture.compressed &&
          _gl.generateMipmap(_gl.TEXTURE_2D),
          (texture.needsUpdate = texture.needsReupload = !1),
          texture.onUpdate && texture.onUpdate();
      }),
      (this.destroy = function (texture) {
        texture._gl && _gl.deleteTexture(texture._gl), delete texture._gl;
      });
  });
class RenderTarget {
  constructor(width, height, options = {}) {
    (this.width = width),
      (this.height = height),
      (this.viewport = new Vector2(0, 0)),
      void 0 === options.minFilter && (options.minFilter = Texture.LINEAR),
      (this.texture = new Texture(null)),
      (this.texture.generateMipmaps = options.generateMipmaps),
      (this.texture.width = width),
      (this.texture.height = height),
      (this.texture.minFilter = options.minFilter || Texture.LINEAR),
      (this.texture.magFilter = options.magFilter || Texture.LINEAR),
      (this.texture.wrapS = options.wrapS || Texture.CLAMP_TO_EDGE),
      (this.texture.wrapT = options.wrapT || Texture.CLAMP_TO_EDGE),
      (this.texture.format = options.format || Texture.RGBFormat),
      options.type && (this.texture.type = options.type),
      (this.isRT = !0);
  }
  setSize(width, height) {
    (this.width = width),
      (this.height = height),
      (this.texture.width = width),
      (this.texture.height = height),
      this.viewport.set(0, 0),
      RenderTarget.renderer.resize(this);
  }
  clone() {
    return new RenderTarget().copy(this);
  }
  copy(source) {
    return (
      (this.width = source.width),
      (this.height = source.height),
      this.viewport.copy(source.viewport),
      (this.texture = source.texture.clone()),
      this
    );
  }
  createDepthTexture() {
    return (
      (this.depth = new Texture(null)),
      (this.depth.generateMipmaps = !1),
      (this.depth.minFilter = Texture.NEAREST),
      (this.depth.magFilter = Texture.NEAREST),
      (this.depth.wrapS = Texture.CLAMP_TO_EDGE),
      (this.depth.wrapT = Texture.CLAMP_TO_EDGE),
      this.depth
    );
  }
  destroy() {
    RenderTarget.renderer.destroy(this);
  }
  upload() {
    this._gl || RenderTarget.renderer.upload(this);
  }
}
class MultiRenderTarget extends RenderTarget {
  constructor(width, height, options = {}) {
    super(width, height, options),
      (this.multi = !0),
      (this.attachments = [this.texture]);
  }
}
class CubeRenderTarget extends RenderTarget {
  constructor(width, height, options = {}) {
    super(width, height, options), (this.activeFace = 0), (this.cube = !0);
  }
}
Class(
  function Shader(
    _vertexShader,
    _fragmentShader,
    _params,
    _onBeforeBuild,
    _postfix
  ) {
    const _this = this;
    (this.uniforms = {}),
      (this.side = Shader.FRONT_SIDE),
      (this.blending = Shader.NORMAL_BLENDING),
      (this.colorMask = Shader.COLOR_MASK_NONE),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 1),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.wireframe = !1),
      (this.transparent = !1),
      (this.visible = !0),
      (this.persists = !1),
      (this.precision = "high"),
      (this.customCompile = ""),
      "string" != typeof _fragmentShader &&
        ((_params = _fragmentShader), (_fragmentShader = _vertexShader)),
      (_params = _params || {}),
      (_this.vsParam = _vertexShader),
      (_this.fsParam = _fragmentShader),
      (_this.params = _params),
      (_this.vsName = _vertexShader),
      (_this.fsName = (_fragmentShader || _vertexShader) + (_postfix || "")),
      _params.vsName &&
        ((_this.vsName = _params.vsName), delete _params.vsName),
      _params.precision && (_this.precision = _params.precision),
      _params.receiveShadow &&
        ((_this.receiveLight = !0),
        World.RENDERER.shadows && (_this.precision = "high"));
    let vs = _vertexShader,
      fs = _fragmentShader;
    _params.uilFrom &&
      ((vs = _params.uilFrom), (fs = _params.uilFrom), delete _params.uilFrom),
      Shader.parseParams(_params, _this),
      (_this.UILPrefix =
        _params.UILPrefix ||
        `${vs}/${fs}/${_params.unique ? _params.unique + "/" : ""}`),
      Shader.renderer.findCachedProgram(_this) ||
        ((_this.vertexShader = Shader.process(
          Shaders.getShader(_vertexShader + ".vs"),
          "vs",
          _this,
          _onBeforeBuild
        )),
        (_this.fragmentShader = Shader.process(
          Shaders.getShader(_fragmentShader + ".fs"),
          "fs",
          _this,
          _onBeforeBuild
        )));
  },
  (_) => {
    function getLightingCode(_this) {
      if (!_this.receiveLight) return "";
      let lighting = Lighting.getLighting(_this),
        numLights = lighting.position.length / 4;
      if (0 == numLights) return "";
      let lightUBO = Lighting.UBO;
      return (
        (_this.uniforms.lightPos = {
          type: "v4v",
          value: lighting.position,
          ignoreUIL: !0,
          lightUBO: lightUBO,
          components: 4,
        }),
        (_this.uniforms.lightColor = {
          type: "v4v",
          value: lighting.color,
          ignoreUIL: !0,
          lightUBO: lightUBO,
          components: 4,
        }),
        (_this.uniforms.lightData = {
          type: "v4v",
          value: lighting.data,
          ignoreUIL: !0,
          lightUBO: lightUBO,
          components: 4,
        }),
        (_this.uniforms.lightData2 = {
          type: "v4v",
          value: lighting.data2,
          ignoreUIL: !0,
          lightUBO: lightUBO,
          components: 4,
        }),
        (_this.uniforms.lightData3 = {
          type: "v4v",
          value: lighting.data3,
          ignoreUIL: !0,
          lightUBO: lightUBO,
          components: 4,
        }),
        (_this.uniforms.lightProperties = {
          type: "v4v",
          value: lighting.properties,
          ignoreUIL: !0,
          lightUBO: lightUBO,
          components: 4,
        }),
        [
          `#define NUM_LIGHTS ${numLights}`,
          "uniform lights {",
          `vec4 lightPos[${numLights}];`,
          `vec4 lightColor[${numLights}];`,
          `vec4 lightData[${numLights}];`,
          `vec4 lightData2[${numLights}];`,
          `vec4 lightData3[${numLights}];`,
          `vec4 lightProperties[${numLights}];`,
          "};",
        ].join("\n") + Lighting.getShadowUniforms()
      );
    }
    (Shader.FRONT_SIDE = "shader_front_side"),
      (Shader.BACK_SIDE = "shader_back_side"),
      (Shader.DOUBLE_SIDE = "shader_double_side"),
      (Shader.ADDITIVE_BLENDING = "shader_additive_blending"),
      (Shader.NORMAL_BLENDING = "shader_normal_blending"),
      (Shader.CUSTOM_DEPTH = "shader_custom_depth"),
      (Shader.COLOR_MASK_RGB = "shader_colormask_rgb"),
      (Shader.COLOR_MASK_RGBA = "shader_colormask_rgba"),
      (Shader.COLOR_MASK_NONE = "shader_colormask_none"),
      (Shader.parseParams = function (_params, _this) {
        for (let key in _params)
          if ("receiveShadow" == key) _this.receiveShadow = _params[key];
          else if ("receiveLight" == key) _this.receiveLight = _params[key];
          else if (_params[key] && void 0 !== _params[key].value)
            window.UILStorage
              ? ((_this.uniforms[key] =
                  UILStorage.parse(_this.UILPrefix + key, _params[key].value) ||
                  _params[key]),
                _params[key].ubo && (_this.uniforms[key].ubo = !0))
              : (_this.uniforms[key] = _params[key]);
          else {
            if ("unique" == key) continue;
            _this[key] = _params[key];
          }
      }),
      (Shader.process = function (code, type, _this, _onBeforeBuild) {
        const WEBGL2 = Renderer.type == Renderer.WEBGL2;
        if (!code)
          throw "No shader found! " + _this.vsName + " | " + _this.fsName;
        const externalOES =
            code.includes("samplerOES") &&
            window.AURA &&
            "android" == Device.system.os,
          standardDeriv = !WEBGL2 && code.includes(["fwidth", "dFdx"]),
          drawBuffers =
            !WEBGL2 &&
            code.includes(["gl_FragData", "#drawbuffer"]) &&
            window.World &&
            World.NUKE.useDrawBuffers;
        return (
          (header =
            "vs" == type
              ? [
                  "#version 300 es",
                  `precision ${_this.precision}p float;`,
                  `precision ${_this.precision}p int;`,
                  "attribute vec2 uv;",
                  "attribute vec3 position;",
                  "attribute vec3 normal;",
                  "uniform mat3 normalMatrix;",
                  "uniform mat4 modelMatrix;",
                  "uniform mat4 modelViewMatrix;",
                  "uniform global {",
                  "mat4 projectionMatrix;",
                  "mat4 viewMatrix;",
                  "vec3 cameraPosition;",
                  "vec2 resolution;",
                  "float time;",
                  "};",
                ].join("\n")
              : [
                  "#version 300 es",
                  externalOES
                    ? "#extension GL_OES_EGL_image_external_essl3 : require"
                    : "",
                  standardDeriv
                    ? "#extension GL_OES_standard_derivatives : enable"
                    : "",
                  drawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
                  `precision ${_this.precision}p float;`,
                  `precision ${_this.precision}p int;`,
                  "uniform mat3 normalMatrix;",
                  "uniform mat4 modelMatrix;",
                  "uniform mat4 modelViewMatrix;",
                  "uniform global {",
                  "mat4 projectionMatrix;",
                  "mat4 viewMatrix;",
                  "vec3 cameraPosition;",
                  "vec2 resolution;",
                  "float time;",
                  "};",
                  "out vec4 FragColor;",
                ].join("\n")),
          (header += "\n__ACTIVE_THEORY_LIGHTS__\n\n"),
          window.AURA && (header += "#define AURA\n"),
          _onBeforeBuild && (code = _onBeforeBuild(code, type)),
          (code = header + code)
        );
      });
    const prototype = Shader.prototype;
    (prototype.copyUniformsTo = function (shader, linked) {
      for (let key in this.uniforms)
        shader.uniforms[key] = linked
          ? this.uniforms[key]
          : { type: this.uniforms[key].type, value: this.uniforms[key].value };
    }),
      (prototype.addUniforms = function (uniforms) {
        uniforms.UILPrefix &&
          ((this.UILPrefix = uniforms.UILPrefix), delete uniforms.UILPrefix);
        for (let key in uniforms) this.uniforms[key] = uniforms[key];
      }),
      (prototype.draw = function (mesh, geom) {
        Shader.renderer.draw(this, mesh, geom);
      }),
      (prototype.upload = function (mesh, geom) {
        Shader.renderer.upload(this, mesh, geom),
          this.receiveShadow &&
            !this.shadow &&
            Lighting.initShadowShader(this, mesh);
      }),
      (prototype.destroy = function () {
        this.persists ||
          (Shader.renderer.destroy(this), this.shadow && this.shadow.destroy()),
          this.receiveLight && Lighting.destroyShader(this);
      }),
      (prototype.onBeforeCompile = function (code, type) {
        const WEBGL2 = Renderer.type == Renderer.WEBGL2;
        if (
          (this.receiveShadow && (this.receiveLight = !0),
          "fs" == type &&
            (WEBGL2
              ? code.includes("gl_FragColor") &&
                (code = code.replace(/gl_FragColor/g, "FragColor"))
              : code.includes("#applyShadow") &&
                (code = code.replace("#applyShadow", "")),
            code.includes("#drawbuffer Color")))
        )
          for (
            code = code.replace("#drawbuffer Color", "");
            code.includes("#drawbuffer");

          ) {
            let pre = code.split("#drawbuffer"),
              post = pre[1].split("\n");
            code = pre[0] + post[1];
          }
        (code = code.replace(
          "__ACTIVE_THEORY_LIGHTS__",
          getLightingCode(this)
        )),
          "fs" == type &&
            code.includes("SHADOW_MAPS") &&
            (code = require("GLSLOptimizer")(
              code.replace("SHADOW_COUNT", Lighting.getShadowCount(this))
            )),
          this.preCompile && (code = this.preCompile(code, type));
        let converter = require("ShaderCode");
        return (code = WEBGL2
          ? converter.convertWebGL2(code, type)
          : converter.convertWebGL1(code));
      }),
      (prototype.set = function (key, value, ref) {
        let _this = ref || this;
        return (
          void 0 !== value &&
            (TweenManager.clearTween(_this.uniforms[key]),
            (_this.uniforms[key].value = value)),
          _this.uniforms[key].value
        );
      }),
      (prototype.get = function (key, ref) {
        return (ref || this).uniforms[key].value;
      }),
      (prototype.tween = function (
        key,
        value,
        time,
        ease,
        delay,
        callback,
        update
      ) {
        return tween(
          this.uniforms[key],
          { value: value },
          time,
          ease,
          delay,
          callback,
          update
        );
      }),
      (prototype.clone = function (noShadows, postfix) {
        const _this = this;
        noShadows && (_this.params.receiveShadow = !1);
        let shader = new Shader(
          _this.vsParam,
          _this.fsParam,
          _this.params,
          null,
          postfix
        );
        for (let key in _this)
          key.includes(["vsName", "fsName", "uniforms"]) ||
            "function" == typeof _this[key] ||
            (shader[key] = _this[key]);
        for (let key in _this.uniforms)
          shader.uniforms[key] = {
            type: _this.uniforms[key].type,
            value: _this.uniforms[key].value,
          };
        return shader;
      });
  }
);
class Texture {
  constructor(img) {
    (this.magFilter = Texture.LINEAR),
      (this.minFilter = Texture.LINEAR_MIPMAP),
      (this.format = Texture.RGBAFormat),
      (this.wrapS = this.wrapT = Texture.CLAMP_TO_EDGE),
      (this._image = img),
      (this.needsUpdate = !0),
      (this.generateMipmaps = !0),
      (this.anisotropy = 1),
      (this.type = Texture.UNSIGNED_BYTE),
      (this.isTexture = !0),
      img && img.onCreateTexture && img.onCreateTexture(this);
  }
  set image(img) {
    (this._image = img),
      img && img.onCreateTexture && img.onCreateTexture(this);
  }
  get image() {
    return this._image;
  }
  upload() {
    this._gl || Texture.renderer.upload(this);
  }
  destroy() {
    Texture.renderer.destroy(this);
  }
  clone() {
    let texture = new Texture(this.img);
    return (
      (texture.format = this.format),
      (texture.type = this.type),
      (texture.anisotropy = this.anisotropy),
      (texture.wrapS = this.wrapS),
      (texture.wrapT = this.wrapT),
      (texture.generateMipmaps = this.generateMipmaps),
      (texture.minFilter = this.minFilter),
      (texture.magFilter = this.magFilter),
      texture
    );
  }
}
class DataTexture extends Texture {
  constructor(data, width, height, format, type) {
    super(),
      format && (this.format = format),
      (this.width = width),
      (this.height = height),
      (this.data = data),
      (this.minFilter = this.magFilter = Texture.NEAREST),
      (this.generateMipmaps = !1),
      (this.type = type || Texture.FLOAT);
  }
}
(Texture.NEAREST = "texture_nearest"),
  (Texture.CLAMP_TO_EDGE = "texture_clamp"),
  (Texture.REPEAT = "texture_repeat"),
  (Texture.MIRROR_REPEAT = "texture_mirror_repeat"),
  (Texture.LINEAR = "texture_linear"),
  (Texture.LINEAR_MIPMAP = "texture_linear_mip"),
  (Texture.LINEAR_MIPMAP_NEAREST = "texture_linear_mip_nearest"),
  (Texture.NEAREST_MIPMAP = "texture_nearest_mip"),
  (Texture.RGBFormat = "texture_rgbFormat"),
  (Texture.RGBAFormat = "texture_rgbaFormat"),
  (Texture.UNSIGNED_BYTE = "texture_unsigned_byte"),
  (Texture.DEPTH = "texture_depth"),
  (Texture.FLOAT = "texture_float"),
  (Texture.HALF_FLOAT = "texture_half_float"),
  Module(function GLSLOptimizer() {
    function unrollLoops(string) {
      return string.replace(
        /#pragma unroll_loop[\s]+?for \(int i \= (\d+)\; i < (\d+)\; i\+\+\) \{([\s\S]+?)(?=\})\}/g,
        function replace(match, start, end, snippet) {
          let unroll = "";
          for (let i = parseInt(start); i < parseInt(end); i++)
            unroll += snippet.replace(/\[i\]/g, "[" + i + "]");
          return unroll;
        }
      );
    }
    this.exports = function (code) {
      return unrollLoops(code);
    };
  }),
  Module(function GLTypes() {
    function getType(texture) {
      let _gl = Renderer.context;
      switch (texture.type) {
        case Texture.FLOAT:
          return _gl.FLOAT;
        case Texture.HALF_FLOAT:
          return Renderer.type == Renderer.WEBGL2
            ? _gl.HALF_FLOAT
            : Renderer.extensions.halfFloat.HALF_FLOAT_OES;
        default:
          return _gl.UNSIGNED_BYTE;
      }
    }
    this.exports = {
      getFormat: function getFormat(texture) {
        let _gl = Renderer.context;
        return texture.format == Texture.RGBAFormat ? _gl.RGBA : _gl.RGB;
      },
      getProperty: function getProperty(property) {
        let _gl = Renderer.context;
        switch (property) {
          case Texture.NEAREST:
            return _gl.NEAREST;
          case Texture.LINEAR:
            return _gl.LINEAR;
          case Texture.LINEAR_MIPMAP:
            return _gl.LINEAR_MIPMAP_LINEAR;
          case Texture.NEAREST_MIPMAP:
            return _gl.NEAREST_MIPMAP_LINEAR;
          case Texture.LINEAR_MIPMAP_NEAREST:
            return _gl.LINEAR_MIPMAP_NEAREST;
          case Texture.CLAMP_TO_EDGE:
            return _gl.CLAMP_TO_EDGE;
          case Texture.REPEAT:
            return _gl.REPEAT;
          case Texture.MIRROR_REPEAT:
            return _gl.MIRRORED_REPEAT;
        }
      },
      getType: getType,
      getFloatParams: function getFloatParams(texture) {
        let _gl = Renderer.context;
        return {
          internalformat: (function () {
            if (Renderer.type != Renderer.WEBGL2)
              return texture.format == Texture.RGBAFormat ? _gl.RGBA : _gl.RGB;
            switch (texture.type) {
              case Texture.HALF_FLOAT:
                return texture.format == Texture.RGBAFormat
                  ? _gl.RGBA16F
                  : _gl.RGB16F;
              case Texture.FLOAT:
                return texture.format == Texture.RGBAFormat
                  ? _gl.RGBA32F
                  : _gl.RGB32F;
            }
          })(),
          format: texture.format == Texture.RGBAFormat ? _gl.RGBA : _gl.RGB,
          type: getType(texture),
        };
      },
    };
  }),
  Module(function ShaderCode() {
    function removeUBO(code, name) {
      let uniforms = code.split(`uniform ${name} {`)[1];
      (uniforms = (uniforms = uniforms.split("};")[0]).split("\n")).forEach(
        (u) => {
          u.length && (code = code.replace(u, "uniform " + u));
        }
      );
      let split = code.split(`uniform ${name} {`);
      return (
        (split[1] = split[1].replace("};", "")),
        (code = split.join("")),
        (code = code.replace(`uniform ${name} {`, ""))
      );
    }
    this.exports = {
      convertWebGL1: function convertWebGL1(code) {
        return (
          (code = code.replace("#version 300 es", "")),
          (code = code.replace("out vec4 FragColor;", "")).includes(
            "samplerExternalOES"
          ) && (code = code.replace("samplerExternalOES", "sampler2D")),
          code.includes("uniform global {") &&
            (code = removeUBO(code, "global")),
          code.includes("uniform ubo {") && (code = removeUBO(code, "ubo")),
          code.includes("uniform lights {") &&
            (code = removeUBO(code, "lights")),
          code
        );
      },
      convertWebGL2: function convertWebGL2(code, type) {
        return (
          (code = code.replace(/texture2D/g, "texture")),
          !(code =
            "vs" == type
              ? (code = code.replace(/attribute/g, "in")).replace(
                  /varying/g,
                  "out"
                )
              : (code = code.replace(/varying/g, "in")).replace(
                  /textureCube/g,
                  "texture"
                )).includes("samplerExternalOES") ||
            ("android" == Device.system.os && window.AURA) ||
            (code = code.replace("samplerExternalOES", "sampler2D")),
          Renderer.UBO
            ? (code.includes("uniform global {") &&
                (code = code.replace(
                  "uniform global",
                  "layout(std140) uniform global"
                )),
              code.includes("uniform ubo {") &&
                (code = code.replace(
                  "uniform ubo",
                  "layout(std140) uniform ubo"
                )),
              Lighting.UBO
                ? code.includes("uniform lights {") &&
                  (code = code.replace(
                    "uniform lights",
                    "layout(std140) uniform lights"
                  ))
                : code.includes("uniform lights {") &&
                  (code = removeUBO(code, "lights")))
            : (code.includes("uniform global {") &&
                (code = removeUBO(code, "global")),
              code.includes("uniform ubo {") && (code = removeUBO(code, "ubo")),
              code.includes("uniform lights {") &&
                (code = removeUBO(code, "lights"))),
          code
        );
      },
    };
  });
class UBO {
  constructor(location, gl = Renderer.context) {
    (this.gl = gl), (this.arrays = []);
    for (let i = 0; i < 30; i++) this.arrays.push([]);
    (this.arrayIndex = 0),
      (this.objects = []),
      (this.location = location),
      (this.data = null),
      (this.lastUpdate = 0);
  }
  _getSize(uniform) {
    let obj = uniform.value;
    return Array.isArray(obj)
      ? uniform.components
        ? (obj.length / uniform.components) * 16
        : 16 * obj.length
      : obj instanceof Vector2
      ? 8
      : obj instanceof Vector3
      ? 16
      : obj instanceof Vector4
      ? 16
      : obj instanceof Color
      ? 16
      : obj instanceof Matrix4
      ? 64
      : obj instanceof Matrix3
      ? 48
      : obj instanceof Quaternion
      ? 16
      : 4;
  }
  _getValues(uniform) {
    let obj = uniform.value;
    return Array.isArray(obj)
      ? obj
      : obj instanceof Vector2
      ? this._array(obj.x, obj.y)
      : obj instanceof Vector3
      ? this._array(obj.x, obj.y, obj.z)
      : obj instanceof Matrix4
      ? obj.elements
      : obj instanceof Matrix3
      ? obj.elements
      : obj instanceof Color
      ? this._array(obj.r, obj.g, obj.b)
      : obj instanceof Quaternion
      ? this._array(obj.x, obj.y, obj.z, obj.w)
      : this._array(obj);
  }
  _array() {
    this.arrayIndex++ >= this.arrays.length - 1 && (this.arrayIndex = 0);
    let array = this.arrays[this.arrayIndex];
    return (array.length = 0), array.push.apply(array, arguments), array;
  }
  clear() {
    for (let i = 0; i < this.arrays.length; i++) this.arrays[i].length = 0;
  }
  calculate() {
    let len = this.objects.length,
      chunk = 16,
      tsize = 0,
      offset = 0,
      size = 0;
    for (let i = 0; i < len; i++) {
      let obj = this.objects[i];
      (tsize = chunk - (size = this._getSize(obj))) < 0 && chunk < 16
        ? ((offset += chunk),
          i > 0 && (this.objects[i - 1].chunkLen += chunk),
          (chunk = 16))
        : (tsize < 0 && 16 == chunk) ||
          (0 == tsize ? (chunk = 16) : (chunk -= size)),
        (obj.offset = offset / 4),
        (obj.chunkLen = size / 4),
        (obj.dataLen = size / 4),
        (offset += size);
    }
    return (
      offset % 16 != 0 &&
        ((this.objects[this.objects.length - 1].chunkLen += chunk / 4),
        (offset += chunk)),
      offset / 4
    );
  }
  compileData() {
    let i,
      array = this._array(),
      len = this.calculate();
    for (i = 0; i < len; i++) array[i] = 0;
    for (i = 0; i < this.objects.length; i++) {
      let obj = this.objects[i],
        values = this._getValues(obj);
      for (let j = 0; j < values.length; j++) array[obj.offset + j] = values[j];
    }
    return array;
  }
  upload() {
    if (this.data) return;
    let gl = Renderer.context;
    (this.data = new Float32Array(this.compileData())),
      (this.buffer = gl.createBuffer()),
      gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer),
      gl.bufferData(gl.UNIFORM_BUFFER, this.data, gl.DYNAMIC_DRAW),
      gl.bindBuffer(gl.UNIFORM_BUFFER, null),
      gl.bindBufferBase(gl.UNIFORM_BUFFER, this.location, this.buffer);
  }
  bind(program, name) {
    this.data || this.upload(), this.needsUpdate && this.update();
    let gl = Renderer.context,
      location = gl.getUniformBlockIndex(program, name);
    location > 99999 ||
      -1 == location ||
      (gl.uniformBlockBinding(program, location, this.location),
      gl.bindBufferBase(gl.UNIFORM_BUFFER, this.location, this.buffer));
  }
  update() {
    this.data || this.upload();
    let now = performance.now();
    if (this.lastUpdate && now - this.lastUpdate < 8) return;
    this.lastUpdate = now;
    let gl = Renderer.context,
      array = this.compileData();
    this.data.set(array),
      gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer),
      gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this.data),
      gl.bindBuffer(gl.UNIFORM_BUFFER, null),
      (this.needsUpdate = !1);
  }
  unbind() {}
  push() {
    if (this.data) throw "Can't modify UBO after initial upload!";
    for (let i = 0; i < arguments.length; i++) this.objects.push(arguments[i]);
  }
  destroy() {
    this.gl.deleteBuffer(this.buffer);
  }
}
class VAO {
  constructor(gl) {
    (this.gl = gl),
      (this.WEBGL2 = Renderer.type == Renderer.WEBGL2),
      this.WEBGL2
        ? (this.vao = gl.createVertexArray())
        : (this.vao = Renderer.extensions.VAO.createVertexArrayOES());
  }
  bind() {
    const gl = this.gl;
    this.WEBGL2
      ? gl.bindVertexArray(this.vao)
      : Renderer.extensions.VAO.bindVertexArrayOES(this.vao);
  }
  unbind() {
    const gl = this.gl;
    this.WEBGL2
      ? gl.bindVertexArray(null)
      : Renderer.extensions.VAO.bindVertexArrayOES(null);
  }
  destroy() {
    const gl = this.gl;
    this.WEBGL2
      ? gl.deleteVertexArray(this.vao)
      : Renderer.extensions.VAO.deleteVertexArrayOES(this.vao),
      (this.vao = null);
  }
}
class BoxGeometry extends Geometry {
  constructor(
    width = 1,
    height = 1,
    depth = 1,
    widthSegments = 1,
    heightSegments = 1,
    depthSegments = 1
  ) {
    function buildPlane(
      u,
      v,
      w,
      udir,
      vdir,
      width,
      height,
      depth,
      gridX,
      gridY,
      materialIndex
    ) {
      let ix,
        iy,
        segmentWidth = width / gridX,
        segmentHeight = height / gridY,
        widthHalf = width / 2,
        heightHalf = height / 2,
        depthHalf = depth / 2,
        gridX1 = gridX + 1,
        gridY1 = gridY + 1,
        vertexCounter = 0,
        vector = new Vector3();
      for (iy = 0; iy < gridY1; iy++) {
        let y = iy * segmentHeight - heightHalf;
        for (ix = 0; ix < gridX1; ix++) {
          let x = ix * segmentWidth - widthHalf;
          (vector[u] = x * udir),
            (vector[v] = y * vdir),
            (vector[w] = depthHalf),
            vertices.push(vector.x, vector.y, vector.z),
            (vector[u] = 0),
            (vector[v] = 0),
            (vector[w] = depth > 0 ? 1 : -1),
            normals.push(vector.x, vector.y, vector.z),
            uvs.push(ix / gridX),
            uvs.push(1 - iy / gridY),
            (vertexCounter += 1);
        }
      }
      for (iy = 0; iy < gridY; iy++)
        for (ix = 0; ix < gridX; ix++) {
          let a = numberOfVertices + ix + gridX1 * iy,
            b = numberOfVertices + ix + gridX1 * (iy + 1),
            c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1),
            d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d), indices.push(b, c, d);
        }
      numberOfVertices += vertexCounter;
    }
    super(),
      (widthSegments = Math.floor(widthSegments)),
      (heightSegments = Math.floor(heightSegments));
    let indices = [],
      vertices = [],
      normals = [],
      uvs = [],
      numberOfVertices = 0;
    buildPlane(
      "z",
      "y",
      "x",
      -1,
      -1,
      depth,
      height,
      width,
      (depthSegments = Math.floor(depthSegments)),
      heightSegments
    ),
      buildPlane(
        "z",
        "y",
        "x",
        1,
        -1,
        depth,
        height,
        -width,
        depthSegments,
        heightSegments
      ),
      buildPlane(
        "x",
        "z",
        "y",
        1,
        1,
        width,
        depth,
        height,
        widthSegments,
        depthSegments
      ),
      buildPlane(
        "x",
        "z",
        "y",
        1,
        -1,
        width,
        depth,
        -height,
        widthSegments,
        depthSegments
      ),
      buildPlane(
        "x",
        "y",
        "z",
        1,
        -1,
        width,
        height,
        depth,
        widthSegments,
        heightSegments
      ),
      buildPlane(
        "x",
        "y",
        "z",
        -1,
        -1,
        width,
        height,
        -depth,
        widthSegments,
        heightSegments
      ),
      (this.index = new Uint16Array(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
class CircleGeometry extends Geometry {
  constructor(
    radius = 1,
    segments = 8,
    thetaStart = 0,
    thetaLength = 2 * Math.PI
  ) {
    super();
    var i,
      s,
      indices = [],
      vertices = [],
      normals = [],
      uvs = [],
      vertex = new Vector3(),
      uv = new Vector2();
    for (
      vertices.push(0, 0, 0),
        normals.push(0, 0, 1),
        uvs.push(0.5, 0.5),
        s = 0,
        i = 3;
      s <= segments;
      s++, i += 3
    ) {
      var segment = thetaStart + (s / segments) * thetaLength;
      (vertex.x = radius * Math.cos(segment)),
        (vertex.y = radius * Math.sin(segment)),
        vertices.push(vertex.x, vertex.y, vertex.z),
        normals.push(0, 0, 1),
        (uv.x = (vertices[i] / radius + 1) / 2),
        (uv.y = (vertices[i + 1] / radius + 1) / 2),
        uvs.push(uv.x, uv.y);
    }
    for (i = 1; i <= segments; i++) indices.push(i, i + 1, 0);
    (this.index = new Uint16Array(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
class CylinderGeometry extends Geometry {
  constructor(
    radiusTop = 1,
    radiusBottom = 1,
    height = 1,
    radialSegments = 8,
    heightSegments = 1,
    openEnded = !1,
    thetaStart = 0,
    thetaLength = 2 * Math.PI
  ) {
    function generateCap(top) {
      let x,
        centerIndexStart,
        centerIndexEnd,
        uv = new Vector2(),
        vertex = new Vector3(),
        radius = !0 === top ? radiusTop : radiusBottom,
        sign = !0 === top ? 1 : -1;
      for (centerIndexStart = index, x = 1; x <= radialSegments; x++)
        vertices.push(0, halfHeight * sign, 0),
          normals.push(0, sign, 0),
          uvs.push(0.5, 0.5),
          index++;
      for (centerIndexEnd = index, x = 0; x <= radialSegments; x++) {
        let theta = (x / radialSegments) * thetaLength + thetaStart,
          cosTheta = Math.cos(theta),
          sinTheta = Math.sin(theta);
        (vertex.x = radius * sinTheta),
          (vertex.y = halfHeight * sign),
          (vertex.z = radius * cosTheta),
          vertices.push(vertex.x, vertex.y, vertex.z),
          normals.push(0, sign, 0),
          (uv.x = 0.5 * cosTheta + 0.5),
          (uv.y = 0.5 * sinTheta * sign + 0.5),
          uvs.push(uv.x, uv.y),
          index++;
      }
      for (x = 0; x < radialSegments; x++) {
        let c = centerIndexStart + x,
          i = centerIndexEnd + x;
        !0 === top ? indices.push(i, i + 1, c) : indices.push(i + 1, i, c);
      }
    }
    super(),
      (radialSegments = Math.floor(radialSegments)),
      (heightSegments = Math.floor(heightSegments));
    let indices = [],
      vertices = [],
      normals = [],
      uvs = [],
      index = 0,
      indexArray = [],
      halfHeight = height / 2;
    !(function generateTorso() {
      let x,
        y,
        normal = new Vector3(),
        vertex = new Vector3(),
        slope = (radiusBottom - radiusTop) / height;
      for (y = 0; y <= heightSegments; y++) {
        let indexRow = [],
          v = y / heightSegments,
          radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (x = 0; x <= radialSegments; x++) {
          let u = x / radialSegments,
            theta = u * thetaLength + thetaStart,
            sinTheta = Math.sin(theta),
            cosTheta = Math.cos(theta);
          (vertex.x = radius * sinTheta),
            (vertex.y = -v * height + halfHeight),
            (vertex.z = radius * cosTheta),
            vertices.push(vertex.x, vertex.y, vertex.z),
            normal.set(sinTheta, slope, cosTheta).normalize(),
            normals.push(normal.x, normal.y, normal.z),
            uvs.push(u, 1 - v),
            indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (x = 0; x < radialSegments; x++)
        for (y = 0; y < heightSegments; y++) {
          let a = indexArray[y][x],
            b = indexArray[y + 1][x],
            c = indexArray[y + 1][x + 1],
            d = indexArray[y][x + 1];
          indices.push(a, b, d), indices.push(b, c, d);
        }
    })(),
      !1 === openEnded &&
        (radiusTop > 0 && generateCap(!0), radiusBottom > 0 && generateCap(!1)),
      (this.index = new Uint16Array(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(
    radius,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  ) {
    super(
      0,
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    );
  }
}
class PlaneGeometry extends Geometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    let ix,
      iy,
      width_half = width / 2,
      height_half = height / 2,
      gridX = Math.floor(widthSegments) || 1,
      gridY = Math.floor(heightSegments) || 1,
      gridX1 = gridX + 1,
      gridY1 = gridY + 1,
      segment_width = width / gridX,
      segment_height = height / gridY,
      indices = [],
      vertices = [],
      normals = [],
      uvs = [];
    for (iy = 0; iy < gridY1; iy++) {
      let y = iy * segment_height - height_half;
      for (ix = 0; ix < gridX1; ix++) {
        let x = ix * segment_width - width_half;
        vertices.push(x, -y, 0),
          normals.push(0, 0, 1),
          uvs.push(ix / gridX),
          uvs.push(1 - iy / gridY);
      }
    }
    for (iy = 0; iy < gridY; iy++)
      for (ix = 0; ix < gridX; ix++) {
        let a = ix + gridX1 * iy,
          b = ix + gridX1 * (iy + 1),
          c = ix + 1 + gridX1 * (iy + 1),
          d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d), indices.push(b, c, d);
      }
    (this.index = new Uint16Array(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
class PolyhedronGeometry extends Geometry {
  constructor(vertices, indices = [], radius = 1, detail = 0) {
    function subdivideFace(a, b, c, detail) {
      var i,
        j,
        cols = Math.pow(2, detail),
        v = [];
      for (i = 0; i <= cols; i++) {
        v[i] = [];
        var aj = a.clone().lerp(c, i / cols),
          bj = b.clone().lerp(c, i / cols),
          rows = cols - i;
        for (j = 0; j <= rows; j++)
          v[i][j] = 0 === j && i === cols ? aj : aj.clone().lerp(bj, j / rows);
      }
      for (i = 0; i < cols; i++)
        for (j = 0; j < 2 * (cols - i) - 1; j++) {
          var k = Math.floor(j / 2);
          j % 2 == 0
            ? (pushVertex(v[i][k + 1]),
              pushVertex(v[i + 1][k]),
              pushVertex(v[i][k]))
            : (pushVertex(v[i][k + 1]),
              pushVertex(v[i + 1][k + 1]),
              pushVertex(v[i + 1][k]));
        }
    }
    function correctSeam() {
      for (let i = 0; i < uvBuffer.length; i += 6) {
        let x0 = uvBuffer[i + 0],
          x1 = uvBuffer[i + 2],
          x2 = uvBuffer[i + 4],
          max = Math.max(x0, x1, x2),
          min = Math.min(x0, x1, x2);
        max > 0.9 &&
          min < 0.1 &&
          (x0 < 0.2 && (uvBuffer[i + 0] += 1),
          x1 < 0.2 && (uvBuffer[i + 2] += 1),
          x2 < 0.2 && (uvBuffer[i + 4] += 1));
      }
    }
    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    function getVertexByIndex(index, vertex) {
      let stride = 3 * index;
      (vertex.x = vertices[stride + 0]),
        (vertex.y = vertices[stride + 1]),
        (vertex.z = vertices[stride + 2]);
    }
    function correctUVs() {
      let a = new Vector3(),
        b = new Vector3(),
        c = new Vector3(),
        centroid = new Vector3(),
        uvA = new Vector2(),
        uvB = new Vector2(),
        uvC = new Vector2();
      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]),
          b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]),
          c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]),
          uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]),
          uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]),
          uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]),
          centroid.copy(a).add(b).add(c).divideScalar(3);
        let azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi),
          correctUV(uvB, j + 2, b, azi),
          correctUV(uvC, j + 4, c, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth) {
      azimuth < 0 && 1 === uv.x && (uvBuffer[stride] = uv.x - 1),
        0 === vector.x &&
          0 === vector.z &&
          (uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5);
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(
        -vector.y,
        Math.sqrt(vector.x * vector.x + vector.z * vector.z)
      );
    }
    super();
    let vertexBuffer = [],
      uvBuffer = [];
    !(function subdivide(detail) {
      let a = new Vector3(),
        b = new Vector3(),
        c = new Vector3();
      for (let i = 0; i < indices.length; i += 3)
        getVertexByIndex(indices[i + 0], a),
          getVertexByIndex(indices[i + 1], b),
          getVertexByIndex(indices[i + 2], c),
          subdivideFace(a, b, c, detail);
    })(detail),
      (function appplyRadius(radius) {
        for (var vertex = new Vector3(), i = 0; i < vertexBuffer.length; i += 3)
          (vertex.x = vertexBuffer[i + 0]),
            (vertex.y = vertexBuffer[i + 1]),
            (vertex.z = vertexBuffer[i + 2]),
            vertex.normalize().multiplyScalar(radius),
            (vertexBuffer[i + 0] = vertex.x),
            (vertexBuffer[i + 1] = vertex.y),
            (vertexBuffer[i + 2] = vertex.z);
      })(radius),
      (function generateUVs() {
        let vertex = new Vector3();
        for (let i = 0; i < vertexBuffer.length; i += 3) {
          (vertex.x = vertexBuffer[i + 0]),
            (vertex.y = vertexBuffer[i + 1]),
            (vertex.z = vertexBuffer[i + 2]);
          let u = azimuth(vertex) / 2 / Math.PI + 0.5,
            v = inclination(vertex) / Math.PI + 0.5;
          uvBuffer.push(u, 1 - v);
        }
        correctUVs(), correctSeam();
      })(),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertexBuffer), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(vertexBuffer.slice()), 3)
      ),
      this.addAttribute(
        "uv",
        new GeometryAttribute(new Float32Array(uvBuffer), 2)
      ),
      0 === detail ? this.computeVertexNormals() : this.normalizeNormals();
  }
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius, detail) {
    let t = (1 + Math.sqrt(5)) / 2;
    super(
      [
        -1,
        t,
        0,
        1,
        t,
        0,
        -1,
        -t,
        0,
        1,
        -t,
        0,
        0,
        -1,
        t,
        0,
        1,
        t,
        0,
        -1,
        -t,
        0,
        1,
        -t,
        t,
        0,
        -1,
        t,
        0,
        1,
        -t,
        0,
        -1,
        -t,
        0,
        1,
      ],
      [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ],
      radius,
      detail
    );
  }
}
class RingGeometry extends Geometry {
  constructor(
    innerRadius = 0.5,
    outerRadius = 1,
    thetaSegments = 8,
    phiSegments = 1,
    thetaStart = 0,
    thetaLength = 2 * Math.PI
  ) {
    super();
    var segment,
      j,
      i,
      indices = [],
      vertices = [],
      normals = [],
      uvs = [],
      radius = innerRadius,
      radiusStep = (outerRadius - innerRadius) / phiSegments,
      vertex = new Vector3(),
      uv = new Vector2();
    for (j = 0; j <= phiSegments; j++) {
      for (i = 0; i <= thetaSegments; i++)
        (segment = thetaStart + (i / thetaSegments) * thetaLength),
          (vertex.x = radius * Math.cos(segment)),
          (vertex.y = radius * Math.sin(segment)),
          vertices.push(vertex.x, vertex.y, vertex.z),
          normals.push(0, 0, 1),
          (uv.x = (vertex.x / outerRadius + 1) / 2),
          (uv.y = (vertex.y / outerRadius + 1) / 2),
          uvs.push(uv.x, uv.y);
      radius += radiusStep;
    }
    for (j = 0; j < phiSegments; j++) {
      var thetaSegmentLevel = j * (thetaSegments + 1);
      for (i = 0; i < thetaSegments; i++) {
        var a = (segment = i + thetaSegmentLevel),
          b = segment + thetaSegments + 1,
          c = segment + thetaSegments + 2,
          d = segment + 1;
        indices.push(a, b, d), indices.push(b, c, d);
      }
    }
    (this.index = new Uint16Array(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
class SphereGeometry extends Geometry {
  constructor(
    radius = 1,
    widthSegments = 8,
    heightSegments = 6,
    phiStart = 0,
    phiLength = 2 * Math.PI,
    thetaStart = 0,
    thetaLength = Math.PI
  ) {
    super(),
      (widthSegments = Math.max(3, Math.floor(widthSegments))),
      (heightSegments = Math.max(2, Math.floor(heightSegments)));
    let ix,
      iy,
      thetaEnd = thetaStart + thetaLength,
      index = 0,
      grid = [],
      vertex = new Vector3(),
      normal = new Vector3(),
      indices = [],
      vertices = [],
      normals = [],
      uvs = [];
    for (iy = 0; iy <= heightSegments; iy++) {
      let verticesRow = [],
        v = iy / heightSegments;
      for (ix = 0; ix <= widthSegments; ix++) {
        let u = ix / widthSegments;
        (vertex.x =
          -radius *
          Math.cos(phiStart + u * phiLength) *
          Math.sin(thetaStart + v * thetaLength)),
          (vertex.y = radius * Math.cos(thetaStart + v * thetaLength)),
          (vertex.z =
            radius *
            Math.sin(phiStart + u * phiLength) *
            Math.sin(thetaStart + v * thetaLength)),
          vertices.push(vertex.x, vertex.y, vertex.z),
          normal.set(vertex.x, vertex.y, vertex.z).normalize(),
          normals.push(normal.x, normal.y, normal.z),
          uvs.push(u, 1 - v),
          verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (iy = 0; iy < heightSegments; iy++)
      for (ix = 0; ix < widthSegments; ix++) {
        let a = grid[iy][ix + 1],
          b = grid[iy][ix],
          c = grid[iy + 1][ix],
          d = grid[iy + 1][ix + 1];
        (0 !== iy || thetaStart > 0) && indices.push(a, b, d),
          (iy !== heightSegments - 1 || thetaEnd < Math.PI) &&
            indices.push(b, c, d);
      }
    (this.index = new Uint16Array(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
class TorusKnotGeometry extends Geometry {
  constructor(
    radius = 1,
    tube = 0.4,
    tubularSegments = 64,
    radialSegments = 8,
    p = 2,
    q = 3
  ) {
    function calculatePositionOnCurve(u, p, q, radius, position) {
      let cu = Math.cos(u),
        su = Math.sin(u),
        quOverP = (q / p) * u,
        cs = Math.cos(quOverP);
      (position.x = radius * (2 + cs) * 0.5 * cu),
        (position.y = radius * (2 + cs) * su * 0.5),
        (position.z = radius * Math.sin(quOverP) * 0.5);
    }
    super();
    let i,
      j,
      indices = [],
      vertices = [],
      normals = [],
      uvs = [],
      vertex = new Vector3(),
      normal = new Vector3(),
      P1 = new Vector3(),
      P2 = new Vector3(),
      B = new Vector3(),
      T = new Vector3(),
      N = new Vector3();
    for (i = 0; i <= tubularSegments; ++i) {
      let u = (i / tubularSegments) * p * Math.PI * 2;
      for (
        calculatePositionOnCurve(u, p, q, radius, P1),
          calculatePositionOnCurve(u + 0.01, p, q, radius, P2),
          T.subVectors(P2, P1),
          N.addVectors(P2, P1),
          B.crossVectors(T, N),
          N.crossVectors(B, T),
          B.normalize(),
          N.normalize(),
          j = 0;
        j <= radialSegments;
        ++j
      ) {
        let v = (j / radialSegments) * Math.PI * 2,
          cx = -tube * Math.cos(v),
          cy = tube * Math.sin(v);
        (vertex.x = P1.x + (cx * N.x + cy * B.x)),
          (vertex.y = P1.y + (cx * N.y + cy * B.y)),
          (vertex.z = P1.z + (cx * N.z + cy * B.z)),
          vertices.push(vertex.x, vertex.y, vertex.z),
          normal.subVectors(vertex, P1).normalize(),
          normals.push(normal.x, normal.y, normal.z),
          uvs.push(i / tubularSegments),
          uvs.push(j / radialSegments);
      }
    }
    for (j = 1; j <= tubularSegments; j++)
      for (i = 1; i <= radialSegments; i++) {
        let a = (radialSegments + 1) * (j - 1) + (i - 1),
          b = (radialSegments + 1) * j + (i - 1),
          c = (radialSegments + 1) * j + i,
          d = (radialSegments + 1) * (j - 1) + i;
        indices.push(a, b, d), indices.push(b, c, d);
      }
    (this.index = new Uint16Array(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
Class(
  function Interaction3D(_camera) {
    function parseMeshes(meshes) {
      function checkMesh(obj) {
        obj.hitArea && (obj = initHitMesh(obj)),
          "boolean" == typeof obj.isHitMesh
            ? ((obj.mouseEnabled = function (visible) {
                visible
                  ? ~_meshes.indexOf(obj) || _meshes.push(obj)
                  : _meshes.remove(obj);
              }),
              output.push(obj))
            : output.push(obj),
          obj.children.length && obj.children.forEach(checkMesh);
      }
      Array.isArray(meshes) || (meshes = [meshes]);
      let output = [];
      return meshes.forEach(checkMesh), output;
    }
    function initHitMesh(obj) {
      return (
        obj.hitMesh ||
          ((obj.hitMesh = new Mesh(obj.hitArea)), obj.add(obj.hitMesh)),
        (obj = obj.hitMesh),
        (obj.isHitMesh = !0),
        (obj.testVisibility = !1),
        (obj.visible = !1),
        obj
      );
    }
    function testObjects() {
      _test.length = 0;
      for (let i = _meshes.length - 1; i > -1; i--) {
        let obj = _meshes[i];
        obj.determineVisible() && _test.push(obj);
      }
      return _test;
    }
    function addHandlers() {
      _this.events.sub(Mouse.input, Interaction.START, start),
        Device.mobile && _this.events.sub(Mouse.input, Interaction.END, end),
        _this.events.sub(Mouse.input, Interaction.MOVE, move),
        _this.events.sub(Mouse.input, Interaction.CLICK, click);
    }
    function removeHandlers() {
      _this.events.unsub(Mouse.input, Interaction.START, start),
        Device.mobile && _this.events.unsub(Mouse.input, Interaction.END, end),
        _this.events.unsub(Mouse.input, Interaction.MOVE, move),
        _this.events.unsub(Mouse.input, Interaction.CLICK, click);
    }
    function start() {
      if (!_this.enabled) return;
      let hit = move();
      hit ? ((_click = hit.object).time = Render.TIME) : (_click = null);
    }
    function move() {
      if (!_this.enabled) return void Stage.css("cursor", _this.cursor);
      let hit;
      if (
        ("2d" == _input.type
          ? (hit = _ray.checkHit(testObjects(), _input.position)[0])
          : (_v3.set(0, 0, -1).applyQuaternion(_input.quaternion),
            (hit = _ray.checkFromValues(
              testObjects(),
              _input.position,
              _v3
            )[0])),
        hit)
      ) {
        let mesh = hit.object;
        return (
          _input.obj &&
            _input.obj.setHitPosition &&
            _input.obj.setHitPosition(hit),
          _hover !== mesh
            ? (_hover && triggerHover("out", _hover, hit),
              triggerHover("over", (_hover = mesh), hit),
              _hover.__clickCallback
                ? Stage.css("cursor", "pointer")
                : Stage.css("cursor", _this.cursor))
            : triggerMove(_hover, hit),
          hit
        );
      }
      return (
        end(),
        _input.obj &&
          _input.obj.setHitPosition &&
          _input.obj.setHitPosition(!1),
        !1
      );
    }
    function end() {
      _hover &&
        (triggerHover("out", _hover, null),
        (_hover = null),
        Stage.css("cursor", _this.cursor));
    }
    function click(e) {
      if (!_this.enabled) return;
      if (!_click) return;
      let hit;
      if ("2d" == _input.type) {
        let element = document.elementFromPoint(e.x, e.y);
        if (element && "hit" === element.className) return;
        hit = _ray.checkHit(testObjects(), _input.position)[0];
      } else
        _v3.set(0, 0, -1).applyQuaternion(_input.quaternion),
          (hit = _ray.checkFromValues(testObjects(), _input.position, _v3)[0]);
      hit && hit.object === _click && triggerClick(_click, hit),
        (_click = null);
    }
    function triggerHover(action, mesh, hit) {
      (_event.action = action),
        (_event.mesh = mesh),
        (_event.hit = hit),
        _this.events.fire(Interaction3D.HOVER, _event, !0),
        _hover.__hoverCallback && _hover.__hoverCallback(_event);
    }
    function triggerClick(mesh, hit) {
      (_event.action = "click"),
        (_event.mesh = mesh),
        (_event.hit = hit),
        _this.events.fire(Interaction3D.CLICK, _event, !0),
        _click.__clickCallback && _click.__clickCallback(_event);
    }
    function triggerMove(mesh, hit) {
      (_event.action = "move"),
        (_event.mesh = mesh),
        (_event.hit = hit),
        _this.events.fire(Interaction3D.MOVE, _event, !0),
        mesh["__moveCallback" + _this.ID] &&
          mesh["__moveCallback" + _this.ID](_event);
    }
    Inherit(this, Component);
    const _this = this;
    let _hover, _click;
    var _input,
      _hold,
      _calc,
      _v3 = new Vector3();
    (_this.ID = Utils.timestamp()), (_camera = _camera || World.CAMERA);
    let _ray = _this.initClass(Raycaster, _camera);
    _ray.testVisibility = !0;
    let _meshes = [],
      _test = [];
    const _event = {};
    (this.cursor = "auto"),
      (_this.enabled = !0),
      this.set("camera", (c) => {
        _ray.camera = c;
      }),
      (this.add = function (meshes, hover, click, move, isParse) {
        (Array.isArray(meshes) && !isParse) || (meshes = parseMeshes(meshes)),
          meshes.forEach((mesh) => {
            (mesh.hitDestroy = (_) => _meshes.remove(mesh)),
              hover && (mesh.__hoverCallback = hover),
              click && (mesh.__clickCallback = click),
              move && (mesh["__moveCallback" + _this.ID] = move),
              _meshes.push(mesh);
          });
      }),
      (this.remove = function (meshes, isParse) {
        (Array.isArray(meshes) && !isParse) || (meshes = parseMeshes(meshes)),
          meshes.forEach((mesh) => {
            mesh === _hover &&
              ((_hover = null), Stage.css("cursor", _this.cursor));
            for (let i = _meshes.length - 1; i >= 0; i--)
              mesh === _meshes[i] && _meshes.splice(i, 1);
          });
      }),
      this.set("testVisibility", (v) => (_ray.testVisibility = v)),
      this.set("input", (obj) => {
        ((_input = {}).obj = obj),
          (_input.position = (obj.group && obj.group.position) || obj),
          (_input.quaternion = obj.group && obj.group.quaternion),
          (_input.type = "number" == typeof _input.position.z ? "3d" : "2d"),
          "3d" == _input.type
            ? ((_hold = new Vector3()), (_calc = new Vector3()))
            : ((_hold = new Vector2()), (_calc = new Vector2())),
          obj == Mouse
            ? addHandlers()
            : (removeHandlers(),
              _this.events.sub(obj, Events.SELECT, start),
              _this.events.sub(obj, Events.END, click),
              _this.startRender(move, 24));
      });
  },
  () => {
    (Interaction3D.HOVER = "interaction3d_hover"),
      (Interaction3D.CLICK = "interaction3d_click"),
      (Interaction3D.MOVE = "interaction3d_move");
    var _map = new WeakMap(),
      _input = Mouse;
    (Interaction3D.find = function (camera) {
      if (!_map.has(camera)) {
        let interaction = new Interaction3D(camera);
        (interaction.input = _input), _map.set(camera, interaction);
      }
      return _map.get(camera);
    }),
      (Interaction3D.useInput = function (obj) {
        for (let [camera, interaction] of _map) interaction.input = obj;
        _input = obj;
      });
  }
),
  Class(function Lighting() {
    function loop() {
      if ((decomposeLights(_activeScene.lights), _this.UBO)) {
        let shader = _activeScene.shaders.start();
        shader &&
          (updateArrays(shader),
          _activeScene.ubo.created
            ? _activeScene.ubo.update()
            : createUBO(shader.uniforms));
      } else {
        let shader = _activeScene.shaders.start();
        for (; shader; )
          updateArrays(shader), (shader = _activeScene.shaders.next());
      }
    }
    function createUBO(uniforms) {
      (_activeScene.ubo.created = !0),
        _activeScene.ubo.push(uniforms.lightPos),
        _activeScene.ubo.push(uniforms.lightColor),
        _activeScene.ubo.push(uniforms.lightData),
        _activeScene.ubo.push(uniforms.lightData2),
        _activeScene.ubo.push(uniforms.lightData3),
        _activeScene.ubo.push(uniforms.lightProperties);
    }
    function decomposeLights(lights) {
      for (let i = lights.length - 1; i > -1; i--) {
        let light = lights[i];
        (light._decomposedTime && Render.TIME - light._decomposedTime < 8) ||
          ((light._decomposedTime = Render.TIME),
          light._parent || light.updateMatrixWorld(),
          light._world || (light._world = new Vector3()),
          light.lockToLocal
            ? light._world.copy(light.position)
            : light.getWorldPosition(light._world));
      }
    }
    function updateArrays(shader) {
      let lighting = shader.__lighting;
      (lighting.position.length = 0),
        (lighting.color.length = 0),
        (lighting.data.length = 0),
        (lighting.data2.length = 0),
        (lighting.data3.length = 0),
        (lighting.properties.length = 0);
      for (let i = 0; i < _activeScene.lights.length; i++) {
        let light = _activeScene.lights[i];
        light._world || decomposeLights(_activeScene.lights),
          lighting.position.push(
            light._world.x,
            light._world.y,
            light._world.z,
            0
          ),
          lighting.color.push(light.color.r, light.color.g, light.color.b, 0),
          lighting.data.push(
            light.data.x,
            light.data.y,
            light.data.z,
            light.data.w
          ),
          lighting.data2.push(
            light.data2.x,
            light.data2.y,
            light.data2.z,
            light.data2.w
          ),
          lighting.data3.push(
            light.data3.x,
            light.data3.y,
            light.data3.z,
            light.data3.w
          ),
          lighting.properties.push(
            light.properties.x,
            light.properties.y,
            light.properties.z,
            light.properties.w
          );
      }
    }
    Inherit(this, Component);
    const _this = this;
    var _activeScene,
      _scenes = {};
    (this.fallbackAreaToPoint = !1),
      (async function () {
        await defer(), _this.createScene("default"), _this.useScene("default");
      })(),
      (this.createScene = function (name) {
        let scene = {
          lights: [],
          renderShadows: [],
          ubo: new UBO(2),
          shaders: new LinkedList(),
          name: name,
        };
        return (_scenes[name] = scene), this;
      }),
      (this.useScene = function (name) {
        if (!(_activeScene = _scenes[name])) throw `Scene ${name} not found`;
        return (_activeScene.ubo.debug = !0), this;
      }),
      (this.push = this.add =
        function (light) {
          (_this.UBO =
            Renderer.UBO &&
            !(window.AURA || RenderManager.type == RenderManager.WEBVR)),
            _activeScene.lights.push(light),
            _this.startedLoop ||
              ((_this.startedLoop = !0),
              RenderManager.type == RenderManager.WEBVR
                ? _this.events.sub(RenderManager.BEFORE_RENDER, (_) => loop())
                : Render.onDrawFrame(loop));
        }),
      (this.remove = function (light) {
        _activeScene.lights.remove(light);
      }),
      (this.getLighting = function (shader, force) {
        return shader.__lighting && !force
          ? shader.__lighting
          : (_activeScene.shaders.push(shader),
            window.AreaLightUtil && AreaLightUtil.append(shader),
            (shader.__lighting = {
              position: [],
              color: [],
              data: [],
              data2: [],
              data3: [],
              properties: [],
            }),
            updateArrays(shader),
            shader.__lighting);
      }),
      (this.destroyShader = function (shader) {
        _activeScene.shaders.remove(shader);
      }),
      (this.sort = function (callback) {
        _activeScene.lights.sort(callback);
      }),
      (this.addToShadowGroup = function (light) {
        _activeScene.renderShadows.push(light);
      }),
      (this.removeFromShadowGroup = function (light) {
        _activeScene.renderShadows.remove(light);
      }),
      (this.getShadowLights = function () {
        return _activeScene.renderShadows;
      }),
      (this.getShadowCount = function () {
        return _activeScene.renderShadows.length;
      }),
      (this.initShadowShader = function (object, mesh) {
        if (!Renderer.instance.shadows) return;
        let shader = object.shader || object;
        shader._gl || shader.upload();
        let vsName = shader.vsName,
          fsName = "ShadowDepth";
        shader.customShadowShader &&
          (vsName = fsName = shader.customShadowShader),
          (object.castShadow == Shader.CUSTOM_DEPTH ||
            (mesh && mesh.castShadow == Shader.CUSTOM_DEPTH)) &&
            (vsName = shader.vsName),
          (shader.shadow = new Shader(vsName, fsName, {
            receiveLight: shader.receiveLight,
            UILPrefix: shader.UILPrefix,
            precision: "high",
          })),
          (shader.shadow.lights = shader.lights),
          shader.copyUniformsTo(shader.shadow, !0),
          shader.shadow.upload();
      }),
      (this.getShadowUniforms = function () {
        return Renderer.instance.shadows &&
          0 != _activeScene.renderShadows.length
          ? [
              `\n#define SHADOW_MAPS ${_activeScene.renderShadows.length}`,
              Renderer.instance.shadows == Renderer.SHADOWS_LOW
                ? "#define SHADOWS_LOW"
                : "",
              Renderer.instance.shadows == Renderer.SHADOWS_MED
                ? "#define SHADOWS_MED"
                : "",
              Renderer.instance.shadows == Renderer.SHADOWS_HIGH
                ? "#define SHADOWS_HIGH"
                : "",
              `uniform sampler2D shadowMap[${_activeScene.renderShadows.length}];`,
              `uniform mat4 shadowMatrix[${_activeScene.renderShadows.length}];`,
              `uniform vec3 shadowLightPos[${_activeScene.renderShadows.length}];`,
              `uniform float shadowSize[${_activeScene.renderShadows.length}];`,
            ].join("\n")
          : "";
      }),
      (this.bindUBO = function (shader) {
        _activeScene.ubo.created && _activeScene.ubo.bind(shader, "lights");
      }),
      (this.fallbackAreaToPointTest = function () {
        return _this.fallbackAreaToPoint;
      });
  }, "static");
class Shadow {
  constructor(light) {
    (this.light = light),
      (this.camera = new PerspectiveCamera(60, 1, 0.1, 50)),
      (this.target = new Vector3()),
      (this.rt = new RenderTarget(1024, 1024)),
      this.rt.createDepthTexture(),
      (this.enabled = !0),
      (this._size = 1024),
      (this._fov = 60),
      (this._far = 50),
      light.add(this.camera);
  }
  destroy() {
    this.rt.destroy();
  }
  set fov(value) {
    (this._fov = value),
      (this.camera.fov = value),
      this.camera.updateProjectionMatrix(),
      -1 == value &&
        (this.camera = new OrthographicCamera(-5, 5, 5, -5, 0.1, 50));
  }
  get fov() {
    return this._fov;
  }
  set area(value) {
    (this._area = value),
      (this.camera.left = -value),
      (this.camera.right = value),
      (this.camera.top = value),
      (this.camera.bottom = -value),
      this.camera.updateProjectionMatrix();
  }
  get area() {
    return this._area;
  }
  set far(value) {
    (this._far = value),
      (this.camera.far = value),
      this.camera.updateProjectionMatrix();
  }
  get far() {
    return this._far;
  }
  set size(value) {
    (this._size = value), this.rt.setSize(value, value);
  }
  get size() {
    return this._size;
  }
}
class Box2 {
  constructor(min, max) {
    (this.min = void 0 !== min ? min : new Vector2(1 / 0, 1 / 0)),
      (this.max = void 0 !== max ? max : new Vector2(-1 / 0, -1 / 0));
  }
  set(min, max) {
    return this.min.copy(min), this.max.copy(max), this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++)
      this.expandByPoint(points[i]);
    return this;
  }
  setFromCenterAndSize(center, size) {
    let v1 = this.V1 || new Vector2();
    this.V1 = v1;
    let halfSize = v1.copy(size).multiplyScalar(0.5);
    return (
      this.min.copy(center).sub(halfSize),
      this.max.copy(center).add(halfSize),
      this
    );
  }
  clone() {
    return new Box2().copy(this);
  }
  copy(box) {
    return this.min.copy(box.min), this.max.copy(box.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    return this.isEmpty()
      ? target.set(0, 0)
      : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty()
      ? target.set(0, 0)
      : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    return this.min.min(point), this.max.max(point), this;
  }
  expandByVector(vector) {
    return this.min.sub(vector), this.max.add(vector), this;
  }
  expandByScalar(scalar) {
    return this.min.addScalar(-scalar), this.max.addScalar(scalar), this;
  }
  containsPoint(point) {
    return !(
      point.x < this.min.x ||
      point.x > this.max.x ||
      point.y < this.min.y ||
      point.y > this.max.y
    );
  }
  containsBox(box) {
    return (
      this.min.x <= box.min.x &&
      box.max.x <= this.max.x &&
      this.min.y <= box.min.y &&
      box.max.y <= this.max.y
    );
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(box) {
    return !(
      box.max.x < this.min.x ||
      box.min.x > this.max.x ||
      box.max.y < this.min.y ||
      box.min.y > this.max.y
    );
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    let v1 = this.V1 || new Vector2();
    return (
      (this.V1 = v1),
      v1.copy(point).clamp(this.min, this.max).sub(point).length()
    );
  }
  intersect(box) {
    return this.min.max(box.min), this.max.min(box.max), this;
  }
  union(box) {
    return this.min.min(box.min), this.max.max(box.max), this;
  }
  translate(offset) {
    return this.min.add(offset), this.max.add(offset), this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
class Box3 {
  constructor(min, max) {
    (this.min = void 0 !== min ? min : new Vector3(1 / 0, 1 / 0, 1 / 0)),
      (this.max = void 0 !== max ? max : new Vector3(-1 / 0, -1 / 0, -1 / 0));
  }
  set(min, max) {
    return this.min.copy(min), this.max.copy(max), this;
  }
  setFromArray(array) {
    let minX = 1 / 0,
      minY = 1 / 0,
      minZ = 1 / 0,
      maxX = -1 / 0,
      maxY = -1 / 0,
      maxZ = -1 / 0;
    for (let i = 0, l = array.length; i < l; i += 3) {
      let x = array[i],
        y = array[i + 1],
        z = array[i + 2];
      x < minX && (minX = x),
        y < minY && (minY = y),
        z < minZ && (minZ = z),
        x > maxX && (maxX = x),
        y > maxY && (maxY = y),
        z > maxZ && (maxZ = z);
    }
    return this.min.set(minX, minY, minZ), this.max.set(maxX, maxY, maxZ), this;
  }
  setFromBufferAttribute(attribute) {
    let minX = 1 / 0,
      minY = 1 / 0,
      minZ = 1 / 0,
      maxX = -1 / 0,
      maxY = -1 / 0,
      maxZ = -1 / 0;
    for (let i = 0, l = attribute.count; i < l; i++) {
      let x = attribute.array[3 * i + 0],
        y = attribute.array[3 * i + 1],
        z = attribute.array[3 * i + 2];
      x < minX && (minX = x),
        y < minY && (minY = y),
        z < minZ && (minZ = z),
        x > maxX && (maxX = x),
        y > maxY && (maxY = y),
        z > maxZ && (maxZ = z);
    }
    return this.min.set(minX, minY, minZ), this.max.set(maxX, maxY, maxZ), this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++)
      this.expandByPoint(points[i]);
    return this;
  }
  setFromCenterAndSize(center, size) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let halfSize = v1.copy(size).multiplyScalar(0.5);
    return (
      this.min.copy(center).sub(halfSize),
      this.max.copy(center).add(halfSize),
      this
    );
  }
  setFromObject(object) {
    return this.makeEmpty(), this.expandByObject(object);
  }
  clone() {
    return new Box3().copy(this);
  }
  copy(box) {
    return this.min.copy(box.min), this.max.copy(box.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(target) {
    return this.isEmpty()
      ? target.set(0, 0, 0)
      : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty()
      ? target.set(0, 0, 0)
      : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    return this.min.min(point), this.max.max(point), this;
  }
  expandByVector(vector) {
    return this.min.sub(vector), this.max.add(vector), this;
  }
  expandByScalar(scalar) {
    return this.min.addScalar(-scalar), this.max.addScalar(scalar), this;
  }
  expandByObject(object) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let scope, i, l;
    return (
      (scope = this),
      object.updateMatrixWorld(!0),
      object.traverse((node) => {
        let attribute = node.geometry.attributes.position;
        if (void 0 !== attribute)
          for (i = 0, l = attribute.count; i < l; i++)
            v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld),
              scope.expandByPoint(v1);
      }),
      this
    );
  }
  containsPoint(point) {
    return !(
      point.x < this.min.x ||
      point.x > this.max.x ||
      point.y < this.min.y ||
      point.y > this.max.y ||
      point.z < this.min.z ||
      point.z > this.max.z
    );
  }
  containsBox(box) {
    return (
      this.min.x <= box.min.x &&
      box.max.x <= this.max.x &&
      this.min.y <= box.min.y &&
      box.max.y <= this.max.y &&
      this.min.z <= box.min.z &&
      box.max.z <= this.max.z
    );
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return !(
      box.max.x < this.min.x ||
      box.min.x > this.max.x ||
      box.max.y < this.min.y ||
      box.min.y > this.max.y ||
      box.max.z < this.min.z ||
      box.min.z > this.max.z
    );
  }
  intersectsSphere(sphere) {
    let closestPoint = this.V1 || new Vector3();
    return (
      (this.V1 = closestPoint),
      this.clampPoint(sphere.center, closestPoint),
      closestPoint.distanceToSquared(sphere.center) <=
        sphere.radius * sphere.radius
    );
  }
  intersectsPlane(plane) {
    let min, max;
    return (
      plane.normal.x > 0
        ? ((min = plane.normal.x * this.min.x),
          (max = plane.normal.x * this.max.x))
        : ((min = plane.normal.x * this.max.x),
          (max = plane.normal.x * this.min.x)),
      plane.normal.y > 0
        ? ((min += plane.normal.y * this.min.y),
          (max += plane.normal.y * this.max.y))
        : ((min += plane.normal.y * this.max.y),
          (max += plane.normal.y * this.min.y)),
      plane.normal.z > 0
        ? ((min += plane.normal.z * this.min.z),
          (max += plane.normal.z * this.max.z))
        : ((min += plane.normal.z * this.max.z),
          (max += plane.normal.z * this.min.z)),
      min <= plane.constant && max >= plane.constant
    );
  }
  intersectsTriangle(triangle) {
    function satForAxes(axes) {
      let i, j;
      for (i = 0, j = axes.length - 3; i <= j; i += 3) {
        testAxis.fromArray(axes, i);
        let r =
            extents.x * Math.abs(testAxis.x) +
            extents.y * Math.abs(testAxis.y) +
            extents.z * Math.abs(testAxis.z),
          p0 = v0.dot(testAxis),
          p1 = v1.dot(testAxis),
          p2 = v2.dot(testAxis);
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r)
          return !1;
      }
      return !0;
    }
    let v0 = this.V0 || new Vector3();
    this.V0 = v0;
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let v2 = this.V2 || new Vector3();
    this.V2 = v2;
    let f0 = this.F0 || new Vector3();
    this.F0 = f0;
    let f1 = this.F1 || new Vector3();
    this.F1 = f1;
    let f2 = this.F2 || new Vector3();
    this.F2 = f2;
    let testAxis = this.V3 || new Vector3();
    this.V3 = testAxis;
    let center = this.V4 || new Vector3();
    this.V4 = center;
    let extents = this.V5 || new Vector3();
    this.V5 = extents;
    let triangleNormal = this.V6 || new Vector3();
    if (((this.V6 = triangleNormal), this.isEmpty())) return !1;
    this.getCenter(center),
      extents.subVectors(this.max, center),
      v0.subVectors(triangle.a, center),
      v1.subVectors(triangle.b, center),
      v2.subVectors(triangle.c, center),
      f0.subVectors(v1, v0),
      f1.subVectors(v2, v1),
      f2.subVectors(v0, v2);
    let axes = [
      0,
      -f0.z,
      f0.y,
      0,
      -f1.z,
      f1.y,
      0,
      -f2.z,
      f2.y,
      f0.z,
      0,
      -f0.x,
      f1.z,
      0,
      -f1.x,
      f2.z,
      0,
      -f2.x,
      -f0.y,
      f0.x,
      0,
      -f1.y,
      f1.x,
      0,
      -f2.y,
      f2.x,
      0,
    ];
    return (
      !!satForAxes(axes) &&
      ((axes = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !!satForAxes(axes) &&
        (triangleNormal.crossVectors(f0, f1),
        (axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z]),
        satForAxes(axes)))
    );
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    let v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1),
      v1.copy(point).clamp(this.min, this.max).sub(point).length()
    );
  }
  getBoundingSphere(target) {
    let v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1),
      this.getCenter(target.center),
      (target.radius = 0.5 * this.getSize(v1).length()),
      target
    );
  }
  intersect(box) {
    return (
      this.min.max(box.min),
      this.max.min(box.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(box) {
    return this.min.min(box.min), this.max.max(box.max), this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    let m = matrix.elements,
      xax = m[0] * this.min.x,
      xay = m[1] * this.min.x,
      xaz = m[2] * this.min.x,
      xbx = m[0] * this.max.x,
      xby = m[1] * this.max.x,
      xbz = m[2] * this.max.x,
      yax = m[4] * this.min.y,
      yay = m[5] * this.min.y,
      yaz = m[6] * this.min.y,
      ybx = m[4] * this.max.y,
      yby = m[5] * this.max.y,
      ybz = m[6] * this.max.y,
      zax = m[8] * this.min.z,
      zay = m[9] * this.min.z,
      zaz = m[10] * this.min.z,
      zbx = m[8] * this.max.z,
      zby = m[9] * this.max.z,
      zbz = m[10] * this.max.z;
    return (
      (this.min.x =
        Math.min(xax, xbx) + Math.min(yax, ybx) + Math.min(zax, zbx) + m[12]),
      (this.min.y =
        Math.min(xay, xby) + Math.min(yay, yby) + Math.min(zay, zby) + m[13]),
      (this.min.z =
        Math.min(xaz, xbz) + Math.min(yaz, ybz) + Math.min(zaz, zbz) + m[14]),
      (this.max.x =
        Math.max(xax, xbx) + Math.max(yax, ybx) + Math.max(zax, zbx) + m[12]),
      (this.max.y =
        Math.max(xay, xby) + Math.max(yay, yby) + Math.max(zay, zby) + m[13]),
      (this.max.z =
        Math.max(xaz, xbz) + Math.max(yaz, ybz) + Math.max(zaz, zbz) + m[14]),
      this
    );
  }
  translate(offset) {
    return this.min.add(offset), this.max.add(offset), this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
  setFromBufferAttribute(attribute) {
    let minX = 1 / 0,
      minY = 1 / 0,
      minZ = 1 / 0,
      maxX = -1 / 0,
      maxY = -1 / 0,
      maxZ = -1 / 0;
    for (let i = 0, l = attribute.count; i < l; i++) {
      let x = attribute.array[3 * i + 0],
        y = attribute.array[3 * i + 1],
        z = attribute.array[3 * i + 2];
      x < minX && (minX = x),
        y < minY && (minY = y),
        z < minZ && (minZ = z),
        x > maxX && (maxX = x),
        y > maxY && (maxY = y),
        z > maxZ && (maxZ = z);
    }
    return this.min.set(minX, minY, minZ), this.max.set(maxX, maxY, maxZ), this;
  }
}
class Color {
  constructor(r, g, b) {
    return void 0 == r && void 0 == g && void 0 == b
      ? this.setRGB(1, 1, 1)
      : void 0 === g && void 0 === b
      ? this.set(r)
      : void this.setRGB(r, g, b);
  }
  set(value) {
    return (
      value && value instanceof Color
        ? this.copy(value)
        : "number" == typeof value
        ? this.setHex(value)
        : "string" == typeof value && this.setStyle(value),
      this
    );
  }
  setScalar(scalar) {
    return (this.r = scalar), (this.g = scalar), (this.b = scalar), this;
  }
  setHex(hex) {
    return (
      (hex = Math.floor(hex)),
      (this.r = ((hex >> 16) & 255) / 255),
      (this.g = ((hex >> 8) & 255) / 255),
      (this.b = (255 & hex) / 255),
      this
    );
  }
  setStyle(string) {
    return this.setHex(Number(string.replace("#", "0x")));
  }
  setRGB(r, g, b) {
    return (this.r = r), (this.g = g), (this.b = b), this;
  }
  setHSL(h, s, l) {
    function hue2rgb(p, q, t) {
      return (
        t < 0 && (t += 1),
        t > 1 && (t -= 1),
        t < 1 / 6
          ? p + 6 * (q - p) * t
          : t < 0.5
          ? q
          : t < 2 / 3
          ? p + 6 * (q - p) * (2 / 3 - t)
          : p
      );
    }
    if (
      ((h = Math.euclideanModulo(h, 1)),
      (s = Math.clamp(s, 0, 1)),
      (l = Math.clamp(l, 0, 1)),
      0 === s)
    )
      this.r = this.g = this.b = l;
    else {
      let p = l <= 0.5 ? l * (1 + s) : l + s - l * s,
        q = 2 * l - p;
      (this.r = hue2rgb(q, p, h + 1 / 3)),
        (this.g = hue2rgb(q, p, h)),
        (this.b = hue2rgb(q, p, h - 1 / 3));
    }
    return this;
  }
  clone() {
    return new Color(this.r, this.g, this.b);
  }
  copy(color) {
    return (this.r = color.r), (this.g = color.g), (this.b = color.b), this;
  }
  copyGammaToLinear(color, gammaFactor) {
    return (
      void 0 === gammaFactor && (gammaFactor = 2),
      (this.r = Math.pow(color.r, gammaFactor)),
      (this.g = Math.pow(color.g, gammaFactor)),
      (this.b = Math.pow(color.b, gammaFactor)),
      this
    );
  }
  copyLinearToGamma(color, gammaFactor) {
    void 0 === gammaFactor && (gammaFactor = 2);
    let safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    return (
      (this.r = Math.pow(color.r, safeInverse)),
      (this.g = Math.pow(color.g, safeInverse)),
      (this.b = Math.pow(color.b, safeInverse)),
      this
    );
  }
  convertGammaToLinear(gammaFactor) {
    return this.copyGammaToLinear(this, gammaFactor), this;
  }
  convertLinearToGamma(gammaFactor) {
    return this.copyLinearToGamma(this, gammaFactor), this;
  }
  getHex() {
    return (
      ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
    );
  }
  getHexString() {
    return "#" + ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL() {
    let target = this.target || {};
    this.target = target;
    let hue,
      saturation,
      r = this.r,
      g = this.g,
      b = this.b,
      max = Math.max(r, g, b),
      min = Math.min(r, g, b),
      lightness = (min + max) / 2;
    if (min === max) (hue = 0), (saturation = 0);
    else {
      let delta = max - min;
      switch (
        ((saturation =
          lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min)),
        max)
      ) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
      }
      hue /= 6;
    }
    return (
      (target.h = hue), (target.s = saturation), (target.l = lightness), target
    );
  }
  tween(color, time, ease, delay) {
    const _this = this;
    _this.tweenObj || (_this.tweenObj = { v: 0 }), (_this.tweenObj.v = 0);
    let clone = this.clone();
    return TweenManager.tween(
      _this.tweenObj,
      { v: 1 },
      time,
      ease,
      delay
    ).onUpdate((_) => {
      _this.copy(clone).lerp(color, _this.tweenObj.v);
    });
  }
  offsetHSL(h, s, l) {
    let hsl = this.getHSL();
    return (
      (hsl.h += h),
      (hsl.s += s),
      (hsl.l += l),
      this.setHSL(hsl.h, hsl.s, hsl.l),
      this
    );
  }
  add(color) {
    return (this.r += color.r), (this.g += color.g), (this.b += color.b), this;
  }
  addColors(color1, color2) {
    return (
      (this.r = color1.r + color2.r),
      (this.g = color1.g + color2.g),
      (this.b = color1.b + color2.b),
      this
    );
  }
  addScalar(s) {
    return (this.r += s), (this.g += s), (this.b += s), this;
  }
  sub(color) {
    return (
      (this.r = Math.max(0, this.r - color.r)),
      (this.g = Math.max(0, this.g - color.g)),
      (this.b = Math.max(0, this.b - color.b)),
      this
    );
  }
  multiply(color) {
    return (this.r *= color.r), (this.g *= color.g), (this.b *= color.b), this;
  }
  multiplyScalar(s) {
    return (this.r *= s), (this.g *= s), (this.b *= s), this;
  }
  lerp(color, alpha) {
    return (
      (this.r += (color.r - this.r) * alpha),
      (this.g += (color.g - this.g) * alpha),
      (this.b += (color.b - this.b) * alpha),
      this
    );
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset) {
    return (
      void 0 === offset && (offset = 0),
      (this.r = array[offset]),
      (this.g = array[offset + 1]),
      (this.b = array[offset + 2]),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this.r),
      (array[offset + 1] = this.g),
      (array[offset + 2] = this.b),
      array
    );
  }
}
class Cylindrical {
  constructor(radius = 1, theta = 0, y = 0) {
    (this.radius = radius), (this.theta = theta), (this.y = y);
  }
  set(radius, theta, y) {
    return (this.radius = radius), (this.theta = theta), (this.y = y), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(other) {
    return (
      (this.radius = other.radius),
      (this.theta = other.theta),
      (this.y = other.y),
      this
    );
  }
  setFromVector3(vec3) {
    return (
      (this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z)),
      (this.theta = Math.atan2(vec3.x, vec3.z)),
      (this.y = vec3.y),
      this
    );
  }
}
class Euler {
  constructor(x, y, z, order) {
    (this._x = x || 0),
      (this._y = y || 0),
      (this._z = z || 0),
      (this._order = order || "XYZ"),
      (this.isEuler = !0);
  }
  set x(value) {
    (this._x = value), this.onChangeCallback();
  }
  get x() {
    return this._x;
  }
  set y(value) {
    (this._y = value), this.onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set z(value) {
    (this._z = value), this.onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set order(value) {
    (this._order = value), this.onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set(x, y, z, order) {
    return (
      (this._x = x),
      (this._y = y),
      (this._z = z),
      (this._order = order || this._order),
      this.onChangeCallback(),
      this
    );
  }
  clone() {
    return new Euler(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    return (
      (this._x = euler._x),
      (this._y = euler._y),
      (this._z = euler._z),
      (this._order = euler._order),
      this.onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(m, order, update) {
    let clamp = Math.clamp,
      te = m.elements,
      m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10];
    return (
      "XYZ" === (order = order || this._order)
        ? ((this._y = Math.asin(clamp(m13, -1, 1))),
          Math.abs(m13) < 0.99999
            ? ((this._x = Math.atan2(-m23, m33)),
              (this._z = Math.atan2(-m12, m11)))
            : ((this._x = Math.atan2(m32, m22)), (this._z = 0)))
        : "YXZ" === order
        ? ((this._x = Math.asin(-clamp(m23, -1, 1))),
          Math.abs(m23) < 0.99999
            ? ((this._y = Math.atan2(m13, m33)),
              (this._z = Math.atan2(m21, m22)))
            : ((this._y = Math.atan2(-m31, m11)), (this._z = 0)))
        : "ZXY" === order
        ? ((this._x = Math.asin(clamp(m32, -1, 1))),
          Math.abs(m32) < 0.99999
            ? ((this._y = Math.atan2(-m31, m33)),
              (this._z = Math.atan2(-m12, m22)))
            : ((this._y = 0), (this._z = Math.atan2(m21, m11))))
        : "ZYX" === order
        ? ((this._y = Math.asin(-clamp(m31, -1, 1))),
          Math.abs(m31) < 0.99999
            ? ((this._x = Math.atan2(m32, m33)),
              (this._z = Math.atan2(m21, m11)))
            : ((this._x = 0), (this._z = Math.atan2(-m12, m22))))
        : "YZX" === order
        ? ((this._z = Math.asin(clamp(m21, -1, 1))),
          Math.abs(m21) < 0.99999
            ? ((this._x = Math.atan2(-m23, m22)),
              (this._y = Math.atan2(-m31, m11)))
            : ((this._x = 0), (this._y = Math.atan2(m13, m33))))
        : "XZY" === order &&
          ((this._z = Math.asin(-clamp(m12, -1, 1))),
          Math.abs(m12) < 0.99999
            ? ((this._x = Math.atan2(m32, m22)),
              (this._y = Math.atan2(m13, m11)))
            : ((this._x = Math.atan2(-m23, m33)), (this._y = 0))),
      (this._order = order),
      !1 !== update && this.onChangeCallback(),
      this
    );
  }
  setFromQuaternion(q, order, update) {
    let matrix = this.M1 || new Matrix4();
    return (
      (this.M1 = matrix),
      matrix.makeRotationFromQuaternion(q),
      this.setFromRotationMatrix(matrix, order, update)
    );
  }
  setFromVector3(v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  }
  reorder(newOrder) {
    let q = this.Q1 || new Quaternion();
    return (
      (this.Q1 = q), q.setFromEuler(this), this.setFromQuaternion(q, newOrder)
    );
  }
  lerp(euler, alpha) {
    (this._x += (euler._x - this._x) * alpha),
      (this._y += (euler._y - this._y) * alpha),
      (this._z += (euler._z - this._z) * alpha),
      this.onChangeCallback();
  }
  equals(euler) {
    return (
      euler._x === this._x &&
      euler._y === this._y &&
      euler._z === this._z &&
      euler._order === this._order
    );
  }
  fromArray(array) {
    return (
      (this._x = array[0]),
      (this._y = array[1]),
      (this._z = array[2]),
      void 0 !== array[3] && (this._order = array[3]),
      this.onChangeCallback(),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this._x),
      (array[offset + 1] = this._y),
      (array[offset + 2] = this._z),
      (array[offset + 3] = this._order),
      array
    );
  }
  toVector3(optionalResult) {
    return optionalResult
      ? optionalResult.set(this._x, this._y, this._z)
      : new Vector3(this._x, this._y, this._z);
  }
  onChange(callback) {
    this.onChangeCallback = callback;
  }
  onChangeCallback() {}
}
(Euler.DefaultOrder = "XYZ"),
  (Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
class Frustum {
  constructor(p0, p1, p2, p3, p4, p5) {
    this.planes = [
      void 0 !== p0 ? p0 : new Plane(),
      void 0 !== p1 ? p1 : new Plane(),
      void 0 !== p2 ? p2 : new Plane(),
      void 0 !== p3 ? p3 : new Plane(),
      void 0 !== p4 ? p4 : new Plane(),
      void 0 !== p5 ? p5 : new Plane(),
    ];
  }
  set(p0, p1, p2, p3, p4, p5) {
    let planes = this.planes;
    return (
      planes[0].copy(p0),
      planes[1].copy(p1),
      planes[2].copy(p2),
      planes[3].copy(p3),
      planes[4].copy(p4),
      planes[5].copy(p5),
      this
    );
  }
  clone() {
    return new Frustum().copy(this);
  }
  copy(frustum) {
    let planes = this.planes;
    for (let i = 0; i < 6; i++) planes[i].copy(frustum.planes[i]);
    return this;
  }
  setFromMatrix(m) {
    let planes = this.planes,
      me = m.elements,
      me0 = me[0],
      me1 = me[1],
      me2 = me[2],
      me3 = me[3],
      me4 = me[4],
      me5 = me[5],
      me6 = me[6],
      me7 = me[7],
      me8 = me[8],
      me9 = me[9],
      me10 = me[10],
      me11 = me[11],
      me12 = me[12],
      me13 = me[13],
      me14 = me[14],
      me15 = me[15];
    return (
      planes[0]
        .setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12)
        .normalize(),
      planes[1]
        .setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12)
        .normalize(),
      planes[2]
        .setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13)
        .normalize(),
      planes[3]
        .setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13)
        .normalize(),
      planes[4]
        .setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14)
        .normalize(),
      planes[5]
        .setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14)
        .normalize(),
      this
    );
  }
  setFromCamera(camera) {
    let matrix = this.M1 || new Matrix4();
    return (
      (this.M1 = matrix),
      matrix.multiplyMatrices(
        camera.projectionMatrix,
        camera.matrixWorldInverse
      ),
      this.setFromMatrix(matrix)
    );
  }
  intersectsObject(object) {
    let sphere = this.S1 || new Sphere();
    this.S1 = sphere;
    let geometry = object.geometry;
    return (
      null === geometry.boundingSphere && geometry.computeBoundingSphere(),
      sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld),
      this.intersectsSphere(sphere)
    );
  }
  intersectsSphere(sphere) {
    let planes = this.planes,
      center = sphere.center,
      negRadius = -sphere.radius;
    for (let i = 0; i < 6; i++)
      if (planes[i].distanceToPoint(center) < negRadius) return !1;
    return !0;
  }
  intersectsBox(box) {
    let p1 = this.V1 || new Vector3(),
      p2 = this.V2 || new Vector3();
    (this.V1 = p1), (this.V2 = p2);
    let planes = this.planes;
    for (let i = 0; i < 6; i++) {
      let plane = planes[i];
      (p1.x = plane.normal.x > 0 ? box.min.x : box.max.x),
        (p2.x = plane.normal.x > 0 ? box.max.x : box.min.x),
        (p1.y = plane.normal.y > 0 ? box.min.y : box.max.y),
        (p2.y = plane.normal.y > 0 ? box.max.y : box.min.y),
        (p1.z = plane.normal.z > 0 ? box.min.z : box.max.z),
        (p2.z = plane.normal.z > 0 ? box.max.z : box.min.z);
      let d1 = plane.distanceToPoint(p1),
        d2 = plane.distanceToPoint(p2);
      if (d1 < 0 && d2 < 0) return !1;
    }
    return !0;
  }
  containsPoint(point) {
    let planes = this.planes;
    for (let i = 0; i < 6; i++)
      if (planes[i].distanceToPoint(point) < 0) return !1;
    return !0;
  }
}
class Line3 {
  constructor(start = new Vector3(), end = new Vector3()) {
    (this.start = start), (this.end = end);
  }
  set(start, end) {
    return this.start.copy(start), this.end.copy(end), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(line) {
    return this.start.copy(line.start), this.end.copy(line.end), this;
  }
  getCenter(target = new Vector3()) {
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target = new Vector3()) {
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, target = new Vector3()) {
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    let startP = this.V1 || new Vector3(),
      startEnd = this.V2 || new Vector3();
    (this.V1 = startP),
      (this.V2 = startEnd),
      startP.subVectors(point, this.start),
      startEnd.subVectors(this.end, this.start);
    let startEnd2 = startEnd.dot(startEnd),
      t = startEnd.dot(startP) / startEnd2;
    return clampToLine && (t = Math.clamp(t, 0, 1)), t;
  }
  closestPointToPoint(point, clampToLine, target = new Vector3()) {
    let t = this.closestPointToPointParameter(point, clampToLine);
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  applyMatrix4(matrix) {
    return this.start.applyMatrix4(matrix), this.end.applyMatrix4(matrix), this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
}
class Matrix3 {
  constructor() {
    this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    let te = this.elements;
    return (
      (te[0] = n11),
      (te[1] = n21),
      (te[2] = n31),
      (te[3] = n12),
      (te[4] = n22),
      (te[5] = n32),
      (te[6] = n13),
      (te[7] = n23),
      (te[8] = n33),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  clone() {
    return new Matrix3().fromArray(this.elements);
  }
  copy(m) {
    let te = this.elements,
      me = m.elements;
    return (
      (te[0] = me[0]),
      (te[1] = me[1]),
      (te[2] = me[2]),
      (te[3] = me[3]),
      (te[4] = me[4]),
      (te[5] = me[5]),
      (te[6] = me[6]),
      (te[7] = me[7]),
      (te[8] = me[8]),
      this
    );
  }
  setFromMatrix4(m) {
    let me = m.elements;
    return (
      this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]),
      this
    );
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    let ae = a.elements,
      be = b.elements,
      te = this.elements,
      a11 = ae[0],
      a12 = ae[3],
      a13 = ae[6],
      a21 = ae[1],
      a22 = ae[4],
      a23 = ae[7],
      a31 = ae[2],
      a32 = ae[5],
      a33 = ae[8],
      b11 = be[0],
      b12 = be[3],
      b13 = be[6],
      b21 = be[1],
      b22 = be[4],
      b23 = be[7],
      b31 = be[2],
      b32 = be[5],
      b33 = be[8];
    return (
      (te[0] = a11 * b11 + a12 * b21 + a13 * b31),
      (te[3] = a11 * b12 + a12 * b22 + a13 * b32),
      (te[6] = a11 * b13 + a12 * b23 + a13 * b33),
      (te[1] = a21 * b11 + a22 * b21 + a23 * b31),
      (te[4] = a21 * b12 + a22 * b22 + a23 * b32),
      (te[7] = a21 * b13 + a22 * b23 + a23 * b33),
      (te[2] = a31 * b11 + a32 * b21 + a33 * b31),
      (te[5] = a31 * b12 + a32 * b22 + a33 * b32),
      (te[8] = a31 * b13 + a32 * b23 + a33 * b33),
      this
    );
  }
  multiplyScalar(s) {
    let te = this.elements;
    return (
      (te[0] *= s),
      (te[3] *= s),
      (te[6] *= s),
      (te[1] *= s),
      (te[4] *= s),
      (te[7] *= s),
      (te[2] *= s),
      (te[5] *= s),
      (te[8] *= s),
      this
    );
  }
  determinant() {
    let te = this.elements,
      a = te[0],
      b = te[1],
      c = te[2],
      d = te[3],
      e = te[4],
      f = te[5],
      g = te[6],
      h = te[7],
      i = te[8];
    return (
      a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g
    );
  }
  getInverse(matrix, throwOnDegenerate) {
    let me = matrix.elements,
      te = this.elements,
      n11 = me[0],
      n21 = me[1],
      n31 = me[2],
      n12 = me[3],
      n22 = me[4],
      n32 = me[5],
      n13 = me[6],
      n23 = me[7],
      n33 = me[8],
      t11 = n33 * n22 - n32 * n23,
      t12 = n32 * n13 - n33 * n12,
      t13 = n23 * n12 - n22 * n13,
      det = n11 * t11 + n21 * t12 + n31 * t13;
    if (0 === det) {
      if (!0 === throwOnDegenerate)
        throw new Error(".getInverse() can't invert matrix, determinant is 0");
      return this.identity();
    }
    let detInv = 1 / det;
    return (
      (te[0] = t11 * detInv),
      (te[1] = (n31 * n23 - n33 * n21) * detInv),
      (te[2] = (n32 * n21 - n31 * n22) * detInv),
      (te[3] = t12 * detInv),
      (te[4] = (n33 * n11 - n31 * n13) * detInv),
      (te[5] = (n31 * n12 - n32 * n11) * detInv),
      (te[6] = t13 * detInv),
      (te[7] = (n21 * n13 - n23 * n11) * detInv),
      (te[8] = (n22 * n11 - n21 * n12) * detInv),
      this
    );
  }
  transpose() {
    let tmp,
      m = this.elements;
    return (
      (tmp = m[1]),
      (m[1] = m[3]),
      (m[3] = tmp),
      (tmp = m[2]),
      (m[2] = m[6]),
      (m[6] = tmp),
      (tmp = m[5]),
      (m[5] = m[7]),
      (m[7] = tmp),
      this
    );
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    let c = Math.cos(rotation),
      s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
  }
  scale(sx, sy) {
    let te = this.elements;
    return (
      (te[0] *= sx),
      (te[3] *= sx),
      (te[6] *= sx),
      (te[1] *= sy),
      (te[4] *= sy),
      (te[7] *= sy),
      this
    );
  }
  rotate(theta) {
    let c = Math.cos(theta),
      s = Math.sin(theta),
      te = this.elements,
      a11 = te[0],
      a12 = te[3],
      a13 = te[6],
      a21 = te[1],
      a22 = te[4],
      a23 = te[7];
    return (
      (te[0] = c * a11 + s * a21),
      (te[3] = c * a12 + s * a22),
      (te[6] = c * a13 + s * a23),
      (te[1] = -s * a11 + c * a21),
      (te[4] = -s * a12 + c * a22),
      (te[7] = -s * a13 + c * a23),
      this
    );
  }
  translate(tx, ty) {
    let te = this.elements;
    return (
      (te[0] += tx * te[2]),
      (te[3] += tx * te[5]),
      (te[6] += tx * te[8]),
      (te[1] += ty * te[2]),
      (te[4] += ty * te[5]),
      (te[7] += ty * te[8]),
      this
    );
  }
  equals(matrix) {
    let te = this.elements,
      me = matrix.elements;
    for (let i = 0; i < 9; i++) if (te[i] !== me[i]) return !1;
    return !0;
  }
  fromArray(array, offset) {
    void 0 === offset && (offset = 0);
    for (let i = 0; i < 9; i++) this.elements[i] = array[i + offset];
    return this;
  }
  toArray(array, offset) {
    void 0 === array && (array = []), void 0 === offset && (offset = 0);
    let te = this.elements;
    return (
      (array[offset] = te[0]),
      (array[offset + 1] = te[1]),
      (array[offset + 2] = te[2]),
      (array[offset + 3] = te[3]),
      (array[offset + 4] = te[4]),
      (array[offset + 5] = te[5]),
      (array[offset + 6] = te[6]),
      (array[offset + 7] = te[7]),
      (array[offset + 8] = te[8]),
      array
    );
  }
  applyToBufferAttribute(attribute) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    for (let i = 0, l = attribute.count; i < l; i++)
      (v1.x = attribute.array[3 * i + 0]),
        (v1.y = attribute.array[3 * i + 1]),
        (v1.z = attribute.array[3 * i + 2]),
        v1.applyMatrix3(this),
        (attribute.array[3 * i + 0] = v1.x),
        (attribute.array[3 * i + 1] = v1.y),
        (attribute.array[3 * i + 2] = v1.z);
    return attribute;
  }
}
class Matrix4 {
  constructor() {
    this.elements = new Float32Array([
      1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
    ]);
  }
  set(
    n11,
    n12,
    n13,
    n14,
    n21,
    n22,
    n23,
    n24,
    n31,
    n32,
    n33,
    n34,
    n41,
    n42,
    n43,
    n44
  ) {
    let te = this.elements;
    return (
      (te[0] = n11),
      (te[4] = n12),
      (te[8] = n13),
      (te[12] = n14),
      (te[1] = n21),
      (te[5] = n22),
      (te[9] = n23),
      (te[13] = n24),
      (te[2] = n31),
      (te[6] = n32),
      (te[10] = n33),
      (te[14] = n34),
      (te[3] = n41),
      (te[7] = n42),
      (te[11] = n43),
      (te[15] = n44),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    let te = this.elements,
      me = m.elements;
    return (
      (te[0] = me[0]),
      (te[1] = me[1]),
      (te[2] = me[2]),
      (te[3] = me[3]),
      (te[4] = me[4]),
      (te[5] = me[5]),
      (te[6] = me[6]),
      (te[7] = me[7]),
      (te[8] = me[8]),
      (te[9] = me[9]),
      (te[10] = me[10]),
      (te[11] = me[11]),
      (te[12] = me[12]),
      (te[13] = me[13]),
      (te[14] = me[14]),
      (te[15] = me[15]),
      this
    );
  }
  copyPosition(m) {
    let te = this.elements,
      me = m.elements;
    return (te[12] = me[12]), (te[13] = me[13]), (te[14] = me[14]), this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    return (
      xAxis.setFromMatrixColumn(this, 0),
      yAxis.setFromMatrixColumn(this, 1),
      zAxis.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(xAxis, yAxis, zAxis) {
    return (
      this.set(
        xAxis.x,
        yAxis.x,
        zAxis.x,
        0,
        xAxis.y,
        yAxis.y,
        zAxis.y,
        0,
        xAxis.z,
        yAxis.z,
        zAxis.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(m) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let te = this.elements,
      me = m.elements,
      scaleX = 1 / v1.setFromMatrixColumn(m, 0).length(),
      scaleY = 1 / v1.setFromMatrixColumn(m, 1).length(),
      scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
    return (
      (te[0] = me[0] * scaleX),
      (te[1] = me[1] * scaleX),
      (te[2] = me[2] * scaleX),
      (te[4] = me[4] * scaleY),
      (te[5] = me[5] * scaleY),
      (te[6] = me[6] * scaleY),
      (te[8] = me[8] * scaleZ),
      (te[9] = me[9] * scaleZ),
      (te[10] = me[10] * scaleZ),
      this
    );
  }
  makeRotationFromEuler(euler) {
    let te = this.elements,
      x = euler.x,
      y = euler.y,
      z = euler.z,
      a = Math.cos(x),
      b = Math.sin(x),
      c = Math.cos(y),
      d = Math.sin(y),
      e = Math.cos(z),
      f = Math.sin(z);
    if ("XYZ" === euler.order) {
      let ae = a * e,
        af = a * f,
        be = b * e,
        bf = b * f;
      (te[0] = c * e),
        (te[4] = -c * f),
        (te[8] = d),
        (te[1] = af + be * d),
        (te[5] = ae - bf * d),
        (te[9] = -b * c),
        (te[2] = bf - ae * d),
        (te[6] = be + af * d),
        (te[10] = a * c);
    } else if ("YXZ" === euler.order) {
      let ce = c * e,
        cf = c * f,
        de = d * e,
        df = d * f;
      (te[0] = ce + df * b),
        (te[4] = de * b - cf),
        (te[8] = a * d),
        (te[1] = a * f),
        (te[5] = a * e),
        (te[9] = -b),
        (te[2] = cf * b - de),
        (te[6] = df + ce * b),
        (te[10] = a * c);
    } else if ("ZXY" === euler.order) {
      let ce = c * e,
        cf = c * f,
        de = d * e,
        df = d * f;
      (te[0] = ce - df * b),
        (te[4] = -a * f),
        (te[8] = de + cf * b),
        (te[1] = cf + de * b),
        (te[5] = a * e),
        (te[9] = df - ce * b),
        (te[2] = -a * d),
        (te[6] = b),
        (te[10] = a * c);
    } else if ("ZYX" === euler.order) {
      let ae = a * e,
        af = a * f,
        be = b * e,
        bf = b * f;
      (te[0] = c * e),
        (te[4] = be * d - af),
        (te[8] = ae * d + bf),
        (te[1] = c * f),
        (te[5] = bf * d + ae),
        (te[9] = af * d - be),
        (te[2] = -d),
        (te[6] = b * c),
        (te[10] = a * c);
    } else if ("YZX" === euler.order) {
      let ac = a * c,
        ad = a * d,
        bc = b * c,
        bd = b * d;
      (te[0] = c * e),
        (te[4] = bd - ac * f),
        (te[8] = bc * f + ad),
        (te[1] = f),
        (te[5] = a * e),
        (te[9] = -b * e),
        (te[2] = -d * e),
        (te[6] = ad * f + bc),
        (te[10] = ac - bd * f);
    } else if ("XZY" === euler.order) {
      let ac = a * c,
        ad = a * d,
        bc = b * c,
        bd = b * d;
      (te[0] = c * e),
        (te[4] = -f),
        (te[8] = d * e),
        (te[1] = ac * f + bd),
        (te[5] = a * e),
        (te[9] = ad * f - bc),
        (te[2] = bc * f - ad),
        (te[6] = b * e),
        (te[10] = bd * f + ac);
    }
    return (
      (te[3] = 0),
      (te[7] = 0),
      (te[11] = 0),
      (te[12] = 0),
      (te[13] = 0),
      (te[14] = 0),
      (te[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(q) {
    let te = this.elements,
      x = q._x,
      y = q._y,
      z = q._z,
      w = q._w,
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,
      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2;
    return (
      (te[0] = 1 - (yy + zz)),
      (te[4] = xy - wz),
      (te[8] = xz + wy),
      (te[1] = xy + wz),
      (te[5] = 1 - (xx + zz)),
      (te[9] = yz - wx),
      (te[2] = xz - wy),
      (te[6] = yz + wx),
      (te[10] = 1 - (xx + yy)),
      (te[3] = 0),
      (te[7] = 0),
      (te[11] = 0),
      (te[12] = 0),
      (te[13] = 0),
      (te[14] = 0),
      (te[15] = 1),
      this
    );
  }
  lookAt(eye, target, up) {
    let x = this.V1 || new Vector3(),
      y = this.V2 || new Vector3(),
      z = this.V3 || new Vector3();
    (this.V1 = x), (this.V2 = y), (this.V3 = z);
    let te = this.elements;
    return (
      z.subVectors(eye, target),
      0 === z.lengthSq() && (z.z = 1),
      z.normalize(),
      x.crossVectors(up, z),
      0 === x.lengthSq() &&
        (1 === Math.abs(up.z) ? (z.x += 1e-4) : (z.z += 1e-4),
        z.normalize(),
        x.crossVectors(up, z)),
      x.normalize(),
      y.crossVectors(z, x),
      (te[0] = x.x),
      (te[4] = y.x),
      (te[8] = z.x),
      (te[1] = x.y),
      (te[5] = y.y),
      (te[9] = z.y),
      (te[2] = x.z),
      (te[6] = y.z),
      (te[10] = z.z),
      this
    );
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    let ae = a.elements,
      be = b.elements,
      te = this.elements,
      a11 = ae[0],
      a12 = ae[4],
      a13 = ae[8],
      a14 = ae[12],
      a21 = ae[1],
      a22 = ae[5],
      a23 = ae[9],
      a24 = ae[13],
      a31 = ae[2],
      a32 = ae[6],
      a33 = ae[10],
      a34 = ae[14],
      a41 = ae[3],
      a42 = ae[7],
      a43 = ae[11],
      a44 = ae[15],
      b11 = be[0],
      b12 = be[4],
      b13 = be[8],
      b14 = be[12],
      b21 = be[1],
      b22 = be[5],
      b23 = be[9],
      b24 = be[13],
      b31 = be[2],
      b32 = be[6],
      b33 = be[10],
      b34 = be[14],
      b41 = be[3],
      b42 = be[7],
      b43 = be[11],
      b44 = be[15];
    return (
      (te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41),
      (te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42),
      (te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43),
      (te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44),
      (te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41),
      (te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42),
      (te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43),
      (te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44),
      (te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41),
      (te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42),
      (te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43),
      (te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44),
      (te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41),
      (te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42),
      (te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43),
      (te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44),
      this
    );
  }
  multiplyScalar(s) {
    let te = this.elements;
    return (
      (te[0] *= s),
      (te[4] *= s),
      (te[8] *= s),
      (te[12] *= s),
      (te[1] *= s),
      (te[5] *= s),
      (te[9] *= s),
      (te[13] *= s),
      (te[2] *= s),
      (te[6] *= s),
      (te[10] *= s),
      (te[14] *= s),
      (te[3] *= s),
      (te[7] *= s),
      (te[11] *= s),
      (te[15] *= s),
      this
    );
  }
  determinant() {
    let te = this.elements,
      n11 = te[0],
      n12 = te[4],
      n13 = te[8],
      n14 = te[12],
      n21 = te[1],
      n22 = te[5],
      n23 = te[9],
      n24 = te[13],
      n31 = te[2],
      n32 = te[6],
      n33 = te[10],
      n34 = te[14];
    return (
      te[3] *
        (+n14 * n23 * n32 -
          n13 * n24 * n32 -
          n14 * n22 * n33 +
          n12 * n24 * n33 +
          n13 * n22 * n34 -
          n12 * n23 * n34) +
      te[7] *
        (+n11 * n23 * n34 -
          n11 * n24 * n33 +
          n14 * n21 * n33 -
          n13 * n21 * n34 +
          n13 * n24 * n31 -
          n14 * n23 * n31) +
      te[11] *
        (+n11 * n24 * n32 -
          n11 * n22 * n34 -
          n14 * n21 * n32 +
          n12 * n21 * n34 +
          n14 * n22 * n31 -
          n12 * n24 * n31) +
      te[15] *
        (-n13 * n22 * n31 -
          n11 * n23 * n32 +
          n11 * n22 * n33 +
          n13 * n21 * n32 -
          n12 * n21 * n33 +
          n12 * n23 * n31)
    );
  }
  transpose() {
    let tmp,
      te = this.elements;
    return (
      (tmp = te[1]),
      (te[1] = te[4]),
      (te[4] = tmp),
      (tmp = te[2]),
      (te[2] = te[8]),
      (te[8] = tmp),
      (tmp = te[6]),
      (te[6] = te[9]),
      (te[9] = tmp),
      (tmp = te[3]),
      (te[3] = te[12]),
      (te[12] = tmp),
      (tmp = te[7]),
      (te[7] = te[13]),
      (te[13] = tmp),
      (tmp = te[11]),
      (te[11] = te[14]),
      (te[14] = tmp),
      this
    );
  }
  setPosition(v) {
    let te = this.elements;
    return (te[12] = v.x), (te[13] = v.y), (te[14] = v.z), this;
  }
  getInverse(m, throwOnDegenerate) {
    let te = this.elements,
      me = m.elements,
      n11 = me[0],
      n21 = me[1],
      n31 = me[2],
      n41 = me[3],
      n12 = me[4],
      n22 = me[5],
      n32 = me[6],
      n42 = me[7],
      n13 = me[8],
      n23 = me[9],
      n33 = me[10],
      n43 = me[11],
      n14 = me[12],
      n24 = me[13],
      n34 = me[14],
      n44 = me[15],
      t11 =
        n23 * n34 * n42 -
        n24 * n33 * n42 +
        n24 * n32 * n43 -
        n22 * n34 * n43 -
        n23 * n32 * n44 +
        n22 * n33 * n44,
      t12 =
        n14 * n33 * n42 -
        n13 * n34 * n42 -
        n14 * n32 * n43 +
        n12 * n34 * n43 +
        n13 * n32 * n44 -
        n12 * n33 * n44,
      t13 =
        n13 * n24 * n42 -
        n14 * n23 * n42 +
        n14 * n22 * n43 -
        n12 * n24 * n43 -
        n13 * n22 * n44 +
        n12 * n23 * n44,
      t14 =
        n14 * n23 * n32 -
        n13 * n24 * n32 -
        n14 * n22 * n33 +
        n12 * n24 * n33 +
        n13 * n22 * n34 -
        n12 * n23 * n34,
      det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (0 === det) {
      if (!0 === throwOnDegenerate)
        throw new Error(".getInverse() can't invert matrix, determinant is 0");
      return this.identity();
    }
    let detInv = 1 / det;
    return (
      (te[0] = t11 * detInv),
      (te[1] =
        (n24 * n33 * n41 -
          n23 * n34 * n41 -
          n24 * n31 * n43 +
          n21 * n34 * n43 +
          n23 * n31 * n44 -
          n21 * n33 * n44) *
        detInv),
      (te[2] =
        (n22 * n34 * n41 -
          n24 * n32 * n41 +
          n24 * n31 * n42 -
          n21 * n34 * n42 -
          n22 * n31 * n44 +
          n21 * n32 * n44) *
        detInv),
      (te[3] =
        (n23 * n32 * n41 -
          n22 * n33 * n41 -
          n23 * n31 * n42 +
          n21 * n33 * n42 +
          n22 * n31 * n43 -
          n21 * n32 * n43) *
        detInv),
      (te[4] = t12 * detInv),
      (te[5] =
        (n13 * n34 * n41 -
          n14 * n33 * n41 +
          n14 * n31 * n43 -
          n11 * n34 * n43 -
          n13 * n31 * n44 +
          n11 * n33 * n44) *
        detInv),
      (te[6] =
        (n14 * n32 * n41 -
          n12 * n34 * n41 -
          n14 * n31 * n42 +
          n11 * n34 * n42 +
          n12 * n31 * n44 -
          n11 * n32 * n44) *
        detInv),
      (te[7] =
        (n12 * n33 * n41 -
          n13 * n32 * n41 +
          n13 * n31 * n42 -
          n11 * n33 * n42 -
          n12 * n31 * n43 +
          n11 * n32 * n43) *
        detInv),
      (te[8] = t13 * detInv),
      (te[9] =
        (n14 * n23 * n41 -
          n13 * n24 * n41 -
          n14 * n21 * n43 +
          n11 * n24 * n43 +
          n13 * n21 * n44 -
          n11 * n23 * n44) *
        detInv),
      (te[10] =
        (n12 * n24 * n41 -
          n14 * n22 * n41 +
          n14 * n21 * n42 -
          n11 * n24 * n42 -
          n12 * n21 * n44 +
          n11 * n22 * n44) *
        detInv),
      (te[11] =
        (n13 * n22 * n41 -
          n12 * n23 * n41 -
          n13 * n21 * n42 +
          n11 * n23 * n42 +
          n12 * n21 * n43 -
          n11 * n22 * n43) *
        detInv),
      (te[12] = t14 * detInv),
      (te[13] =
        (n13 * n24 * n31 -
          n14 * n23 * n31 +
          n14 * n21 * n33 -
          n11 * n24 * n33 -
          n13 * n21 * n34 +
          n11 * n23 * n34) *
        detInv),
      (te[14] =
        (n14 * n22 * n31 -
          n12 * n24 * n31 -
          n14 * n21 * n32 +
          n11 * n24 * n32 +
          n12 * n21 * n34 -
          n11 * n22 * n34) *
        detInv),
      (te[15] =
        (n12 * n23 * n31 -
          n13 * n22 * n31 +
          n13 * n21 * n32 -
          n11 * n23 * n32 -
          n12 * n21 * n33 +
          n11 * n22 * n33) *
        detInv),
      this
    );
  }
  scale(v) {
    let te = this.elements,
      x = v.x,
      y = v.y,
      z = v.z;
    return (
      (te[0] *= x),
      (te[4] *= y),
      (te[8] *= z),
      (te[1] *= x),
      (te[5] *= y),
      (te[9] *= z),
      (te[2] *= x),
      (te[6] *= y),
      (te[10] *= z),
      (te[3] *= x),
      (te[7] *= y),
      (te[11] *= z),
      this
    );
  }
  getMaxScaleOnAxis() {
    let te = this.elements,
      scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2],
      scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6],
      scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1), this;
  }
  makeRotationX(theta) {
    let c = Math.cos(theta),
      s = Math.sin(theta);
    return this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(theta) {
    let c = Math.cos(theta),
      s = Math.sin(theta);
    return this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(theta) {
    let c = Math.cos(theta),
      s = Math.sin(theta);
    return this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(axis, angle) {
    let c = Math.cos(angle),
      s = Math.sin(angle),
      t = 1 - c,
      x = axis.x,
      y = axis.y,
      z = axis.z,
      tx = t * x,
      ty = t * y;
    return (
      this.set(
        tx * x + c,
        tx * y - s * z,
        tx * z + s * y,
        0,
        tx * y + s * z,
        ty * y + c,
        ty * z - s * x,
        0,
        tx * z - s * y,
        ty * z + s * x,
        t * z * z + c,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(x, y, z) {
    return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1), this;
  }
  makeShear(x, y, z) {
    return this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1), this;
  }
  compose(position, quaternion, scale) {
    return (
      this.makeRotationFromQuaternion(quaternion),
      this.scale(scale),
      this.setPosition(position),
      this
    );
  }
  decompose(position, quaternion, scale) {
    let vector = this.V1 || new Vector3();
    this.V1 = vector;
    let matrix = this.M1 || new Matrix4();
    this.M1 = matrix;
    let te = this.elements,
      sx = vector.set(te[0], te[1], te[2]).length(),
      sy = vector.set(te[4], te[5], te[6]).length(),
      sz = vector.set(te[8], te[9], te[10]).length();
    this.determinant() < 0 && (sx = -sx),
      (position.x = te[12]),
      (position.y = te[13]),
      (position.z = te[14]),
      matrix.copy(this);
    let invSX = 1 / sx,
      invSY = 1 / sy,
      invSZ = 1 / sz;
    return (
      (matrix.elements[0] *= invSX),
      (matrix.elements[1] *= invSX),
      (matrix.elements[2] *= invSX),
      (matrix.elements[4] *= invSY),
      (matrix.elements[5] *= invSY),
      (matrix.elements[6] *= invSY),
      (matrix.elements[8] *= invSZ),
      (matrix.elements[9] *= invSZ),
      (matrix.elements[10] *= invSZ),
      quaternion.setFromRotationMatrix(matrix),
      (scale.x = sx),
      (scale.y = sy),
      (scale.z = sz),
      this
    );
  }
  makePerspective(left, right, top, bottom, near, far) {
    let te = this.elements,
      x = (2 * near) / (right - left),
      y = (2 * near) / (top - bottom),
      a = (right + left) / (right - left),
      b = (top + bottom) / (top - bottom),
      c = -(far + near) / (far - near),
      d = (-2 * far * near) / (far - near);
    return (
      (te[0] = x),
      (te[4] = 0),
      (te[8] = a),
      (te[12] = 0),
      (te[1] = 0),
      (te[5] = y),
      (te[9] = b),
      (te[13] = 0),
      (te[2] = 0),
      (te[6] = 0),
      (te[10] = c),
      (te[14] = d),
      (te[3] = 0),
      (te[7] = 0),
      (te[11] = -1),
      (te[15] = 0),
      this
    );
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    let te = this.elements,
      w = 1 / (right - left),
      h = 1 / (top - bottom),
      p = 1 / (far - near),
      x = (right + left) * w,
      y = (top + bottom) * h,
      z = (far + near) * p;
    return (
      (te[0] = 2 * w),
      (te[4] = 0),
      (te[8] = 0),
      (te[12] = -x),
      (te[1] = 0),
      (te[5] = 2 * h),
      (te[9] = 0),
      (te[13] = -y),
      (te[2] = 0),
      (te[6] = 0),
      (te[10] = -2 * p),
      (te[14] = -z),
      (te[3] = 0),
      (te[7] = 0),
      (te[11] = 0),
      (te[15] = 1),
      this
    );
  }
  equals(matrix) {
    let te = this.elements,
      me = matrix.elements;
    for (let i = 0; i < 16; i++) if (te[i] !== me[i]) return !1;
    return !0;
  }
  fromArray(array, offset) {
    void 0 === offset && (offset = 0);
    for (let i = 0; i < 16; i++) this.elements[i] = array[i + offset];
    return this;
  }
  toArray(array, offset) {
    void 0 === array && (array = []), void 0 === offset && (offset = 0);
    let te = this.elements;
    return (
      (array[offset] = te[0]),
      (array[offset + 1] = te[1]),
      (array[offset + 2] = te[2]),
      (array[offset + 3] = te[3]),
      (array[offset + 4] = te[4]),
      (array[offset + 5] = te[5]),
      (array[offset + 6] = te[6]),
      (array[offset + 7] = te[7]),
      (array[offset + 8] = te[8]),
      (array[offset + 9] = te[9]),
      (array[offset + 10] = te[10]),
      (array[offset + 11] = te[11]),
      (array[offset + 12] = te[12]),
      (array[offset + 13] = te[13]),
      (array[offset + 14] = te[14]),
      (array[offset + 15] = te[15]),
      array
    );
  }
  applyToBufferAttribute(attribute) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    for (let i = 0, l = attribute.count; i < l; i++)
      (v1.x = attribute.array[3 * i + 0]),
        (v1.y = attribute.array[3 * i + 1]),
        (v1.z = attribute.array[3 * i + 2]),
        v1.applyMatrix4(this),
        (attribute.array[3 * i + 0] = v1.x),
        (attribute.array[3 * i + 1] = v1.y),
        (attribute.array[3 * i + 2] = v1.z);
    return attribute;
  }
}
class Plane {
  constructor(normal, constant) {
    (this.normal = void 0 !== normal ? normal : new Vector3(1, 0, 0)),
      (this.constant = void 0 !== constant ? constant : 0);
  }
  set(normal, constant) {
    return this.normal.copy(normal), (this.constant = constant), this;
  }
  setComponents(x, y, z, w) {
    return this.normal.set(x, y, z), (this.constant = w), this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    return (
      this.normal.copy(normal), (this.constant = -point.dot(this.normal)), this
    );
  }
  setFromCoplanarPoints(a, b, c) {
    let v1 = this.V1 || new Vector3(),
      v2 = this.V2 || new Vector3();
    (this.V1 = v1), (this.V2 = v2);
    var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
    return this.setFromNormalAndCoplanarPoint(normal, a), this;
  }
  clone() {
    return new Plane().copy(this);
  }
  copy(plane) {
    return (
      this.normal.copy(plane.normal), (this.constant = plane.constant), this
    );
  }
  normalize() {
    var inverseNormalLength = 1 / this.normal.length();
    return (
      this.normal.multiplyScalar(inverseNormalLength),
      (this.constant *= inverseNormalLength),
      this
    );
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target
      .copy(this.normal)
      .multiplyScalar(-this.distanceToPoint(point))
      .add(point);
  }
  intersectLine(line, target) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    var direction = line.delta(v1),
      denominator = this.normal.dot(direction);
    if (0 !== denominator) {
      var t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (!(t < 0 || t > 1))
        return target.copy(direction).multiplyScalar(t).add(line.start);
    } else if (0 === this.distanceToPoint(line.start))
      return target.copy(line.start);
  }
  intersectsLine(line) {
    var startSign = this.distanceToPoint(line.start),
      endSign = this.distanceToPoint(line.end);
    return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let m1 = this.M1 || new Matrix3();
    this.M1 = m1;
    var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix),
      referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix),
      normal = this.normal.applyMatrix3(normalMatrix).normalize();
    return (this.constant = -referencePoint.dot(normal)), this;
  }
  translate(offset) {
    return (this.constant -= offset.dot(this.normal)), this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
}
class Quaternion {
  constructor(x, y, z, w) {
    (this._x = x || 0),
      (this._y = y || 0),
      (this._z = z || 0),
      (this._w = void 0 !== w ? w : 1);
  }
  set x(v) {
    (this._x = v), this.onChangeCallback && this.onChangeCallback();
  }
  get x() {
    return this._x;
  }
  set y(v) {
    (this._y = v), this.onChangeCallback && this.onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set z(v) {
    (this._z = v), this.onChangeCallback && this.onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set w(v) {
    (this._w = v), this.onChangeCallback && this.onChangeCallback();
  }
  get w() {
    return this._w;
  }
  clone() {
    return new Quaternion(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    return (
      (this._x = quaternion.x),
      (this._y = quaternion.y),
      (this._z = quaternion.z),
      (this._w = quaternion.w),
      this.onChangeCallback(),
      this
    );
  }
  set(x, y, z, w) {
    (this._x = x),
      (this._y = y),
      (this._z = z),
      (this._w = w),
      this.onChangeCallback();
  }
  setFromEuler(euler, update) {
    let x = euler._x,
      y = euler._y,
      z = euler._z,
      order = euler.order,
      cos = Math.cos,
      sin = Math.sin,
      c1 = cos(x / 2),
      c2 = cos(y / 2),
      c3 = cos(z / 2),
      s1 = sin(x / 2),
      s2 = sin(y / 2),
      s3 = sin(z / 2);
    return (
      "XYZ" === order
        ? ((this._x = s1 * c2 * c3 + c1 * s2 * s3),
          (this._y = c1 * s2 * c3 - s1 * c2 * s3),
          (this._z = c1 * c2 * s3 + s1 * s2 * c3),
          (this._w = c1 * c2 * c3 - s1 * s2 * s3))
        : "YXZ" === order
        ? ((this._x = s1 * c2 * c3 + c1 * s2 * s3),
          (this._y = c1 * s2 * c3 - s1 * c2 * s3),
          (this._z = c1 * c2 * s3 - s1 * s2 * c3),
          (this._w = c1 * c2 * c3 + s1 * s2 * s3))
        : "ZXY" === order
        ? ((this._x = s1 * c2 * c3 - c1 * s2 * s3),
          (this._y = c1 * s2 * c3 + s1 * c2 * s3),
          (this._z = c1 * c2 * s3 + s1 * s2 * c3),
          (this._w = c1 * c2 * c3 - s1 * s2 * s3))
        : "ZYX" === order
        ? ((this._x = s1 * c2 * c3 - c1 * s2 * s3),
          (this._y = c1 * s2 * c3 + s1 * c2 * s3),
          (this._z = c1 * c2 * s3 - s1 * s2 * c3),
          (this._w = c1 * c2 * c3 + s1 * s2 * s3))
        : "YZX" === order
        ? ((this._x = s1 * c2 * c3 + c1 * s2 * s3),
          (this._y = c1 * s2 * c3 + s1 * c2 * s3),
          (this._z = c1 * c2 * s3 - s1 * s2 * c3),
          (this._w = c1 * c2 * c3 - s1 * s2 * s3))
        : "XZY" === order &&
          ((this._x = s1 * c2 * c3 - c1 * s2 * s3),
          (this._y = c1 * s2 * c3 - s1 * c2 * s3),
          (this._z = c1 * c2 * s3 + s1 * s2 * c3),
          (this._w = c1 * c2 * c3 + s1 * s2 * s3)),
      !1 !== update && this.onChangeCallback(),
      this
    );
  }
  setFromAxisAngle(axis, angle) {
    let halfAngle = angle / 2,
      s = Math.sin(halfAngle);
    return (
      (this._x = axis.x * s),
      (this._y = axis.y * s),
      (this._z = axis.z * s),
      (this._w = Math.cos(halfAngle)),
      this.onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(m) {
    let s,
      te = m.elements,
      m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10],
      trace = m11 + m22 + m33;
    return (
      trace > 0
        ? ((s = 0.5 / Math.sqrt(trace + 1)),
          (this._w = 0.25 / s),
          (this._x = (m32 - m23) * s),
          (this._y = (m13 - m31) * s),
          (this._z = (m21 - m12) * s))
        : m11 > m22 && m11 > m33
        ? ((s = 2 * Math.sqrt(1 + m11 - m22 - m33)),
          (this._w = (m32 - m23) / s),
          (this._x = 0.25 * s),
          (this._y = (m12 + m21) / s),
          (this._z = (m13 + m31) / s))
        : m22 > m33
        ? ((s = 2 * Math.sqrt(1 + m22 - m11 - m33)),
          (this._w = (m13 - m31) / s),
          (this._x = (m12 + m21) / s),
          (this._y = 0.25 * s),
          (this._z = (m23 + m32) / s))
        : ((s = 2 * Math.sqrt(1 + m33 - m11 - m22)),
          (this._w = (m21 - m12) / s),
          (this._x = (m13 + m31) / s),
          (this._y = (m23 + m32) / s),
          (this._z = 0.25 * s)),
      this.onChangeCallback(),
      this
    );
  }
  setFromUnitVectors(vFrom, vTo) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let r = vFrom.dot(vTo) + 1;
    return (
      r < 1e-6
        ? ((r = 0),
          Math.abs(vFrom.x) > Math.abs(vFrom.z)
            ? v1.set(-vFrom.y, vFrom.x, 0)
            : v1.set(0, -vFrom.z, vFrom.y))
        : v1.crossVectors(vFrom, vTo),
      (this._x = v1.x),
      (this._y = v1.y),
      (this._z = v1.z),
      (this._w = r),
      this.normalize()
    );
  }
  inverse() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this.onChangeCallback(),
      this
    );
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let l = this.length();
    return (
      0 === l
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((l = 1 / l),
          (this._x = this._x * l),
          (this._y = this._y * l),
          (this._z = this._z * l),
          (this._w = this._w * l)),
      this.onChangeCallback(),
      this
    );
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    let qax = a._x,
      qay = a._y,
      qaz = a._z,
      qaw = a._w,
      qbx = b._x,
      qby = b._y,
      qbz = b._z,
      qbw = b._w;
    return (
      (this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby),
      (this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz),
      (this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx),
      (this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz),
      this.onChangeCallback(),
      this
    );
  }
  slerp(qb, t) {
    if (0 === t) return this;
    if (1 === t) return this.copy(qb);
    let x = this._x,
      y = this._y,
      z = this._z,
      w = this._w,
      cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (
      (cosHalfTheta < 0
        ? ((this._w = -qb._w),
          (this._x = -qb._x),
          (this._y = -qb._y),
          (this._z = -qb._z),
          (cosHalfTheta = -cosHalfTheta))
        : this.copy(qb),
      cosHalfTheta >= 1)
    )
      return (this._w = w), (this._x = x), (this._y = y), (this._z = z), this;
    let sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    if (Math.abs(sinHalfTheta) < 0.001)
      return (
        (this._w = 0.5 * (w + this._w)),
        (this._x = 0.5 * (x + this._x)),
        (this._y = 0.5 * (y + this._y)),
        (this._z = 0.5 * (z + this._z)),
        this
      );
    let halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta),
      ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
      ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    return (
      (this._w = w * ratioA + this._w * ratioB),
      (this._x = x * ratioA + this._x * ratioB),
      (this._y = y * ratioA + this._y * ratioB),
      (this._z = z * ratioA + this._z * ratioB),
      this.onChangeCallback(),
      this
    );
  }
  equals(quaternion) {
    return (
      quaternion._x === this._x &&
      quaternion._y === this._y &&
      quaternion._z === this._z &&
      quaternion._w === this._w
    );
  }
  fromArray(array, offset) {
    return (
      void 0 === offset && (offset = 0),
      (this._x = array[offset]),
      (this._y = array[offset + 1]),
      (this._z = array[offset + 2]),
      (this._w = array[offset + 3]),
      this.onChangeCallback(),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this._x),
      (array[offset + 1] = this._y),
      (array[offset + 2] = this._z),
      (array[offset + 3] = this._w),
      array
    );
  }
  onChange(callback) {
    this.onChangeCallback = callback;
  }
  onChangeCallback() {}
}
class RayManager {
  constructor(origin, direction, near = 0, far = 1 / 0) {
    (this.ray = new Ray(origin, direction)),
      (this.near = near),
      (this.far = far),
      (this.params = { Mesh: {}, Points: { threshold: 1 } });
  }
  set(origin, direction) {
    return this.ray.set(origin, direction), this;
  }
  setFromCamera(coords, camera) {
    camera.isPerspective
      ? (this.ray.origin.setFromMatrixPosition(camera.matrixWorld),
        this.ray.direction
          .set(coords.x, coords.y, 0.5)
          .unproject(camera)
          .sub(this.ray.origin)
          .normalize())
      : (this.ray.origin
          .set(
            coords.x,
            coords.y,
            (camera.near + camera.far) / (camera.near - camera.far)
          )
          .unproject(camera),
        this.ray.direction
          .set(0, 0, -1)
          .transformDirection(camera.matrixWorld));
  }
  _ascSort(a, b) {
    return a.distance - b.distance;
  }
  _intersectObject(object, raycaster, intersects, recursive) {
    if (
      !1 !== object.visible &&
      (object.raycast(raycaster, intersects), !0 === recursive)
    ) {
      let children = object.children;
      for (let i = 0, l = children.length; i < l; i++)
        this._intersectObject(children[i], raycaster, intersects, !0);
    }
  }
  intersectObject(object, recursive, optionalTarget) {
    let intersects = optionalTarget || [];
    return (
      this._intersectObject(object, this, intersects, recursive),
      intersects.sort(this._ascSort),
      intersects
    );
  }
  intersectObjects(objects, recursive, optionalTarget) {
    let intersects = optionalTarget || [];
    for (let i = 0, l = objects.length; i < l; i++)
      this._intersectObject(objects[i], this, intersects, recursive);
    return intersects.sort(this._ascSort), intersects;
  }
}
class Ray {
  constructor(origin = new Vector3(), direction = new Vector3()) {
    (this.origin = origin), (this.direction = direction);
  }
  set(origin, direction) {
    return this.origin.copy(origin), this.direction.copy(direction), this;
  }
  clone() {
    return new Ray().copy(this);
  }
  copy(ray) {
    return (
      this.origin.copy(ray.origin), this.direction.copy(ray.direction), this
    );
  }
  at(t, target = new Vector3()) {
    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(v) {
    return this.direction.copy(v).sub(this.origin).normalize(), this;
  }
  recast(t) {
    let v1 = this.V1 || new Vector3();
    (this.V1 = v1), this.origin.copy(this.at(t, v1));
  }
  closestPointToPoint(point, target = new Vector3()) {
    target.subVectors(point, this.origin);
    let directionDistance = target.dot(this.direction);
    return directionDistance < 0
      ? target.copy(this.origin)
      : target
          .copy(this.direction)
          .multiplyScalar(directionDistance)
          .add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let directionDistance = v1
      .subVectors(point, this.origin)
      .dot(this.direction);
    return directionDistance < 0
      ? this.origin.distanceToSquared(point)
      : (v1
          .copy(this.direction)
          .multiplyScalar(directionDistance)
          .add(this.origin),
        v1.distanceToSquared(point));
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    let segCenter = this.V1 || new Vector3(),
      segDir = this.V2 || new Vector3(),
      diff = this.V3 || new Vector3();
    (this.V1 = segCenter),
      (this.V2 = segDir),
      (this.V3 = diff),
      segCenter.copy(v0).add(v1).multiplyScalar(0.5),
      segDir.copy(v1).sub(v0).normalize(),
      diff.copy(this.origin).sub(segCenter);
    let s0,
      s1,
      sqrDist,
      extDet,
      segExtent = 0.5 * v0.distanceTo(v1),
      a01 = -this.direction.dot(segDir),
      b0 = diff.dot(this.direction),
      b1 = -diff.dot(segDir),
      c = diff.lengthSq(),
      det = Math.abs(1 - a01 * a01);
    if (det > 0)
      if (
        ((s0 = a01 * b1 - b0),
        (s1 = a01 * b0 - b1),
        (extDet = segExtent * det),
        s0 >= 0)
      )
        if (s1 >= -extDet)
          if (s1 <= extDet) {
            let invDet = 1 / det;
            sqrDist =
              (s0 *= invDet) * (s0 + a01 * (s1 *= invDet) + 2 * b0) +
              s1 * (a01 * s0 + s1 + 2 * b1) +
              c;
          } else
            (s1 = segExtent),
              (sqrDist =
                -(s0 = Math.max(0, -(a01 * s1 + b0))) * s0 +
                s1 * (s1 + 2 * b1) +
                c);
        else
          (s1 = -segExtent),
            (sqrDist =
              -(s0 = Math.max(0, -(a01 * s1 + b0))) * s0 +
              s1 * (s1 + 2 * b1) +
              c);
      else
        s1 <= -extDet
          ? (sqrDist =
              -(s0 = Math.max(0, -(-a01 * segExtent + b0))) * s0 +
              (s1 =
                s0 > 0
                  ? -segExtent
                  : Math.min(Math.max(-segExtent, -b1), segExtent)) *
                (s1 + 2 * b1) +
              c)
          : s1 <= extDet
          ? ((s0 = 0),
            (sqrDist =
              (s1 = Math.min(Math.max(-segExtent, -b1), segExtent)) *
                (s1 + 2 * b1) +
              c))
          : (sqrDist =
              -(s0 = Math.max(0, -(a01 * segExtent + b0))) * s0 +
              (s1 =
                s0 > 0
                  ? segExtent
                  : Math.min(Math.max(-segExtent, -b1), segExtent)) *
                (s1 + 2 * b1) +
              c);
    else
      (s1 = a01 > 0 ? -segExtent : segExtent),
        (sqrDist =
          -(s0 = Math.max(0, -(a01 * s1 + b0))) * s0 + s1 * (s1 + 2 * b1) + c);
    return (
      optionalPointOnRay &&
        optionalPointOnRay
          .copy(this.direction)
          .multiplyScalar(s0)
          .add(this.origin),
      optionalPointOnSegment &&
        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter),
      sqrDist
    );
  }
  intersectSphere(sphere, target) {
    let v1 = this.V1 || new Vector3();
    (this.V1 = v1), v1.subVectors(sphere.center, this.origin);
    let tca = v1.dot(this.direction),
      d2 = v1.dot(v1) - tca * tca,
      radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    let thc = Math.sqrt(radius2 - d2),
      t0 = tca - thc,
      t1 = tca + thc;
    return t0 < 0 && t1 < 0
      ? null
      : t0 < 0
      ? this.at(t1, target)
      : this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceToPoint(sphere.center) <= sphere.radius;
  }
  distanceToPlane(plane) {
    let denominator = plane.normal.dot(this.direction);
    if (0 === denominator)
      return 0 === plane.distanceToPoint(this.origin) ? 0 : null;
    let t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    let t = this.distanceToPlane(plane);
    return null === t ? null : this.at(t, target);
  }
  intersectsPlane(plane) {
    let distToPoint = plane.distanceToPoint(this.origin);
    return (
      0 === distToPoint || plane.normal.dot(this.direction) * distToPoint < 0
    );
  }
  intersectBox(box, target) {
    let tmin,
      tmax,
      tymin,
      tymax,
      tzmin,
      tzmax,
      invdirx = 1 / this.direction.x,
      invdiry = 1 / this.direction.y,
      invdirz = 1 / this.direction.z,
      origin = this.origin;
    return (
      invdirx >= 0
        ? ((tmin = (box.min.x - origin.x) * invdirx),
          (tmax = (box.max.x - origin.x) * invdirx))
        : ((tmin = (box.max.x - origin.x) * invdirx),
          (tmax = (box.min.x - origin.x) * invdirx)),
      invdiry >= 0
        ? ((tymin = (box.min.y - origin.y) * invdiry),
          (tymax = (box.max.y - origin.y) * invdiry))
        : ((tymin = (box.max.y - origin.y) * invdiry),
          (tymax = (box.min.y - origin.y) * invdiry)),
      tmin > tymax || tymin > tmax
        ? null
        : ((tymin > tmin || tmin != tmin) && (tmin = tymin),
          (tymax < tmax || tmax != tmax) && (tmax = tymax),
          invdirz >= 0
            ? ((tzmin = (box.min.z - origin.z) * invdirz),
              (tzmax = (box.max.z - origin.z) * invdirz))
            : ((tzmin = (box.max.z - origin.z) * invdirz),
              (tzmax = (box.min.z - origin.z) * invdirz)),
          tmin > tzmax || tzmin > tmax
            ? null
            : ((tzmin > tmin || tmin != tmin) && (tmin = tzmin),
              (tzmax < tmax || tmax != tmax) && (tmax = tzmax),
              tmax < 0 ? null : this.at(tmin >= 0 ? tmin : tmax, target)))
    );
  }
  intersectsBox(box) {
    let v = this.V1 || new Vector3();
    return (this.V1 = v), null !== this.intersectBox(box, v);
  }
  intersectsTriangle(a, b, c, backfaceCulling, target) {
    let diff = this.V1 || new Vector3(),
      edge1 = this.V2 || new Vector3(),
      edge2 = this.V3 || new Vector3(),
      normal = this.V4 || new Vector3();
    (this.V1 = diff),
      (this.V2 = edge1),
      (this.V3 = edge2),
      (this.V4 = normal),
      edge1.subVectors(b, a),
      edge2.subVectors(c, a),
      normal.crossVectors(edge1, edge2);
    let sign,
      DdN = this.direction.dot(normal);
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign = 1;
    } else {
      if (!(DdN < 0)) return null;
      (sign = -1), (DdN = -DdN);
    }
    diff.subVectors(this.origin, a);
    let DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
    if (DdQxE2 < 0) return null;
    let DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
    if (DdE1xQ < 0) return null;
    if (DdQxE2 + DdE1xQ > DdN) return null;
    let QdN = -sign * diff.dot(normal);
    return QdN < 0 ? null : this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    return (
      this.origin.applyMatrix4(matrix4),
      this.direction.transformDirection(matrix4),
      this
    );
  }
  equals(ray) {
    return (
      ray.origin.equals(this.origin) && ray.direction.equals(this.direction)
    );
  }
}
class Sphere {
  constructor(center = new Vector3(), radius = 0) {
    (this.center = center), (this.radius = radius);
  }
  set(center, radius) {
    return this.center.copy(center), (this.radius = radius), this;
  }
  setFromPoints(points, optionalCenter) {
    let box = this.V1 || new Box3();
    this.V1 = box;
    let center = this.center;
    void 0 !== optionalCenter
      ? center.copy(optionalCenter)
      : box.setFromPoints(points).getCenter(center);
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++)
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    return (this.radius = Math.sqrt(maxRadiusSq)), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(sphere) {
    return this.center.copy(sphere.center), (this.radius = sphere.radius), this;
  }
  empty() {
    return this.radius <= 0;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    let radiusSum = this.radius + sphere.radius;
    return (
      sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum
    );
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target = new Vector3()) {
    let deltaLengthSq = this.center.distanceToSquared(point);
    return (
      target.copy(point),
      deltaLengthSq > this.radius * this.radius &&
        (target.sub(this.center).normalize(),
        target.multiplyScalar(this.radius).add(this.center)),
      target
    );
  }
  getBoundingBox(target = new Box3()) {
    return (
      target.set(this.center, this.center),
      target.expandByScalar(this.radius),
      target
    );
  }
  applyMatrix4(matrix) {
    return (
      this.center.applyMatrix4(matrix),
      (this.radius = this.radius * matrix.getMaxScaleOnAxis()),
      this
    );
  }
  translate(offset) {
    return this.center.add(offset), this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
}
class Spherical {
  constructor(radius = 1, phi = 0, theta = 0) {
    (this.radius = radius), (this.phi = phi), (this.theta = theta);
  }
  set(radius, phi, theta) {
    return (this.radius = radius), (this.phi = phi), (this.theta = theta), this;
  }
  clone() {
    return new Spherical().copy(this);
  }
  copy(other) {
    return (
      (this.radius = other.radius),
      (this.phi = other.phi),
      (this.theta = other.theta),
      this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(vec3) {
    return (
      (this.radius = vec3.length()),
      0 === this.radius
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(vec3.x, vec3.z)),
          (this.phi = Math.acos(Math.clamp(vec3.y / this.radius, -1, 1)))),
      this
    );
  }
}
class Triangle {
  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    (this.a = a), (this.b = b), (this.c = c);
  }
  set(a, b, c) {
    return this.a.copy(a), this.b.copy(b), this.c.copy(c), this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    return (
      this.a.copy(points[i0]),
      this.b.copy(points[i1]),
      this.c.copy(points[i2]),
      this
    );
  }
  clone() {
    return new Triangle().copy(this);
  }
  copy(triangle) {
    return (
      this.a.copy(triangle.a),
      this.b.copy(triangle.b),
      this.c.copy(triangle.c),
      this
    );
  }
  getArea() {
    let v0 = this.V0 || new Vector3(),
      v1 = this.V1 || new Vector3();
    return (
      (this.V0 = v0),
      (this.V1 = v1),
      v0.subVectors(this.c, this.b),
      v1.subVectors(this.a, this.b),
      0.5 * v0.cross(v1).length()
    );
  }
  getMidpoint(target = new Vector3()) {
    return target
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target = new Vector3()) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  equals(triangle) {
    return (
      triangle.a.equals(this.a) &&
      triangle.b.equals(this.b) &&
      triangle.c.equals(this.c)
    );
  }
}
class Vector2 {
  constructor(x = 0, y = 0) {
    (this.x = x), (this.y = y);
  }
  set(x, y) {
    return (this.x = x), (this.y = y), this;
  }
  get width() {
    return this.x;
  }
  get height() {
    return this.y;
  }
  setScalar(s) {
    return (this.x = this.y = s), this;
  }
  clone() {
    return new Vector2(this.x, this.y);
  }
  copy(v) {
    return (this.x = v.x), (this.y = v.y), this;
  }
  add(v) {
    return (this.x += v.x), (this.y += v.y), this;
  }
  addScalar(s) {
    return (this.x += s), (this.y += s), this;
  }
  addVectors(a, b) {
    return (this.x = a.x + b.x), (this.y = a.y + b.y), this;
  }
  addScaledVector(v, s) {
    return (this.x += v.x * s), (this.y += v.y * s), this;
  }
  sub(v) {
    return (this.x -= v.x), (this.y -= v.y), this;
  }
  subScalar(s) {
    return (this.x -= s), (this.y -= s), this;
  }
  subVectors(a, b) {
    return (this.x = a.x - b.x), (this.y = a.y - b.y), this;
  }
  multiply(v) {
    return (this.x *= v.x), (this.y *= v.y), this;
  }
  multiplyScalar(scalar) {
    return (this.x *= scalar), (this.y *= scalar), this;
  }
  divide(v) {
    return (this.x /= v.x), (this.y /= v.y), this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    let x = this.x,
      y = this.y,
      e = m.elements;
    return (
      (this.x = e[0] * x + e[3] * y + e[6]),
      (this.y = e[1] * x + e[4] * y + e[7]),
      this
    );
  }
  min(v) {
    return (
      (this.x = Math.min(this.x, v.x)), (this.y = Math.min(this.y, v.y)), this
    );
  }
  max(v) {
    return (
      (this.x = Math.max(this.x, v.x)), (this.y = Math.max(this.y, v.y)), this
    );
  }
  clamp(min, max) {
    return (
      (this.x = Math.max(min.x, Math.min(max.x, this.x))),
      (this.y = Math.max(min.y, Math.min(max.y, this.y))),
      this
    );
  }
  clampScalar(minVal, maxVal) {
    let min = new Vector2(),
      max = new Vector2();
    return (
      min.set(minVal, minVal), max.set(maxVal, maxVal), this.clamp(min, max)
    );
  }
  clampLength(min, max) {
    let length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(
      Math.max(min, Math.min(max, length))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    let angle = Math.atan2(this.y, this.x);
    return angle < 0 && (angle += 2 * Math.PI), angle;
  }
  angleTo(a, b) {
    return b || (b = this), Math.atan2(a.y - b.y, a.x - b.x);
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    let dx = this.x - v.x,
      dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    return (
      (this.x += (v.x - this.x) * alpha),
      (this.y += (v.y - this.y) * alpha),
      this
    );
  }
  lerpVectors(v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  setAngleRadius(a, r) {
    return (this.x = Math.cos(a) * r), (this.y = Math.sin(a) * r), this;
  }
  addAngleRadius(a, r) {
    return (this.x += Math.cos(a) * r), (this.y += Math.sin(a) * r), this;
  }
  fromArray(array, offset) {
    return (
      void 0 === offset && (offset = 0),
      (this.x = array[offset]),
      (this.y = array[offset + 1]),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this.x),
      (array[offset + 1] = this.y),
      array
    );
  }
  rotateAround(center, angle) {
    let c = Math.cos(angle),
      s = Math.sin(angle),
      x = this.x - center.x,
      y = this.y - center.y;
    return (
      (this.x = x * c - y * s + center.x),
      (this.y = x * s + y * c + center.y),
      this
    );
  }
  fromBufferAttribute(attribute, index) {
    (this.x = attribute.array[2 * index + 0]),
      (this.y = attribute.array[2 * index + 1]);
  }
}
class Vector3 {
  constructor(x, y, z) {
    (this.x = x || 0), (this.y = y || 0), (this.z = z || 0);
  }
  set(x, y, z) {
    return (this.x = x || 0), (this.y = y || 0), (this.z = z || 0), this;
  }
  setScalar(scalar) {
    return (this.x = scalar), (this.y = scalar), (this.z = scalar), this;
  }
  clone() {
    return new Vector3(this.x, this.y, this.z);
  }
  copy(v) {
    return (this.x = v.x), (this.y = v.y), (this.z = v.z), this;
  }
  add(v) {
    return (this.x += v.x), (this.y += v.y), (this.z += v.z), this;
  }
  addScalar(s) {
    return (this.x += s), (this.y += s), (this.z += s), this;
  }
  addVectors(a, b) {
    return (
      (this.x = a.x + b.x), (this.y = a.y + b.y), (this.z = a.z + b.z), this
    );
  }
  addScaledVector(v) {
    return (this.x += v.x * s), (this.y += v.y * s), (this.z += v.z * s), this;
  }
  sub(v) {
    return (this.x -= v.x), (this.y -= v.y), (this.z -= v.z), this;
  }
  subScalar(s) {
    return (this.x -= s), (this.y -= s), (this.z -= s), this;
  }
  subVectors(a, b) {
    return (
      (this.x = a.x - b.x), (this.y = a.y - b.y), (this.z = a.z - b.z), this
    );
  }
  multiply(v) {
    return (this.x *= v.x), (this.y *= v.y), (this.z *= v.z), this;
  }
  multiplyScalar(scalar) {
    return (this.x *= scalar), (this.y *= scalar), (this.z *= scalar), this;
  }
  multiplyVectors(a, b) {
    return (
      (this.x = a.x * b.x), (this.y = a.y * b.y), (this.z = a.z * b.z), this
    );
  }
  applyEuler(euler) {
    let quaternion = this.Q1 || new Quaternion();
    return (
      (this.Q1 = quaternion),
      this.applyQuaternion(quaternion.setFromEuler(euler))
    );
  }
  applyAxisAngle(axis, angle) {
    let quaternion = this.Q1 || new Quaternion();
    return (
      (this.Q1 = quaternion),
      this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle))
    );
  }
  applyMatrix3(m) {
    let x = this.x,
      y = this.y,
      z = this.z,
      e = m.elements;
    return (
      (this.x = e[0] * x + e[3] * y + e[6] * z),
      (this.y = e[1] * x + e[4] * y + e[7] * z),
      (this.z = e[2] * x + e[5] * y + e[8] * z),
      this
    );
  }
  applyMatrix4(m) {
    let x = this.x,
      y = this.y,
      z = this.z,
      e = m.elements,
      w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    return (
      (this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w),
      (this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w),
      (this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w),
      this
    );
  }
  applyQuaternion(q) {
    let x = this.x,
      y = this.y,
      z = this.z,
      qx = q.x,
      qy = q.y,
      qz = q.z,
      qw = q.w,
      ix = qw * x + qy * z - qz * y,
      iy = qw * y + qz * x - qx * z,
      iz = qw * z + qx * y - qy * x,
      iw = -qx * x - qy * y - qz * z;
    return (
      (this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy),
      (this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz),
      (this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx),
      this
    );
  }
  project(camera) {
    let matrix = this.M1 || new Matrix4();
    return (
      (this.M1 = matrix),
      matrix.multiplyMatrices(
        camera.projectionMatrix,
        matrix.getInverse(camera.matrixWorld)
      ),
      this.applyMatrix4(matrix)
    );
  }
  unproject(camera) {
    let matrix = this.M1 || new Matrix4();
    return (
      (this.M1 = matrix),
      matrix.multiplyMatrices(
        camera.matrixWorld,
        matrix.getInverse(camera.projectionMatrix)
      ),
      this.applyMatrix4(matrix)
    );
  }
  transformDirection(m) {
    let x = this.x,
      y = this.y,
      z = this.z,
      e = m.elements;
    return (
      (this.x = e[0] * x + e[4] * y + e[8] * z),
      (this.y = e[1] * x + e[5] * y + e[9] * z),
      (this.z = e[2] * x + e[6] * y + e[10] * z),
      this.normalize()
    );
  }
  divide(v) {
    return (this.x /= v.x), (this.y /= v.y), (this.z /= v.z), this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    return (
      (this.x = Math.min(this.x, v.x)),
      (this.y = Math.min(this.y, v.y)),
      (this.z = Math.min(this.z, v.z)),
      this
    );
  }
  max(v) {
    return (
      (this.x = Math.max(this.x, v.x)),
      (this.y = Math.max(this.y, v.y)),
      (this.z = Math.max(this.z, v.z)),
      this
    );
  }
  clamp(min, max) {
    return (
      (this.x = Math.max(min.x, Math.min(max.x, this.x))),
      (this.y = Math.max(min.y, Math.min(max.y, this.y))),
      (this.z = Math.max(min.z, Math.min(max.z, this.z))),
      this
    );
  }
  clampScalar(minVal, maxVal) {
    let min = new Vector3(),
      max = new Vector3();
    return (
      min.set(minVal, minVal, minVal),
      max.set(maxVal, maxVal, maxVal),
      this.clamp(min, max)
    );
  }
  clampLength(min, max) {
    let length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(
      Math.max(min, Math.min(max, length))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    return (
      (this.x += (v.x - this.x) * alpha),
      (this.y += (v.y - this.y) * alpha),
      (this.z += (v.z - this.z) * alpha),
      this
    );
  }
  lerpVectors(v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    let ax = a.x,
      ay = a.y,
      az = a.z,
      bx = b.x,
      by = b.y,
      bz = b.z;
    return (
      (this.x = ay * bz - az * by),
      (this.y = az * bx - ax * bz),
      (this.z = ax * by - ay * bx),
      this
    );
  }
  projectOnVector(vector) {
    let scalar = vector.dot(this) / vector.lengthSq();
    return this.copy(vector).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    let v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1), v1.copy(this).projectOnVector(planeNormal), this.sub(v1)
    );
  }
  reflect(normal) {
    let v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1),
      this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)))
    );
  }
  angleTo(v) {
    let theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
    return Math.acos(Math.clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    let dx = this.x - v.x,
      dy = this.y - v.y,
      dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return (
      Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)
    );
  }
  setFromSpherical(s) {
    let sinPhiRadius = Math.sin(s.phi) * s.radius;
    return (
      (this.x = sinPhiRadius * Math.sin(s.theta)),
      (this.y = Math.cos(s.phi) * s.radius),
      (this.z = sinPhiRadius * Math.cos(s.theta)),
      this
    );
  }
  setFromCylindrical(c) {
    return (
      (this.x = c.radius * Math.sin(c.theta)),
      (this.y = c.y),
      (this.z = c.radius * Math.cos(c.theta)),
      this
    );
  }
  setFromMatrixPosition(m) {
    let e = m.elements;
    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
  }
  setFromMatrixScale(m) {
    let sx = this.setFromMatrixColumn(m, 0).length(),
      sy = this.setFromMatrixColumn(m, 1).length(),
      sz = this.setFromMatrixColumn(m, 2).length();
    return (this.x = sx), (this.y = sy), (this.z = sz), this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, 4 * index);
  }
  setAngleRadius(a, r, dir = "xy") {
    return (
      (this[dir[0]] = Math.cos(a) * r), (this[dir[1]] = Math.cos(a) * r), this
    );
  }
  addAngleRadius(a, r, dir = "xy") {
    return (
      (this[dir[0]] += Math.cos(a) * r), (this[dir[1]] += Math.cos(a) * r), this
    );
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset) {
    return (
      void 0 === offset && (offset = 0),
      (this.x = array[offset]),
      (this.y = array[offset + 1]),
      (this.z = array[offset + 2]),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this.x),
      (array[offset + 1] = this.y),
      (array[offset + 2] = this.z),
      array
    );
  }
  fromBufferAttribute(attribute, index) {
    return (
      (this.x = attribute.array[3 * index + 0]),
      (this.y = attribute.array[3 * index + 1]),
      (this.z = attribute.array[3 * index + 2]),
      this
    );
  }
}
class Vector3D {
  constructor(x, y, z) {
    (this._x = x || 0), (this._y = y || 0), (this._z = z || 0);
  }
  get x() {
    return this._x;
  }
  set x(v) {
    if (Hydra.LOCAL && isNaN(v)) throw "Vector3D::NaN";
    Math.abs(this._x - v) > 1e-4 && this.onChangeCallback(), (this._x = v);
  }
  get y() {
    return this._y;
  }
  set y(v) {
    if (Hydra.LOCAL && isNaN(v)) throw "Vector3D::NaN";
    Math.abs(this._y - v) > 1e-4 && this.onChangeCallback(), (this._y = v);
  }
  get z() {
    return this._z;
  }
  set z(v) {
    if (Hydra.LOCAL && isNaN(v)) throw "Vector3D::NaN";
    Math.abs(this._z - v) > 1e-4 && this.onChangeCallback(), (this._z = v);
  }
  onChangeCallback() {}
  set(x, y, z) {
    return (
      (this._x = x || 0),
      (this._y = y || 0),
      (this._z = z || 0),
      this.onChangeCallback(),
      this
    );
  }
  setScalar(scalar) {
    return (
      (this._x = scalar),
      (this._y = scalar),
      (this._z = scalar),
      this.onChangeCallback(),
      this
    );
  }
  clone() {
    return new Vector3(this._x, this._y, this._z);
  }
  copy(v) {
    let dirty =
      Math.abs(this._x - v.x) > 1e-4 ||
      Math.abs(this._y - v.y) > 1e-4 ||
      Math.abs(this._z - v.z) > 1e-4;
    return (
      (this._x = v.x),
      (this._y = v.y),
      (this._z = v.z),
      dirty && this.onChangeCallback(),
      this
    );
  }
  add(v) {
    return (
      (this._x += v.x),
      (this._y += v.y),
      (this._z += v.z),
      this.onChangeCallback(),
      this
    );
  }
  addScalar(s) {
    return (
      (this._x += s),
      (this._y += s),
      (this._z += s),
      this.onChangeCallback(),
      this
    );
  }
  addVectors(a, b) {
    return (
      (this._x = a.x + b.x),
      (this._y = a.y + b.y),
      (this._z = a.z + b.z),
      this.onChangeCallback(),
      this
    );
  }
  addScaledVector(v) {
    return (
      (this._x += v.x * s),
      (this._y += v.y * s),
      (this._z += v.z * s),
      this.onChangeCallback(),
      this
    );
  }
  sub(v) {
    return (
      (this._x -= v.x),
      (this._y -= v.y),
      (this._z -= v.z),
      this.onChangeCallback(),
      this
    );
  }
  subScalar(s) {
    return (
      (this._x -= s),
      (this._y -= s),
      (this._z -= s),
      this.onChangeCallback(),
      this
    );
  }
  subVectors(a, b) {
    return (
      (this._x = a.x - b.x),
      (this._y = a.y - b.y),
      (this._z = a.z - b.z),
      this.onChangeCallback(),
      this
    );
  }
  multiply(v) {
    return (
      (this._x *= v.x),
      (this._y *= v.y),
      (this._z *= v.z),
      this.onChangeCallback(),
      this
    );
  }
  multiplyScalar(scalar) {
    return (
      (this._x *= scalar),
      (this._y *= scalar),
      (this._z *= scalar),
      this.onChangeCallback(),
      this
    );
  }
  multiplyVectors(a, b) {
    return (
      (this._x = a.x * b.x),
      (this._y = a.y * b.y),
      (this._z = a.z * b.z),
      this.onChangeCallback(),
      this
    );
  }
  applyEuler(euler) {
    let quaternion = this.Q1 || new Quaternion();
    return (
      (this.Q1 = quaternion),
      this.applyQuaternion(quaternion.setFromEuler(euler))
    );
  }
  applyAxisAngle(axis, angle) {
    let quaternion = this.Q1 || new Quaternion();
    return (
      (this.Q1 = quaternion),
      this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle))
    );
  }
  applyMatrix3(m) {
    let x = this._x,
      y = this._y,
      z = this._z,
      e = m.elements;
    return (
      (this._x = e[0] * x + e[3] * y + e[6] * z),
      (this._y = e[1] * x + e[4] * y + e[7] * z),
      (this._z = e[2] * x + e[5] * y + e[8] * z),
      this.onChangeCallback(),
      this
    );
  }
  applyMatrix4(m) {
    let x = this._x,
      y = this._y,
      z = this._z,
      e = m.elements,
      w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    return (
      (this._x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w),
      (this._y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w),
      (this._z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w),
      this.onChangeCallback(),
      this
    );
  }
  applyQuaternion(q) {
    let x = this._x,
      y = this._y,
      z = this._z,
      qx = q.x,
      qy = q.y,
      qz = q.z,
      qw = q.w,
      ix = qw * x + qy * z - qz * y,
      iy = qw * y + qz * x - qx * z,
      iz = qw * z + qx * y - qy * x,
      iw = -qx * x - qy * y - qz * z;
    return (
      (this._x = ix * qw + iw * -qx + iy * -qz - iz * -qy),
      (this._y = iy * qw + iw * -qy + iz * -qx - ix * -qz),
      (this._z = iz * qw + iw * -qz + ix * -qy - iy * -qx),
      this.onChangeCallback(),
      this
    );
  }
  project(camera) {
    let matrix = this.M1 || new Matrix4();
    return (
      (this.M1 = matrix),
      matrix.multiplyMatrices(
        camera.projectionMatrix,
        matrix.getInverse(camera.matrixWorld)
      ),
      this.applyMatrix4(matrix)
    );
  }
  unproject(camera) {
    let matrix = this.M1 || new Matrix4();
    return (
      (this.M1 = matrix),
      matrix.multiplyMatrices(
        camera.matrixWorld,
        matrix.getInverse(camera.projectionMatrix)
      ),
      this.applyMatrix4(matrix)
    );
  }
  transformDirection(m) {
    let x = this._x,
      y = this._y,
      z = this._z,
      e = m.elements;
    return (
      (this._x = e[0] * x + e[4] * y + e[8] * z),
      (this._y = e[1] * x + e[5] * y + e[9] * z),
      (this._z = e[2] * x + e[6] * y + e[10] * z),
      this.onChangeCallback(),
      this.normalize()
    );
  }
  divide(v) {
    return (
      (this._x /= v.x),
      (this._y /= v.y),
      (this._z /= v.z),
      this.onChangeCallback(),
      this
    );
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    return (
      (this._x = Math.min(this._x, v.x)),
      (this._y = Math.min(this._y, v.y)),
      (this._z = Math.min(this._z, v.z)),
      this.onChangeCallback(),
      this
    );
  }
  max(v) {
    return (
      (this._x = Math.max(this._x, v.x)),
      (this._y = Math.max(this._y, v.y)),
      (this._z = Math.max(this._z, v.z)),
      this
    );
  }
  clamp(min, max) {
    return (
      (this._x = Math.max(min.x, Math.min(max.x, this._x))),
      (this._y = Math.max(min.y, Math.min(max.y, this._y))),
      (this._z = Math.max(min.z, Math.min(max.z, this._z))),
      this
    );
  }
  clampScalar(minVal, maxVal) {
    let min = new Vector3(),
      max = new Vector3();
    return (
      min.set(minVal, minVal, minVal),
      max.set(maxVal, maxVal, maxVal),
      this.clamp(min, max)
    );
  }
  clampLength(min, max) {
    let length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(
      Math.max(min, Math.min(max, length))
    );
  }
  floor() {
    return (
      (this._x = Math.floor(this._x)),
      (this._y = Math.floor(this._y)),
      (this._z = Math.floor(this._z)),
      this.onChangeCallback(),
      this
    );
  }
  ceil() {
    return (
      (this._x = Math.ceil(this._x)),
      (this._y = Math.ceil(this._y)),
      (this._z = Math.ceil(this._z)),
      this.onChangeCallback(),
      this
    );
  }
  round() {
    return (
      (this._x = Math.round(this._x)),
      (this._y = Math.round(this._y)),
      (this._z = Math.round(this._z)),
      this.onChangeCallback(),
      this
    );
  }
  roundToZero() {
    return (
      (this._x = this._x < 0 ? Math.ceil(this._x) : Math.floor(this._x)),
      (this._y = this._y < 0 ? Math.ceil(this._y) : Math.floor(this._y)),
      (this._z = this._z < 0 ? Math.ceil(this._z) : Math.floor(this._z)),
      this.onChangeCallback(),
      this
    );
  }
  negate() {
    return (
      (this._x = -this._x),
      (this._y = -this._y),
      (this._z = -this._z),
      this.onChangeCallback(),
      this
    );
  }
  dot(v) {
    return this._x * v.x + this._y * v.y + this._z * v.z;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
  }
  manhattanLength() {
    return Math.abs(this._x) + Math.abs(this._y) + Math.abs(this._z);
  }
  normalize() {
    return this.onChangeCallback(), this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.onChangeCallback(), this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    return (
      (this._x += (v.x - this._x) * alpha),
      (this._y += (v.y - this._y) * alpha),
      (this._z += (v.z - this._z) * alpha),
      this.onChangeCallback(),
      this
    );
  }
  lerpVectors(v1, v2, alpha) {
    return (
      this.onChangeCallback(),
      this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
    );
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    let ax = a.x,
      ay = a.y,
      az = a.z,
      bx = b.x,
      by = b.y,
      bz = b.z;
    return (
      (this._x = ay * bz - az * by),
      (this._y = az * bx - ax * bz),
      (this._z = ax * by - ay * bx),
      this.onChangeCallback(),
      this
    );
  }
  projectOnVector(vector) {
    let scalar = vector.dot(this) / vector.lengthSq();
    return this.copy(vector).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    let v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1),
      this.onChangeCallback(),
      v1.copy(this).projectOnVector(planeNormal),
      this.sub(v1)
    );
  }
  reflect(normal) {
    let v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1),
      this.onChangeCallback(),
      this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)))
    );
  }
  angleTo(v) {
    let theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
    return Math.acos(Math.clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    let dx = this._x - v.x,
      dy = this._y - v.y,
      dz = this._z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return (
      Math.abs(this._x - v.x) +
      Math.abs(this._y - v.y) +
      Math.abs(this._z - v.z)
    );
  }
  setFromSpherical(s) {
    let sinPhiRadius = Math.sin(s.phi) * s.radius;
    return (
      (this._x = sinPhiRadius * Math.sin(s.theta)),
      (this._y = Math.cos(s.phi) * s.radius),
      (this._z = sinPhiRadius * Math.cos(s.theta)),
      this.onChangeCallback(),
      this
    );
  }
  setFromCylindrical(c) {
    return (
      (this._x = c.radius * Math.sin(c.theta)),
      (this._y = c.y),
      (this._z = c.radius * Math.cos(c.theta)),
      this.onChangeCallback(),
      this
    );
  }
  setFromMatrixPosition(m) {
    let e = m.elements;
    return (
      (this._x = e[12]),
      (this._y = e[13]),
      (this._z = e[14]),
      this.onChangeCallback(),
      this
    );
  }
  setFromMatrixScale(m) {
    let sx = this.setFromMatrixColumn(m, 0).length(),
      sy = this.setFromMatrixColumn(m, 1).length(),
      sz = this.setFromMatrixColumn(m, 2).length();
    return (
      this.onChangeCallback(),
      (this._x = sx),
      (this._y = sy),
      (this._z = sz),
      this
    );
  }
  setFromMatrixColumn(m, index) {
    return this.onChangeCallback(), this.fromArray(m.elements, 4 * index);
  }
  equals(v) {
    return v.x === this._x && v.y === this._y && v.z === this._z;
  }
  fromArray(array, offset) {
    return (
      void 0 === offset && (offset = 0),
      (this._x = array[offset]),
      (this._y = array[offset + 1]),
      (this._z = array[offset + 2]),
      this.onChangeCallback(),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this._x),
      (array[offset + 1] = this._y),
      (array[offset + 2] = this._z),
      array
    );
  }
  fromBufferAttribute(attribute, index) {
    (this._x = attribute.array[3 * index + 0]),
      (this._y = attribute.array[3 * index + 1]),
      (this._z = attribute.array[3 * index + 2]),
      this.onChangeCallback();
  }
  onChange(callback) {
    this.onChangeCallback = callback;
  }
  onChangeCallback() {}
}
class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 0) {
    (this.x = x), (this.y = y), (this.z = z), (this.w = w);
  }
  multiplyScalar(s) {
    return (this.x *= s), (this.y *= s), (this.z *= s), (this.w *= s), this;
  }
  set(x, y, z, w) {
    return (this.x = x), (this.y = y), (this.z = z), (this.w = w), this;
  }
  copy(v) {
    return (this.x = v.x), (this.y = v.y), (this.z = v.z), (this.w = v.w), this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  applyMatrix4(m) {
    let x = this.x,
      y = this.y,
      z = this.z,
      w = this.w,
      e = m.elements;
    return (
      (this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w),
      (this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w),
      (this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w),
      (this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this.x),
      (array[offset + 1] = this.y),
      (array[offset + 2] = this.z),
      (array[offset + 3] = this.w),
      array
    );
  }
  fromArray(array, offset) {
    return (
      void 0 === offset && (offset = 0),
      (this.x = array[offset]),
      (this.y = array[offset + 1]),
      (this.z = array[offset + 2]),
      (this.w = array[offset + 3]),
      this
    );
  }
}
class Face3 {
  constructor(a, b, c, normal = new Vector3()) {
    (this.a = a), (this.b = b), (this.c = c), (this.normal = normal);
  }
}
Class(function zUtils3D() {
  (Math.euclideanModulo = function (n, m) {
    return ((n % m) + m) % m;
  }),
    (Math.isPowerOf2 = function (w, h) {
      let test = (value) => 0 == (value & (value - 1));
      return test(w) && test(h);
    }),
    (Math.floorPowerOf2 = function (value) {
      return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    }),
    (Geometry.TYPES = {
      SphereGeometry: SphereGeometry,
      IcosahedronGeometry: IcosahedronGeometry,
      BoxGeometry: BoxGeometry,
      PlaneGeometry: PlaneGeometry,
      CylinderGeometry: CylinderGeometry,
    }),
    (Vector3.prototype.isVector3 = !0),
    (Vector2.prototype.isVector2 = !0),
    (CameraBase3D.prototype.isCamera = !0),
    (PerspectiveCamera.prototype.isPerspective = !0),
    (Ray.prototype.intersectTriangle = (function () {
      var diff = new Vector3(),
        edge1 = new Vector3(),
        edge2 = new Vector3(),
        normal = new Vector3();
      return function intersectTriangle(a, b, c, backfaceCulling, target) {
        edge1.subVectors(b, a),
          edge2.subVectors(c, a),
          normal.crossVectors(edge1, edge2);
        var sign,
          DdN = this.direction.dot(normal);
        if (DdN > 0) {
          if (backfaceCulling) return null;
          sign = 1;
        } else {
          if (!(DdN < 0)) return null;
          (sign = -1), (DdN = -DdN);
        }
        diff.subVectors(this.origin, a);
        var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
        if (DdQxE2 < 0) return null;
        var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
        if (DdE1xQ < 0) return null;
        if (DdQxE2 + DdE1xQ > DdN) return null;
        var QdN = -sign * diff.dot(normal);
        return QdN < 0 ? null : this.at(QdN / DdN, target);
      };
    })()),
    (Mesh.prototype.raycast = (function () {
      function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
        return (
          Triangle.getBarycoord(point, p1, p2, p3, barycoord),
          uv1.multiplyScalar(barycoord.x),
          uv2.multiplyScalar(barycoord.y),
          uv3.multiplyScalar(barycoord.z),
          uv1.add(uv2).add(uv3),
          uv1.clone()
        );
      }
      function checkIntersection(
        object,
        shader,
        raycaster,
        ray,
        pA,
        pB,
        pC,
        point
      ) {
        let intersect;
        if (
          null ===
          (intersect =
            shader.side === Shader.BACK_SIDE
              ? ray.intersectTriangle(pC, pB, pA, !0, point)
              : ray.intersectTriangle(
                  pA,
                  pB,
                  pC,
                  shader.side !== Shader.DOUBLE_SIDE,
                  point
                ))
        )
          return null;
        intersectionPointWorld.copy(point),
          intersectionPointWorld.applyMatrix4(object.matrixWorld);
        let distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
        return distance < raycaster.near || distance > raycaster.far
          ? null
          : {
              distance: distance,
              point: intersectionPointWorld.clone(),
              object: object,
            };
      }
      function checkBufferGeometryIntersection(
        object,
        raycaster,
        ray,
        position,
        uv,
        a,
        b,
        c
      ) {
        vA.fromBufferAttribute(position, a),
          vB.fromBufferAttribute(position, b),
          vC.fromBufferAttribute(position, c);
        let intersection = checkIntersection(
          object,
          object.shader,
          raycaster,
          ray,
          vA,
          vB,
          vC,
          intersectionPoint
        );
        if (intersection) {
          uv &&
            (uvA.fromBufferAttribute(uv, a),
            uvB.fromBufferAttribute(uv, b),
            uvC.fromBufferAttribute(uv, c),
            (intersection.uv = uvIntersection(
              intersectionPoint,
              vA,
              vB,
              vC,
              uvA,
              uvB,
              uvC
            )));
          let face = new Face3(a, b, c);
          Triangle.getNormal(vA, vB, vC, face.normal),
            (intersection.face = face);
        }
        return intersection;
      }
      let inverseMatrix = new Matrix4(),
        ray = new Ray(),
        sphere = new Sphere(),
        vA = new Vector3(),
        vB = new Vector3(),
        vC = new Vector3(),
        uvA =
          (new Vector3(),
          new Vector3(),
          new Vector3(),
          new Vector3(),
          new Vector2()),
        uvB = new Vector2(),
        uvC = new Vector2(),
        barycoord = new Vector3(),
        intersectionPoint = new Vector3(),
        intersectionPointWorld = new Vector3();
      return function raycast(raycaster, intersects) {
        let geometry = this.geometry,
          shader = this.shader,
          matrixWorld = this.matrixWorld;
        if (void 0 === shader) return;
        if (
          (null === geometry.boundingSphere && geometry.computeBoundingSphere(),
          sphere.copy(geometry.boundingSphere),
          sphere.applyMatrix4(matrixWorld),
          !1 === raycaster.ray.intersectsSphere(sphere))
        )
          return;
        if (
          (inverseMatrix.getInverse(matrixWorld),
          ray.copy(raycaster.ray).applyMatrix4(inverseMatrix),
          null !== geometry.boundingBox &&
            !1 === ray.intersectsBox(geometry.boundingBox))
        )
          return;
        let intersection,
          a,
          b,
          c,
          i,
          l,
          index = geometry.index,
          position = geometry.attributes.position,
          uv = geometry.attributes.uv;
        if (null !== index)
          for (i = 0, l = index.length; i < l; i += 3)
            (a = index[i]),
              (b = index[i + 1]),
              (c = index[i + 2]),
              (intersection = checkBufferGeometryIntersection(
                this,
                raycaster,
                ray,
                position,
                uv,
                a,
                b,
                c
              )) &&
                ((intersection.faceIndex = Math.floor(i / 3)),
                intersects.push(intersection));
        else if (void 0 !== position)
          for (i = 0, l = position.count; i < l; i += 3)
            (intersection = checkBufferGeometryIntersection(
              this,
              raycaster,
              ray,
              position,
              uv,
              (a = i),
              (b = i + 1),
              (c = i + 2)
            )) &&
              ((intersection.faceIndex = Math.floor(i / 3)),
              intersects.push(intersection));
      };
    })()),
    (Triangle.prototype.closestPointToPoint = (function () {
      let plane = new Plane(),
        edgeList = [new Line3(), new Line3(), new Line3()],
        projectedPoint = new Vector3(),
        closestPoint = new Vector3();
      return function closestPointToPoint(point, target = new Vector3()) {
        let minDistance = 1 / 0;
        if (
          (plane.setFromCoplanarPoints(this.a, this.b, this.c),
          plane.projectPoint(point, projectedPoint),
          !0 === this.containsPoint(projectedPoint))
        )
          target.copy(projectedPoint);
        else {
          edgeList[0].set(this.a, this.b),
            edgeList[1].set(this.b, this.c),
            edgeList[2].set(this.c, this.a);
          for (let i = 0; i < edgeList.length; i++) {
            edgeList[i].closestPointToPoint(projectedPoint, !0, closestPoint);
            let distance = projectedPoint.distanceToSquared(closestPoint);
            distance < minDistance &&
              ((minDistance = distance), target.copy(closestPoint));
          }
        }
        return target;
      };
    })()),
    (Points.prototype.raycast = (function () {
      let inverseMatrix = new Matrix4(),
        ray = new Ray(),
        sphere = new Sphere();
      return function raycast(raycaster, intersects) {
        function testPoint(point, index) {
          let rayPointDistanceSq = ray.distanceSqToPoint(point);
          if (rayPointDistanceSq < localThresholdSq) {
            ray.closestPointToPoint(point, intersectPoint),
              intersectPoint.applyMatrix4(matrixWorld);
            let distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far) return;
            intersects.push({
              distance: distance,
              distanceToRay: Math.sqrt(rayPointDistanceSq),
              point: intersectPoint.clone(),
              index: index,
              face: null,
              object: object,
            });
          }
        }
        let object = this,
          geometry = this.geometry,
          matrixWorld = this.matrixWorld,
          threshold = raycaster.params.Points.threshold;
        if (
          (null === geometry.boundingSphere && geometry.computeBoundingSphere(),
          sphere.copy(geometry.boundingSphere),
          sphere.applyMatrix4(matrixWorld),
          (sphere.radius += threshold),
          !1 === raycaster.ray.intersectsSphere(sphere))
        )
          return;
        inverseMatrix.getInverse(matrixWorld),
          ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        let localThreshold =
            threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          localThresholdSq = localThreshold * localThreshold,
          position = new Vector3(),
          intersectPoint = new Vector3(),
          index = geometry.index,
          positions = geometry.attributes.position.array;
        if (null !== index) {
          let indices = index.array;
          for (let i = 0, il = indices.length; i < il; i++) {
            let a = indices[i];
            position.fromArray(positions, 3 * a), testPoint(position, a);
          }
        } else
          for (let i = 0, l = positions.length / 3; i < l; i++)
            position.fromArray(positions, 3 * i), testPoint(position, i);
      };
    })()),
    Object.assign(Triangle, {
      getNormal: (function () {
        var v0 = new Vector3();
        return function getNormal(a, b, c, target = new Vector3()) {
          target.subVectors(c, b), v0.subVectors(a, b), target.cross(v0);
          var targetLengthSq = target.lengthSq();
          return targetLengthSq > 0
            ? target.multiplyScalar(1 / Math.sqrt(targetLengthSq))
            : target.set(0, 0, 0);
        };
      })(),
      getBarycoord: (function () {
        var v0 = new Vector3(),
          v1 = new Vector3(),
          v2 = new Vector3();
        return function getBarycoord(point, a, b, c, target = new Vector3()) {
          v0.subVectors(c, a), v1.subVectors(b, a), v2.subVectors(point, a);
          var dot00 = v0.dot(v0),
            dot01 = v0.dot(v1),
            dot02 = v0.dot(v2),
            dot11 = v1.dot(v1),
            dot12 = v1.dot(v2),
            denom = dot00 * dot11 - dot01 * dot01;
          if (0 === denom) return target.set(-2, -1, -1);
          var invDenom = 1 / denom,
            u = (dot11 * dot02 - dot01 * dot12) * invDenom,
            v = (dot00 * dot12 - dot01 * dot02) * invDenom;
          return target.set(1 - u - v, v, u);
        };
      })(),
      containsPoint: (function () {
        var v1 = new Vector3();
        return function containsPoint(point, a, b, c) {
          return (
            Triangle.getBarycoord(point, a, b, c, v1),
            v1.x >= 0 && v1.y >= 0 && v1.x + v1.y <= 1
          );
        };
      })(),
    });
}, "static"),
  Class(function FXLayer(_parentNuke, _type, _preventDrawBuffers = !1) {
    function editShader(mesh) {
      let modifyShader = (shader, name) => {
          let fs = shader._fragmentShader;
          if (!fs) return;
          let marker = "#drawbuffer " + name;
          if (fs.includes(marker)) {
            let split = fs.split(marker + " ");
            fs = split[0] + split[1];
          }
          for (; fs.includes("#drawbuffer"); ) {
            fs = fs.split("\n");
            for (let i = 0; i < fs.length; i++)
              fs[i].includes("#drawbuffer") && (fs[i] = "");
            fs = fs.join("\n");
          }
          shader.fragmentShader = fs;
        },
        applyShadow = (shader, bool) => {
          let fs = shader.fragmentShader;
          if (fs) {
            for (; fs.includes("#applyShadow"); ) {
              fs = fs.split("\n");
              for (let i = 0; i < fs.length; i++)
                bool
                  ? fs[i].includes("#applyShadow") &&
                    (fs[i] = fs[i].replace("#applyShadow", ""))
                  : fs[i].includes("#applyShadow") && (fs[i] = "");
              fs = fs.join("\n");
            }
            shader.fragmentShader = fs;
          }
        };
      mesh.shader._fragmentShader ||
        (mesh.shader._fragmentShader = mesh.shader.fragmentShader),
        modifyShader(mesh.shader, "Color");
      let shader = mesh.shader.clone(
        !_this.renderShadows,
        `-${_this.name || _name}`
      );
      modifyShader(shader, _this.name || _name),
        applyShadow(shader, _this.renderShadows),
        applyShadow(mesh.shader, !0),
        mesh.shader.copyUniformsTo(shader, !0),
        (mesh.shader = shader);
    }
    function editDBShader(mesh) {
      const WEBGL2 = Renderer.type == Renderer.WEBGL2;
      let modifyMarker = (fs, name, index) => {
          if (WEBGL2) {
            let mainAt = (fs = fs.replace("out vec4 FragColor;", "")).indexOf(
              "void main()"
            );
            fs =
              fs.slice(0, mainAt) +
              `layout(location=${index}) out vec4 ${name};\n` +
              fs.slice(mainAt);
          }
          let marker = "#drawbuffer " + name;
          if (fs.includes(marker)) {
            let split = fs.split(marker + " "),
              finalOut = WEBGL2 ? name : `gl_FragData[${index}]`;
            (split[1] = split[1].replace("gl_FragColor", finalOut)),
              (fs = split[0] + split[1]);
          }
          for (; fs.includes("#applyShadow"); ) {
            fs = fs.split("\n");
            for (let i = 0; i < fs.length; i++)
              fs[i].includes("#applyShadow") &&
                (fs[i] = fs[i].replace("#applyShadow", ""));
            fs = fs.join("\n");
          }
          return fs;
        },
        shader = mesh.shader,
        fs = shader.fragmentShader;
      (WEBGL2 && fs.includes("location=0")) ||
        (fs = modifyMarker(fs, "Color", 0)),
        (fs = modifyMarker(fs, _this.name || _name, _textureIndex)),
        (shader.fragmentShader = fs);
    }
    function addListeners() {
      _this.events.sub(Events.RESIZE, resizeHandler);
    }
    function resizeHandler() {
      _rt.setSize &&
        _rt.setSize(
          _nuke.stage.width * _this.resolution * _nuke.dpr,
          _nuke.stage.height * _this.resolution * _nuke.dpr
        );
    }
    function initRT(rt) {
      if (_useDrawBuffers) {
        let texture = new Texture();
        (texture.minFilter = Texture.LINEAR),
          (texture.magFilter = Texture.LINEAR),
          (texture.format = Texture.RGBFormat),
          _this.rtType && (texture.type = _this.rtType),
          _this.rtFormat && (texture.type = _this.rtFormat),
          (texture.wrapS = texture.wrapT = Texture.CLAMP_TO_EDGE),
          (texture.fxLayer = _this),
          (_this.textureIndex = _textureIndex =
            _parentNuke.attachDrawBuffer(texture)),
          (_rt = { texture: texture });
      } else _rt = rt || Utils3D.createRT(_nuke.stage.width * _this.resolution * _nuke.dpr, _nuke.stage.height * _this.resolution * _nuke.dpr, _this.rtType || Texture.RGBFormat);
      (_this.rt = _rt), _this.nuke.setSize(_rt.width, _rt.height);
    }
    Inherit(this, Component);
    var _nuke,
      _rt,
      _this = this,
      _scene = new Scene(),
      _objects = [],
      _textureIndex = -1,
      _id = Utils.timestamp(),
      _name = Utils.getConstructorName(_this),
      _useDrawBuffers = !_preventDrawBuffers;
    (this.resolution = 1),
      (this.enabled = !0),
      (this.renderShadows = !0),
      (this.create = function (nuke = World.NUKE, type, rt) {
        if (!nuke) return;
        _useDrawBuffers = nuke.useDrawBuffers;
        let format;
        type &&
          "object" == typeof type &&
          ("boolean" == typeof type.useDrawBuffers &&
            (_useDrawBuffers = type.useDrawBuffers),
          (format = type.format),
          (type = type.type)),
          type && (_this.rtType = type),
          format && (_this.rtFormat = format),
          ((_this = this).scene = _scene),
          ((_nuke = _this.initClass(Nuke, nuke.stage, {
            renderer: nuke.renderer,
            camera: nuke.camera,
            scene: _scene,
            dpr: nuke.dpr,
            useDrawBuffers: !1,
          })).parentNuke = nuke),
          (_parentNuke = nuke),
          (_this.nuke = _nuke),
          initRT(rt),
          addListeners();
      }),
      (this.addObject = this.add =
        function (object) {
          if (_nuke)
            if (_useDrawBuffers)
              object.shader &&
                object.shader.fragmentShader &&
                editDBShader(object);
            else {
              let clone = object.clone();
              for (
                object["clone_" + _id] = clone,
                  _scene.add(clone),
                  _objects.push(object),
                  object.shader && editShader(clone);
                clone.children.length;

              )
                clone.remove(clone.children[0]);
            }
        }),
      (this.removeObject = function (object) {
        _nuke &&
          (_scene.remove(object["clone_" + _id]),
          _objects.remove(object),
          delete object["clone_" + _id]);
      }),
      (this.render = this.draw =
        function (stage, camera) {
          if (
            _nuke &&
            _this.enabled &&
            !_useDrawBuffers &&
            _parentNuke.enabled &&
            _objects.length
          ) {
            stage &&
              ((_nuke.stage = stage), _this.setSize(stage.width, stage.height)),
              (_nuke.camera = camera || _nuke.parentNuke.camera),
              _this.renderShadows ||
                (_nuke.renderer.overridePreventShadows = !0);
            for (let i = _objects.length - 1; i > -1; i--) {
              let obj = _objects[i],
                clone = obj["clone_" + _id];
              _this.forceVisible
                ? (clone.visible = !0)
                : (clone.visible = obj.determineVisible()),
                clone.visible &&
                  (obj.updateMatrixWorld(),
                  obj.ignoreMatrix || Utils3D.decompose(obj, clone));
            }
            (_nuke.rtt = _rt),
              _nuke.render(),
              (_nuke.renderer.overridePreventShadows = !1);
          }
        }),
      (this.addPass = function (pass) {
        _nuke && _nuke.add(pass);
      }),
      (this.removePass = function (pass) {
        _nuke && _nuke.remove(pass);
      }),
      (this.setSize = function (width, height) {
        _nuke &&
          ((_rt.width == width && _rt.height == height) ||
            (_this.events.unsub(Events.RESIZE, resizeHandler),
            _rt &&
              _rt.setSize(
                width * _this.resolution * _nuke.dpr,
                height * _this.resolution * _nuke.dpr
              ),
            _nuke.setSize(
              width * _this.resolution * _nuke.dpr,
              height * _this.resolution * _nuke.dpr
            )));
      }),
      (this.setDPR = function (dpr) {
        _nuke && ((_nuke.dpr = dpr), resizeHandler());
      }),
      (this.setResolution = function (res) {
        (_this.resolution = res), resizeHandler();
      }),
      (this.getObjects = function () {
        return _objects;
      }),
      (this.useRT = function (rt) {
        _rt = _this.rt = rt;
      }),
      _parentNuke instanceof Nuke && this.create(_parentNuke, _type);
  }),
  Namespace("FX"),
  Class(function FXScene(_parentNuke, _type) {
    function initRT(rt, options = {}) {
      options.type == Texture.FLOAT && (options.format = Texture.RGBAFormat),
        (_this.width = _nuke.stage.width * _this.resolution * _nuke.dpr),
        (_this.height = _nuke.stage.height * _this.resolution * _nuke.dpr),
        (_rt =
          rt ||
          new RenderTarget(
            _this.width,
            _this.height,
            Object.assign(
              {
                minFilter: Texture.LINEAR,
                magFilter: Texture.LINEAR,
                generateMipmaps: !1,
              },
              options
            )
          )),
        (_this.rt = _rt),
        (_rt.fxscene = _this);
    }
    function addListeners() {
      _this.events.sub(Events.RESIZE, resizeHandler);
    }
    function resizeHandler() {
      _rt.setSize &&
        _rt.setSize(
          _nuke.stage.width * _this.resolution * _nuke.dpr,
          _nuke.stage.height * _this.resolution * _nuke.dpr
        ),
        _this.nuke.setSize(_rt.width, _rt.height);
    }
    Inherit(this, Component);
    var _nuke,
      _rt,
      _this = this,
      _scene = new Scene(),
      _id = Utils.timestamp(),
      _objects = [],
      _visible = !0;
    (this.resolution = 1),
      (this.autoVisible = !0),
      (this.enabled = !0),
      (this.scene = _scene),
      (this.renderShadows = !1),
      this.set("visible", (v) => (_this.scene.visible = _visible = v)),
      this.get("visible", (_) => _visible),
      (this.create = function (nuke = World.NUKE, rt, options) {
        rt &&
          "object" == typeof rt &&
          (rt.isRT || ((options = rt), (rt = void 0))),
          ((_this = this).scene = _scene),
          (_this.nuke = _nuke =
            _this.initClass(Nuke, nuke.stage, {
              renderer: nuke.renderer,
              camera: nuke.camera,
              scene: _scene,
              dpr: nuke.dpr,
            })),
          (_scene.nuke = _nuke),
          initRT(rt, options),
          rt ? _this.flag("recycle_rt", !0) : addListeners();
      }),
      (this.onDestroy = function () {
        (_this.scene.deleted = !0),
          _this.flag("recycle_rt") || (_rt && _rt.destroy && _rt.destroy());
      }),
      (this.setSize = function (width, height, exact) {
        _nuke &&
          ((_rt.width == width && _rt.height == height) ||
            (_this.events.unsub(Events.RESIZE, resizeHandler),
            exact
              ? ((_this.width = width), (_this.height = height))
              : ((_this.width = width * _this.resolution * _nuke.dpr),
                (_this.height = height * _this.resolution * _nuke.dpr)),
            _rt && _rt.setSize(_this.width, _this.height),
            _nuke.setSize(_this.width, _this.height)));
      }),
      (this.add = this.addObject =
        function (object) {
          let clone = object.clone();
          for (
            object["clone_" + _id] = clone,
              _scene.add(clone),
              _objects.push(object);
            clone.children.length;

          )
            clone.remove(clone.children[0]);
          return clone;
        }),
      (this.removeObject = function (object) {
        _scene.remove(object["clone_" + _id]),
          _objects.remove(object),
          delete object["clone_" + _id];
      }),
      (this.render = this.draw =
        function (stage, camera) {
          stage &&
            (_this.events.unsub(Events.RESIZE, resizeHandler),
            _this.nuke.setSize(stage.width, stage.height),
            (_this.nuke.stage = stage)),
            camera && (_this.nuke.camera = camera);
          let clearColor = null,
            alpha = 1;
          _this.clearColor &&
            ((clearColor = _nuke.renderer.getClearColor().getHex()),
            _nuke.renderer.setClearColor(_this.clearColor)),
            _this.clearAlpha > -1 &&
              ((alpha = _nuke.renderer.getClearAlpha()),
              _nuke.renderer.setClearAlpha(_this.clearAlpha)),
            _this.renderShadows || (_nuke.renderer.overridePreventShadows = !0);
          for (let i = _objects.length - 1; i > -1; i--) {
            let obj = _objects[i],
              clone = obj["clone_" + _id];
            _this.forceVisible || obj.cloneVisible
              ? (clone.visible =
                  "boolean" != typeof clone.isVisible || clone.isVisible)
              : (clone.visible = obj.determineVisible()),
              clone.visible &&
                (obj.updateMatrixWorld(!1 === obj.visible || void 0),
                obj.ignoreMatrix ||
                  (Utils3D.decompose(obj, clone),
                  clone.overrideScale &&
                    clone.scale.setScalar(clone.overrideScale)));
          }
          _this.preventRTDraw || ((_nuke.rtt = _rt), _nuke.render()),
            (_nuke.renderer.overridePreventShadows = !1),
            _this.clearColor && _nuke.renderer.setClearColor(clearColor),
            _this.clearAlpha > -1 &&
              _nuke.renderer.setClearAlpha(_this.clearAlpha);
        }),
      (this.setDPR = function (dpr) {
        return _nuke ? ((_nuke.dpr = dpr), resizeHandler(), _this) : _this;
      }),
      (this.addPass = function (pass) {
        _nuke && _nuke.add(pass);
      }),
      (this.removePass = function (pass) {
        _nuke && _nuke.remove(pass);
      }),
      (this.setResolution = function (res) {
        return (_this.resolution = res), resizeHandler(), this;
      }),
      (this.useRT = function (rt) {
        _rt = _this.rt = rt;
      }),
      (this.upload = function () {
        _rt && _rt.upload();
      }),
      (this.useCamera = function (camera) {
        _this.nuke.camera = camera.camera || camera;
      }),
      (this.useScene = function (scene) {
        _this.nuke.scene = scene;
      }),
      (this.createDepthTexture = function () {
        return (
          _this.nuke.passes.length
            ? (_this.nuke.rttBuffer.createDepthTexture(),
              (_this.depthTexture = _this.nuke.rttBuffer.depth))
            : (_this.rt.createDepthTexture(),
              (_this.depthTexture = _this.rt.depth)),
          _this.depthTexture
        );
      }),
      _parentNuke instanceof Nuke && this.create(_parentNuke, _type);
  }),
  Class(function BlitPass(_forceNuke) {
    Inherit(this, NukePass);
    (this.uniforms = {}),
      this.init("BlitPass"),
      _forceNuke || (this.blitFramebuffer = !0);
  }),
  Class(
    function Nuke(_stage, _params) {
      function initNuke() {
        var width = _this.stage.width * _dpr,
          height = _this.stage.height * _dpr;
        (_rttPing = Nuke.getRT(width, height, !1)),
          (_rttPong = Nuke.getRT(width, height, !1)),
          (_rttBuffer = Nuke.getRT(width, height, _this.useDrawBuffers)),
          (_rttCamera = Nuke.getCamera()),
          (_nukeScene = new Scene()),
          (_nukeMesh = new Mesh(Nuke.getTri(), null)),
          _nukeScene.add(_nukeMesh),
          (_width = width),
          (_height = height);
      }
      function finalRender(scene, camera) {
        _this.renderer.render(scene, camera || _this.camera, _this.rtt),
          _this.postRender && _this.postRender();
      }
      function blitFBO() {
        _this.rtt && !_this.rtt._gl && _this.rtt.upload();
        let gl = _this.renderer.context;
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, _rttBuffer._gl),
          gl.bindFramebuffer(
            gl.DRAW_FRAMEBUFFER,
            _this.rtt ? _this.rtt._gl : null
          ),
          gl.blitFramebuffer(
            0,
            0,
            _rttBuffer.width,
            _rttBuffer.height,
            0,
            0,
            _this.renderer.canvas.width,
            _this.renderer.canvas.height,
            gl.COLOR_BUFFER_BIT,
            gl.LINEAR
          ),
          _this.postRender && _this.postRender();
      }
      function addListeners() {
        _this.events.sub(Events.RESIZE, resizeHandler);
      }
      function resizeHandler() {
        var width = _this.stage.width * _dpr,
          height = _this.stage.height * _dpr;
        _rttPing.setSize(width, height),
          _rttPong.setSize(width, height),
          _rttBuffer.setSize(width, height);
      }
      Inherit(this, Component);
      var _width,
        _height,
        _this = this;
      _params.renderer || console.error("Nuke :: Must define renderer"),
        (_this.stage = _stage),
        (_this.renderer = _params.renderer),
        (_this.camera = _params.camera),
        (_this.scene = _params.scene),
        (_this.rtt = _params.rtt),
        (_this.enabled = 0 != _params.enabled),
        (_this.passes = _params.passes || []),
        (_this.useDrawBuffers =
          void 0 !== _params.useDrawBuffers
            ? _params.useDrawBuffers
            : Renderer.type == Renderer.WEBGL2 ||
              (!Utils.query("noDrawBuffers") &&
                !Nuke.NO_DRAWBUFFERS &&
                Device.graphics.webgl &&
                Device.graphics.webgl.detect("draw_buffers")));
      var _rttPing,
        _rttPong,
        _nukeScene,
        _nukeMesh,
        _rttCamera,
        _rttBuffer,
        _dpr = _params.dpr || 1,
        _drawBuffers = [];
      initNuke(),
        addListeners(),
        (_this.add = function (pass, index) {
          "number" != typeof index
            ? _this.passes.push(pass)
            : _this.passes.splice(index, 0, pass);
        }),
        (_this.remove = function (pass) {
          "number" == typeof pass
            ? _this.passes.splice(pass)
            : _this.passes.remove(pass);
        }),
        (_this.render = function () {
          if (
            (_this.onBeforeRender && _this.onBeforeRender(),
            !_this.enabled || !_this.passes.length)
          )
            return (
              finalRender(_this.scene),
              void (_this.onBeforeProcess && _this.onBeforeProcess())
            );
          (_this.hasRendered = !0),
            _this.onBeforeProcess && _this.onBeforeProcess(),
            _this.renderer.render(_this.scene, _this.camera, _rttBuffer, !0);
          let usedBuffer = !1,
            pingPong = !0,
            count = _this.passes.length - 1;
          if (
            0 == count &&
            _this.passes[0].blitFramebuffer &&
            Renderer.type == Renderer.WEBGL2
          )
            return blitFBO();
          for (var i = 0; i < count; i++)
            (_nukeMesh.shader = _this.passes[i].pass),
              (_nukeMesh.shader.depthTest = !1),
              (_nukeMesh.shader.frustumCulled = !1),
              (usedBuffer = !0),
              (_nukeMesh.shader.uniforms.tDiffuse.value =
                0 == i
                  ? _rttBuffer.texture
                  : pingPong
                  ? _rttPing.texture
                  : _rttPong.texture),
              _this.renderer.render(
                _nukeScene,
                _rttCamera,
                pingPong ? _rttPong : _rttPing
              ),
              (pingPong = !pingPong);
          (_nukeMesh.shader = _this.passes[_this.passes.length - 1].pass),
            (_nukeMesh.shader.uniforms.tDiffuse.value = usedBuffer
              ? pingPong
                ? _rttPing.texture
                : _rttPong.texture
              : _rttBuffer.texture),
            finalRender(_nukeScene, _rttCamera);
        }),
        (_this.setSize = function (width, height) {
          (width == _width && height == _height) ||
            ((_width = width), (_height = height), resizeHandler());
        }),
        (_this.attachDrawBuffer = function (texture) {
          if (
            (_this.hasRendered &&
              console.warn(
                "Attempt to attach draw buffer after first render! Create FXLayer instance before first render."
              ),
            _drawBuffers.push(texture),
            _rttBuffer && _rttBuffer.attachments)
          ) {
            _rttBuffer.attachments = [_rttBuffer.attachments[0]];
            for (let i = 0; i < _drawBuffers.length; i++)
              _rttBuffer.attachments.push(_drawBuffers[i]);
          }
          return _drawBuffers.length;
        }),
        _this.set("dpr", function (v) {
          (_dpr = v), resizeHandler();
        }),
        _this.get("dpr", function () {
          return _dpr;
        }),
        _this.get("output", function () {
          return _nukeMesh.shader && _nukeMesh.shader.uniforms
            ? _nukeMesh.shader.uniforms.tDiffuse.value
            : null;
        }),
        _this.get("rttBuffer", function () {
          return _rttBuffer;
        }),
        _this.get("prevFrameRT", function () {
          return _rttBuffer && _rttBuffer.texture ? _rttBuffer.texture : null;
        }),
        _this.get("nukeScene", function () {
          return _nukeScene;
        }),
        _this.get("ping", function () {
          return _rttPing;
        }),
        _this.get("pong", function () {
          return _rttPong;
        });
    },
    function () {
      var _camera, _geom;
      new WeakMap();
      (Nuke.getRT = function (width, height, multi) {
        return multi
          ? Utils3D.createMultiRT(width, height)
          : Utils3D.createRT(width, height);
      }),
        (Nuke.getCamera = function () {
          return (
            _camera ||
              (_camera = new OrthographicCamera(
                Stage.width / -2,
                Stage.width / 2,
                Stage.height / 2,
                Stage.height / -2,
                1,
                1e3
              )),
            _camera
          );
        }),
        (Nuke.getTri = function () {
          if (!_geom) {
            _geom = new Geometry();
            let position = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
              uv = new Float32Array([0, 0, 2, 0, 0, 2]);
            _geom.addAttribute("position", new GeometryAttribute(position, 3)),
              _geom.addAttribute("uv", new GeometryAttribute(uv, 2));
          }
          return _geom;
        });
    }
  ),
  Class(function NukePass(_fs, _uniforms, _pass) {
    function prefix(code) {
      if (!code) throw `No shader ${_fs} found`;
      let pre = "";
      return (
        code.includes("uniform sampler2D tDiffuse") ||
          ((pre += "uniform sampler2D tDiffuse;\n"),
          (pre += "varying vec2 vUv;\n")),
        (code = pre + code)
      );
    }
    Inherit(this, Component);
    var _this = this;
    (this.UILPrefix =
      "string" == typeof _fs ? _fs : Utils.getConstructorName(_fs)),
      (this.init = function (fs, vs) {
        if (_this.pass) return;
        _this = this;
        fs || this.constructor.toString().match(/function ([^\(]+)/)[1],
          Array.isArray(fs) && fs.join("");
        if (
          ((_this.uniforms = _uniforms || _this.uniforms || {}),
          (_this.uniforms.tDiffuse = { type: "t", value: null, ignoreUIL: !0 }),
          _this.uniforms.unique &&
            (_this.UILPrefix += "_" + _this.uniforms.unique + "_"),
          window.UILStorage)
        )
          for (let key in _this.uniforms)
            "unique" !== key &&
              (_this.uniforms[key] =
                UILStorage.parse(
                  _this.UILPrefix + key,
                  _this.uniforms[key].value
                ) || _this.uniforms[key]);
        (_this.pass = _this.initClass(
          Shader,
          vs || "NukePass",
          fs,
          Utils.mergeObject(_this.uniforms, { precision: "high" }),
          (code, type) => ("fs" == type ? prefix(code) : code)
        )),
          (_this.uniforms = _this.pass.uniforms);
      }),
      (this.set = function (key, value) {
        TweenManager.clearTween(_this.uniforms[key]),
          (_this.uniforms[key].value = value);
      }),
      (this.get = function (key) {
        return void 0 === _this.uniforms[key]
          ? null
          : _this.uniforms[key].value;
      }),
      (this.tween = function (key, value, time, ease, delay, callback, update) {
        return tween(
          _this.uniforms[key],
          { value: value },
          time,
          ease,
          delay,
          callback,
          update
        );
      }),
      (this.clone = function () {
        return (
          _this.pass || _this.init(_fs),
          new NukePass(null, null, _this.pass.clone())
        );
      }),
      (this.upload = function () {
        _this.pass.upload();
      }),
      "string" == typeof _fs
        ? _this.init(_fs)
        : _pass && ((_this.pass = _pass), (_this.uniforms = _pass.uniforms));
  }),
  Class(
    function Raycaster(_camera) {
      function ascSort(a, b) {
        return a.distance - b.distance;
      }
      function intersectObject(object, raycaster, intersects, recursive) {
        let obj = object;
        for (; obj && _this.testVisibility; ) {
          if (
            !1 === obj.visible &&
            !obj.forceRayVisible &&
            !1 !== obj.testVisibility
          )
            return;
          obj = obj.parent;
        }
        if (
          object.raycast &&
          (object.raycast(raycaster, intersects), !0 === recursive)
        ) {
          let children = object.children;
          for (let i = 0, l = children.length; i < l; i++)
            intersectObject(children[i], raycaster, intersects, !0);
        }
      }
      function intersect(objects) {
        Array.isArray(objects) || (objects = [objects]);
        let intersects = [];
        return (
          objects.forEach((object) => {
            intersectObject(object, _raycaster, intersects, !1);
          }),
          intersects.sort(ascSort),
          intersects
        );
      }
      Inherit(this, Component);
      const _this = this;
      let _mouse = new Vector3(),
        _raycaster = new RayManager();
      (this.testVisibility = !0),
        this.set("camera", function (camera) {
          _camera = camera;
        }),
        this.set("pointsThreshold", function (value) {
          _raycaster.params.Points.threshold = value;
        }),
        this.get("ray", () => _raycaster.ray),
        (this.checkHit = function (objects, mouse, rect = Stage) {
          return (
            (mouse = mouse || Mouse) === Mouse && rect === Stage
              ? _mouse.copy(Mouse.tilt)
              : ((_mouse.x = (mouse.x / rect.width) * 2 - 1),
                (_mouse.y = (-mouse.y / rect.height) * 2 + 1)),
            _raycaster.setFromCamera(_mouse, _camera),
            intersect(objects)
          );
        }),
        (this.checkFromValues = function (objects, origin, direction) {
          return (
            _raycaster.set(origin, direction, 0, Number.POSITIVE_INFINITY),
            intersect(objects)
          );
        });
    },
    (_) => {
      var _ray,
        _map = new WeakMap();
      (Raycaster.checkHit = function (objects, mouse) {
        return (
          _ray || (_ray = new Raycaster(World.CAMERA)),
          _ray.checkHit(objects, mouse)
        );
      }),
        (Raycaster.checkFromValues = function (objects, origin, direction) {
          return (
            _ray || (_ray = new Raycaster(World.CAMERA)),
            _ray.checkFromValues(objects, origin, direction)
          );
        }),
        (Raycaster.find = function (camera) {
          if (!_map.has(camera)) {
            let ray = new Raycaster(camera);
            _map.set(camera, ray);
          }
          return _map.get(camera);
        });
    }
  ),
  Class(
    function ScreenProjection(_camera) {
      Inherit(this, Component);
      var _this = this,
        _v3 = new Vector3(),
        _v32 = new Vector3(),
        _value = new Vector3();
      (_camera = _camera.camera || _camera),
        this.set("camera", function (v) {
          _camera = v.camera || v;
        }),
        this.get("camera", (_) => _camera),
        (this.unproject = function (mouse, distance = 0) {
          let rect = _this.rect || Stage;
          _v3.set(
            (mouse.x / rect.width) * 2 - 1,
            (-mouse.y / rect.height) * 2 + 1,
            0.5
          ),
            _v3.unproject(_camera);
          let pos = _camera.getWorldPosition();
          return (
            _v3.sub(pos).normalize(),
            _value.copy(pos).add(_v3.multiplyScalar(distance)),
            _value
          );
        }),
        (this.project = function (pos, screen) {
          return (
            (screen = screen || Stage),
            pos instanceof Base3D
              ? (pos.updateMatrixWorld(),
                _v32.set(0, 0, 0).setFromMatrixPosition(pos.matrixWorld))
              : _v32.copy(pos),
            _v32.project(_camera),
            (_v32.x = ((_v32.x + 1) / 2) * screen.width),
            (_v32.y = (-(_v32.y - 1) / 2) * screen.height),
            _v32
          );
        });
    },
    (_) => {
      var _screen,
        _map = new WeakMap();
      (ScreenProjection.unproject = function (mouse, distance) {
        return (
          _screen || (_screen = new ScreenProjection(World.CAMERA)),
          _screen.unproject(mouse, distance)
        );
      }),
        (ScreenProjection.project = function (pos, screen) {
          return (
            _screen || (_screen = new ScreenProjection(World.CAMERA)),
            _screen.project(pos, screen)
          );
        }),
        (ScreenProjection.find = function (camera) {
          if (!_map.has(camera)) {
            let projection = new ScreenProjection(camera);
            _map.set(camera, projection);
          }
          return _map.get(camera);
        });
    }
  ),
  (window.DebugControls = function (object, domElement) {
    function getAutoRotationAngle() {
      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    function dollyIn(dollyScale) {
      scope.object instanceof PerspectiveCamera
        ? (scale /= dollyScale)
        : scope.object instanceof OrthographicCamera
        ? ((scope.object.zoom = Math.max(
            scope.minZoom,
            Math.min(scope.maxZoom, scope.object.zoom * dollyScale)
          )),
          scope.object.updateProjectionMatrix(),
          (zoomChanged = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (scope.enableZoom = !1));
    }
    function dollyOut(dollyScale) {
      scope.object instanceof PerspectiveCamera
        ? (scale *= dollyScale)
        : scope.object instanceof OrthographicCamera
        ? ((scope.object.zoom = Math.max(
            scope.minZoom,
            Math.min(scope.maxZoom, scope.object.zoom / dollyScale)
          )),
          scope.object.updateProjectionMatrix(),
          (zoomChanged = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (scope.enableZoom = !1));
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY),
        rotateDelta.subVectors(rotateEnd, rotateStart);
      var element =
        scope.domElement === document
          ? scope.domElement.body
          : scope.domElement;
      rotateLeft(
        ((2 * Math.PI * rotateDelta.x) / element.clientWidth) *
          scope.rotateSpeed
      ),
        rotateUp(
          ((2 * Math.PI * rotateDelta.y) / element.clientHeight) *
            scope.rotateSpeed
        ),
        rotateStart.copy(rotateEnd),
        scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY),
        dollyDelta.subVectors(dollyEnd, dollyStart),
        dollyDelta.y > 0
          ? dollyIn(getZoomScale())
          : dollyDelta.y < 0 && dollyOut(getZoomScale()),
        dollyStart.copy(dollyEnd),
        scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY),
        panDelta.subVectors(panEnd, panStart),
        pan(panDelta.x, panDelta.y),
        panStart.copy(panEnd),
        scope.update(),
        scope.onChange && scope.onChange();
    }
    function handleMouseUp(event) {}
    function handleMouseWheel(event) {
      var delta = 0;
      void 0 !== event.wheelDelta
        ? (delta = event.wheelDelta)
        : void 0 !== event.detail && (delta = -event.detail),
        delta > 0
          ? dollyOut(getZoomScale())
          : delta < 0 && dollyIn(getZoomScale()),
        scope.update();
    }
    function handleKeyDown(event) {
      switch (event.keyCode) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed), scope.update();
          break;
        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed), scope.update();
          break;
        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0), scope.update();
          break;
        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0), scope.update();
      }
    }
    function handleTouchStartRotate(event) {
      rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    }
    function handleTouchStartDolly(event) {
      var dx = event.touches[0].pageX - event.touches[1].pageX,
        dy = event.touches[0].pageY - event.touches[1].pageY,
        distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartPan(event) {
      panStart.set(event.touches[0].pageX, event.touches[0].pageY);
    }
    function handleTouchMoveRotate(event) {
      rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY),
        rotateDelta.subVectors(rotateEnd, rotateStart);
      var element =
        scope.domElement === document
          ? scope.domElement.body
          : scope.domElement;
      rotateLeft(
        ((2 * Math.PI * rotateDelta.x) / element.clientWidth) *
          scope.rotateSpeed
      ),
        rotateUp(
          ((2 * Math.PI * rotateDelta.y) / element.clientHeight) *
            scope.rotateSpeed
        ),
        rotateStart.copy(rotateEnd),
        scope.update();
    }
    function handleTouchMoveDolly(event) {
      var dx = event.touches[0].pageX - event.touches[1].pageX,
        dy = event.touches[0].pageY - event.touches[1].pageY,
        distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance),
        dollyDelta.subVectors(dollyEnd, dollyStart),
        dollyDelta.y > 0
          ? dollyOut(getZoomScale())
          : dollyDelta.y < 0 && dollyIn(getZoomScale()),
        dollyStart.copy(dollyEnd),
        scope.update();
    }
    function handleTouchMovePan(event) {
      panEnd.set(event.touches[0].pageX, event.touches[0].pageY),
        panDelta.subVectors(panEnd, panStart),
        pan(panDelta.x, panDelta.y),
        panStart.copy(panEnd),
        scope.update();
    }
    function handleTouchEnd(event) {}
    function onMouseDown(event) {
      if (!1 !== scope.enabled) {
        if (
          (event.preventDefault(), event.button === scope.mouseButtons.ORBIT)
        ) {
          if (!1 === scope.enableRotate) return;
          handleMouseDownRotate(event), (state = STATE.ROTATE);
        } else if (event.button === scope.mouseButtons.ZOOM) {
          if (!1 === scope.enableZoom) return;
          handleMouseDownDolly(event), (state = STATE.DOLLY);
        } else if (event.button === scope.mouseButtons.PAN) {
          if (!1 === scope.enablePan) return;
          handleMouseDownPan(event), (state = STATE.PAN);
        }
        state !== STATE.NONE &&
          (document.addEventListener("mousemove", onMouseMove, !1),
          document.addEventListener("mouseup", onMouseUp, !1));
      }
    }
    function onMouseMove(event) {
      if (!1 !== scope.enabled)
        if ((event.preventDefault(), state === STATE.ROTATE)) {
          if (!1 === scope.enableRotate) return;
          handleMouseMoveRotate(event);
        } else if (state === STATE.DOLLY) {
          if (!1 === scope.enableZoom) return;
          handleMouseMoveDolly(event);
        } else if (state === STATE.PAN) {
          if (!1 === scope.enablePan) return;
          handleMouseMovePan(event);
        }
    }
    function onMouseUp(event) {
      !1 !== scope.enabled &&
        (handleMouseUp(event),
        document.removeEventListener("mousemove", onMouseMove, !1),
        document.removeEventListener("mouseup", onMouseUp, !1),
        scope.onChange && scope.onChange(),
        (state = STATE.NONE));
    }
    function onMouseWheel(event) {
      !1 === scope.enabled ||
        !1 === scope.enableZoom ||
        (state !== STATE.NONE && state !== STATE.ROTATE) ||
        (event.preventDefault(),
        event.stopPropagation(),
        handleMouseWheel(event),
        scope.onChange && scope.onChange());
    }
    function onKeyDown(event) {
      !1 !== scope.enabled &&
        !1 !== scope.enableKeys &&
        !1 !== scope.enablePan &&
        handleKeyDown(event);
    }
    function onTouchStart(event) {
      if (!1 !== scope.enabled) {
        switch (event.touches.length) {
          case 1:
            if (!1 === scope.enableRotate) return;
            handleTouchStartRotate(event), (state = STATE.TOUCH_ROTATE);
            break;
          case 2:
            if (!1 === scope.enableZoom) return;
            handleTouchStartDolly(event), (state = STATE.TOUCH_DOLLY);
            break;
          case 3:
            if (!1 === scope.enablePan) return;
            handleTouchStartPan(event), (state = STATE.TOUCH_PAN);
            break;
          default:
            state = STATE.NONE;
        }
        STATE.NONE;
      }
    }
    function onTouchMove(event) {
      if (!1 !== scope.enabled)
        switch (
          (event.preventDefault(),
          event.stopPropagation(),
          event.touches.length)
        ) {
          case 1:
            if (!1 === scope.enableRotate) return;
            if (state !== STATE.TOUCH_ROTATE) return;
            handleTouchMoveRotate(event);
            break;
          case 2:
            if (!1 === scope.enableZoom) return;
            if (state !== STATE.TOUCH_DOLLY) return;
            handleTouchMoveDolly(event);
            break;
          case 3:
            if (!1 === scope.enablePan) return;
            if (state !== STATE.TOUCH_PAN) return;
            handleTouchMovePan(event);
            break;
          default:
            state = STATE.NONE;
        }
    }
    function onTouchEnd(event) {
      !1 !== scope.enabled &&
        (handleTouchEnd(event),
        scope.onChange && scope.onChange(),
        (state = STATE.NONE));
    }
    function onContextMenu(event) {}
    (this.object = object),
      (this.domElement = void 0 !== domElement ? domElement : document),
      (this.enabled = !0),
      (this.target = new Vector3()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !0),
      (this.dampingFactor = 0.1),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 0.1),
      (this.enablePan = !0),
      (this.keyPanSpeed = 7),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.enableKeys = !1),
      (this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }),
      (this.mouseButtons = { ORBIT: 0, ZOOM: 2, PAN: 1 }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = function () {
        return spherical.phi;
      }),
      (this.getAzimuthalAngle = function () {
        return spherical.theta;
      }),
      (this.reset = function () {
        scope.target.copy(scope.target0),
          scope.object.position.copy(scope.position0),
          (scope.object.zoom = scope.zoom0),
          scope.object.updateProjectionMatrix(),
          scope.update(),
          (state = STATE.NONE);
      }),
      (this.update = (function () {
        var offset = new Vector3(),
          quat = new Quaternion().setFromUnitVectors(
            object.up,
            new Vector3(0, 1, 0)
          ),
          quatInverse = quat.clone().inverse(),
          lastPosition = new Vector3(),
          lastQuaternion = new Quaternion();
        return function update() {
          var position = scope.object.position;
          return (
            offset.copy(position).sub(scope.target),
            offset.applyQuaternion(quat),
            spherical.setFromVector3(offset),
            scope.autoRotate &&
              state === STATE.NONE &&
              rotateLeft(getAutoRotationAngle()),
            (spherical.theta += sphericalDelta.theta),
            (spherical.phi += sphericalDelta.phi),
            (spherical.theta = Math.max(
              scope.minAzimuthAngle,
              Math.min(scope.maxAzimuthAngle, spherical.theta)
            )),
            (spherical.phi = Math.max(
              scope.minPolarAngle,
              Math.min(scope.maxPolarAngle, spherical.phi)
            )),
            spherical.makeSafe(),
            (spherical.radius *= scale),
            (spherical.radius = Math.max(
              scope.minDistance,
              Math.min(scope.maxDistance, spherical.radius)
            )),
            scope.target.add(panOffset),
            offset.setFromSpherical(spherical),
            offset.applyQuaternion(quatInverse),
            position.copy(scope.target).add(offset),
            scope.object.lookAt(scope.target),
            !0 === scope.enableDamping
              ? ((sphericalDelta.theta *= 1 - scope.dampingFactor),
                (sphericalDelta.phi *= 1 - scope.dampingFactor))
              : sphericalDelta.set(0, 0, 0),
            (scale = 1),
            panOffset.set(0, 0, 0),
            !!(
              zoomChanged ||
              lastPosition.distanceToSquared(scope.object.position) > EPS ||
              8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS
            ) &&
              (lastPosition.copy(scope.object.position),
              lastQuaternion.copy(scope.object.quaternion),
              (zoomChanged = !1),
              !0)
          );
        };
      })()),
      (this.dispose = function () {
        scope.domElement.removeEventListener("contextmenu", onContextMenu, !1),
          scope.domElement.removeEventListener("mousedown", onMouseDown, !1),
          scope.domElement.removeEventListener("mousewheel", onMouseWheel, !1),
          scope.domElement.removeEventListener(
            "MozMousePixelScroll",
            onMouseWheel,
            !1
          ),
          scope.domElement.removeEventListener("touchstart", onTouchStart, !1),
          scope.domElement.removeEventListener("touchend", onTouchEnd, !1),
          scope.domElement.removeEventListener("touchmove", onTouchMove, !1),
          document.removeEventListener("mousemove", onMouseMove, !1),
          document.removeEventListener("mouseup", onMouseUp, !1),
          window.removeEventListener("keydown", onKeyDown, !1);
      });
    var scope = this,
      STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_DOLLY: 4,
        TOUCH_PAN: 5,
      },
      state = STATE.NONE,
      EPS = 1e-6,
      spherical = new Spherical(),
      sphericalDelta = new Spherical(),
      scale = 1,
      panOffset = new Vector3(),
      zoomChanged = !1,
      rotateStart = new Vector2(),
      rotateEnd = new Vector2(),
      rotateDelta = new Vector2(),
      panStart = new Vector2(),
      panEnd = new Vector2(),
      panDelta = new Vector2(),
      dollyStart = new Vector2(),
      dollyEnd = new Vector2(),
      dollyDelta = new Vector2(),
      panLeft = (function () {
        var v = new Vector3();
        return function panLeft(distance, objectMatrix) {
          v.setFromMatrixColumn(objectMatrix, 0),
            v.multiplyScalar(-distance),
            panOffset.add(v);
        };
      })(),
      panUp = (function () {
        var v = new Vector3();
        return function panUp(distance, objectMatrix) {
          v.setFromMatrixColumn(objectMatrix, 1),
            v.multiplyScalar(distance),
            panOffset.add(v);
        };
      })(),
      pan = (function () {
        var offset = new Vector3();
        return function pan(deltaX, deltaY) {
          var element =
            scope.domElement === document
              ? scope.domElement.body
              : scope.domElement;
          if (scope.object instanceof PerspectiveCamera) {
            var position = scope.object.position;
            offset.copy(position).sub(scope.target);
            var targetDistance = offset.length();
            (targetDistance *= Math.tan(
              ((scope.object.fov / 2) * Math.PI) / 180
            )),
              panLeft(
                (2 * deltaX * targetDistance) / element.clientHeight,
                scope.object.matrix
              ),
              panUp(
                (2 * deltaY * targetDistance) / element.clientHeight,
                scope.object.matrix
              );
          } else
            scope.object instanceof OrthographicCamera
              ? (panLeft(
                  (deltaX * (scope.object.right - scope.object.left)) /
                    scope.object.zoom /
                    element.clientWidth,
                  scope.object.matrix
                ),
                panUp(
                  (deltaY * (scope.object.top - scope.object.bottom)) /
                    scope.object.zoom /
                    element.clientHeight,
                  scope.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (scope.enablePan = !1));
        };
      })();
    scope.domElement.addEventListener("contextmenu", onContextMenu, !1),
      scope.domElement.addEventListener("mousedown", onMouseDown, !1),
      scope.domElement.addEventListener("mousewheel", onMouseWheel, !1),
      scope.domElement.addEventListener(
        "MozMousePixelScroll",
        onMouseWheel,
        !1
      ),
      scope.domElement.addEventListener("touchstart", onTouchStart, !1),
      scope.domElement.addEventListener("touchend", onTouchEnd, !1),
      scope.domElement.addEventListener("touchmove", onTouchMove, !1),
      window.addEventListener("keydown", onKeyDown, !1),
      this.update();
  }),
  Class(function GeomThread() {
    function computeBounding(data) {
      let geom = new Geometry();
      geom.addAttribute("position", new GeometryAttribute(data.position, 3)),
        geom.computeBoundingBox(),
        geom.computeBoundingSphere(),
        (data.boundingBox = geom.boundingBox),
        (data.boundingSphere = geom.boundingSphere);
    }
    function loadGeometry(e, id) {
      get(e.path).then((data) => {
        let buffers = [];
        for (let key in data)
          Array.isArray(data[key])
            ? ((data[key] = new Float32Array(data[key])),
              buffers.push(data[key].buffer))
            : data[key].length > 0 && buffers.push(data[key].buffer);
        computeBounding(data),
          e.custom && self[e.custom](data),
          resolve(data, id, buffers);
      });
    }
    function loadSkinnedGeometry(e, id) {
      get(e.path).then((data) => {
        let buffers = [];
        for (let key in data)
          "bones" != key &&
            (Array.isArray(data[key])
              ? ((data[key] = new Float32Array(data[key])),
                buffers.push(data[key].buffer))
              : data[key].length > 0 && buffers.push(data[key].buffer));
        computeBounding(data),
          e.custom && self[e.custom](data),
          resolve(data, id, buffers);
      });
    }
    function geom_useFn(e) {
      Global.FNS || (Global.FNS = []), Global.FNS.push(e.name);
    }
    Inherit(this, Component);
    const _this = this;
    var _cache = {},
      _cacheWait = {},
      _receive = {};
    (this.caching = !0),
      (async function () {
        await Hydra.ready(),
          Thread.upload(
            loadGeometry,
            loadSkinnedGeometry,
            geom_useFn,
            computeBounding
          );
      })(),
      (this.loadGeometry = function (path, custom) {
        if (_cache[path]) return Promise.resolve(_cache[path]);
        if (
          (path.includes("assets/geometry/") ||
            (path = "assets/geometry/" + path),
          path.includes(".") || (path += ".json"),
          (path = Thread.absolutePath(Assets.getPath(path))),
          _this.caching)
        ) {
          if (_cacheWait[path]) return _cacheWait[path];
          _cacheWait[path] = Promise.create();
        }
        return (
          Thread.shared()
            .loadGeometry({ path: path, custom: custom })
            .then((data) => {
              let geometry;
              if (custom && _receive[custom]) geometry = _receive[custom](data);
              else {
                let geom = new Geometry();
                geom.addAttribute(
                  "position",
                  new GeometryAttribute(data.position, 3)
                ),
                  geom.addAttribute(
                    "normal",
                    new GeometryAttribute(
                      data.normal || data.position.length,
                      3
                    )
                  ),
                  geom.addAttribute(
                    "uv",
                    new GeometryAttribute(
                      data.uv || (data.position.length / 3) * 2,
                      2
                    )
                  ),
                  data.uv2 &&
                    geom.addAttribute(
                      "uv2",
                      new GeometryAttribute(data.uv2, 2)
                    ),
                  (geom.boundingBox = new Box3(
                    new Vector3().set(
                      data.boundingBox.min.x,
                      data.boundingBox.min.y,
                      data.boundingBox.min.z
                    ),
                    new Vector3().set(
                      data.boundingBox.max.x,
                      data.boundingBox.max.y,
                      data.boundingBox.max.z
                    )
                  )),
                  (geom.boundingSphere = new Sphere(
                    new Vector3().set(
                      data.boundingSphere.center.x,
                      data.boundingSphere.center.y,
                      data.boundingSphere.center.z
                    ),
                    data.boundingSphere.radius
                  )),
                  (geometry = geom);
              }
              _this.caching && (_cache[path] = geometry),
                _cacheWait[path].resolve(geometry);
            }),
          _cacheWait[path]
        );
      }),
      (this.loadSkinnedGeometry = function (path, custom) {
        if (_cache[path]) return Promise.resolve(_cache[path]);
        if (
          (path.includes("assets/geometry/") ||
            (path = "assets/geometry/" + path),
          path.includes(".") || (path += ".json"),
          (path = Thread.absolutePath(Assets.getPath(path))),
          _this.caching)
        ) {
          if (_cacheWait[path]) return _cacheWait[path];
          _cacheWait[path] = Promise.create();
        }
        return (
          Thread.shared()
            .loadSkinnedGeometry({ path: path, custom: custom })
            .then((data) => {
              let geometry;
              if (custom && _receive[custom]) geometry = _receive[custom](data);
              else {
                let geom = new Geometry();
                geom.addAttribute(
                  "position",
                  new GeometryAttribute(data.position, 3)
                ),
                  geom.addAttribute(
                    "normal",
                    new GeometryAttribute(
                      data.normal || data.position.length,
                      3
                    )
                  ),
                  geom.addAttribute(
                    "uv",
                    new GeometryAttribute(
                      data.uv || (data.position.length / 3) * 2,
                      2
                    )
                  ),
                  geom.addAttribute(
                    "skinIndex",
                    new GeometryAttribute(data.skinIndex, 4)
                  ),
                  geom.addAttribute(
                    "skinWeight",
                    new GeometryAttribute(data.skinWeight, 4)
                  ),
                  (geom.bones = (data.rig ? data.rig.bones : data.bones).slice(
                    0
                  )),
                  (geom.boundingBox = new Box3(
                    new Vector3().set(
                      data.boundingBox.min.x,
                      data.boundingBox.min.y,
                      data.boundingBox.min.z
                    ),
                    new Vector3().set(
                      data.boundingBox.max.x,
                      data.boundingBox.max.y,
                      data.boundingBox.max.z
                    )
                  )),
                  (geom.boundingSphere = new Sphere(
                    new Vector3().set(
                      data.boundingSphere.center.x,
                      data.boundingSphere.center.y,
                      data.boundingSphere.center.z
                    ),
                    data.boundingSphere.radius
                  )),
                  (geometry = geom);
              }
              _this.caching && (_cache[path] = geometry),
                _cacheWait[path].resolve(geometry);
            }),
          _cacheWait[path]
        );
      }),
      (this.customFunction = function (fn, receive) {
        let name = Thread.upload(fn);
        (name = name[0]),
          t.geom_useFn({ name: name }),
          (_receive[name] = receive);
      });
  }, "static"),
  Class(function Object3D() {
    Inherit(this, Component);
    var _this = this,
      _visible = !0;
    (this.__element = !0),
      (this.group = new Group()),
      (this.group.classRef = this),
      (this.add = function (child) {
        this.group.add(child.group || child);
      }),
      (this.remove = function (child) {
        this.group.remove(child.group || child);
      }),
      (this.onDestroy = function () {
        (this.group.deleted = !0),
          (this.group.classRef = null),
          this.group &&
            this.group.parent &&
            this.group.parent.remove(this.group);
      }),
      this.set("visible", (v) => (_this.group.visible = _visible = v)),
      this.get("visible", (_) => _visible);
  }),
  Class(function Utils3D() {
    const _this = this;
    var _debugGeometry,
      _emptyTexture,
      _q,
      _textures = {};
    (window.Vec2 = window.Vector2),
      (window.Vec3 = window.Vector3),
      (async function () {
        await Hydra.ready();
        let threads = Thread.shared(!0);
        for (let i = 0; i < threads.array.length; i++)
          _this.loadEngineOnThread(threads.array[i]);
      })(),
      (this.decompose = function (local, world) {
        local.matrixWorld.decompose(
          world.position,
          world.quaternion,
          world.scale
        );
      }),
      (this.createDebug = function (size = 1, color) {
        return (
          _debugGeometry || (_debugGeometry = new IcosahedronGeometry(size, 1)),
          new Mesh(_debugGeometry, _this.getTestShader(color))
        );
      }),
      (this.getTestShader = function (color) {
        return color
          ? new Shader("ColorMaterial", {
              color: {
                value: color instanceof Color ? color : new Color(color),
              },
              alpha: { value: 1 },
            })
          : new Shader("TestMaterial");
      }),
      (this.createMultiRT = function (width, height, type, format) {
        let rt = new MultiRenderTarget(width, height, {
          minFilter: Texture.LINEAR,
          magFilter: Texture.LINEAR,
          format: format || Texture.RGBFormat,
          type: type,
        });
        return (rt.texture.generateMipmaps = !1), rt;
      }),
      (this.createRT = function (width, height, type, format) {
        let rt = new RenderTarget(width, height, {
          minFilter: Texture.LINEAR,
          magFilter: Texture.LINEAR,
          format: format || Texture.RGBFormat,
          type: type,
        });
        return (rt.texture.generateMipmaps = !1), rt;
      }),
      (this.getFloatType = function () {
        return "android" == Device.system.os
          ? Texture.FLOAT
          : Texture.HALF_FLOAT;
      }),
      (this.getTexture = function (path, params = {}) {
        if (path.includes("://")) {
          let guard = path.split("://");
          (guard[1] = guard[1].replace(/\/\//g, "/")),
            (path = guard.join("://"));
        } else path = path.replace(/\/\//g, "/");
        if (!_textures[path]) {
          let texture = new Texture();
          (texture.loaded = !1),
            (texture.promise = Promise.create()),
            (texture._destroy = texture.destroy),
            (texture.destroy = function () {
              delete _textures[path], this._destroy();
            }),
            (_textures[path] = texture),
            (texture.format = path.match(/jpe?g/)
              ? Texture.RGBFormat
              : Texture.RGBAFormat),
            (texture.src = path),
            !1 === params.premultiplyAlpha && (texture.premultiplyAlpha = !1),
            path.includes("-compressedKtx") &&
              ((texture.compressed = !0), (texture.minFilter = Texture.LINEAR)),
            _this.onTextureCreated && _this.onTextureCreated(texture),
            ImageDecoder.decode(path, params).then((imgBmp) => {
              (texture.image = imgBmp),
                (texture.loaded = !0),
                (texture.needsReupload = !0),
                Math.isPowerOf2(imgBmp.width, imgBmp.height) ||
                  ((texture.minFilter = Texture.LINEAR),
                  (texture.generateMipmaps = !1)),
                (texture.onUpdate = function () {
                  !params.preserveData && imgBmp.close && imgBmp.close(),
                    (texture.onUpdate = null);
                }),
                texture.promise.resolve(),
                texture.onload && (texture.onload(), (texture.onload = null));
            });
        }
        return _textures[path];
      }),
      (this.getLookupTexture = function (path) {
        let texture = this.getTexture(path);
        return (
          (texture.minFilter = texture.magFilter = Texture.NEAREST), texture
        );
      }),
      (this.clearTextureCache = function () {
        for (let key in _textures) _textures[key].destroy();
        _textures = {};
      }),
      (this.loadCurve = function (obj) {
        "string" == typeof obj &&
          ((obj = Assets.JSON[obj]).curves = obj.curves[0]);
        let data = obj.curves,
          points = [];
        for (let j = 0; j < data.length; j += 3)
          points.push(new Vector3(data[j + 0], data[j + 1], data[j + 2]));
        if (!window.CatmullRomCurve) throw "loadCurve requires curve3d module";
        return new CatmullRomCurve(points);
      }),
      (this.getEmptyTexture = function () {
        return _emptyTexture || (_emptyTexture = new Texture()), _emptyTexture;
      }),
      (this.getRepeatTexture = function (src, scale) {
        let texture = _this.getTexture(src, scale);
        return (texture.wrapS = texture.wrapT = Texture.REPEAT), texture;
      }),
      (this.findTexturesByPath = function (path) {
        let array = [];
        for (let key in _textures)
          key.includes(path) && array.push(_textures[key]);
        return array;
      }),
      (this.getHeightFromCamera = function (camera, dist) {
        (camera = camera.camera || camera),
          dist || (dist = camera.position.length());
        let fov = camera.fov;
        return 2 * dist * Math.tan(0.5 * Math.radians(fov));
      }),
      (this.getPositionFromCameraSize = function (camera, size) {
        camera = camera.camera || camera;
        let fov = Math.radians(camera.fov);
        return Math.abs(size / Math.sin(fov / 2));
      }),
      (this.loadEngineOnThread = function (thread) {
        [
          "Base3D",
          "CameraBase3D",
          "Mesh",
          "OrthographicCamera",
          "PerspectiveCamera",
          "Geometry",
          "GeometryAttribute",
          "Points",
          "Scene",
          "BoxGeometry",
          "CylinderGeometry",
          "PlaneGeometry",
          "PolyhedronGeometry",
          "IcosahedronGeometry",
          "SphereGeometry",
          "Box2",
          "Box3",
          "Face3",
          "Color",
          "Cylindrical",
          "Euler",
          "Frustum",
          "Line3",
          "Matrix3",
          "Matrix4",
          "Plane",
          "Quaternion",
          "Ray",
          "Sphere",
          "Spherical",
          "Triangle",
          "Vector2",
          "Vector3",
          "Vector4",
          "RayManager",
        ].forEach((name) => {
          thread.importES6Class(name);
        }),
          thread.importCode(
            `Class(${zUtils3D.constructor.toString()}, 'static')`
          );
      }),
      (this.billboard = function (mesh, camera = World.CAMERA) {
        _q || (_q = new Quaternion()),
          mesh._parent
            ? (mesh._parent.getWorldQuaternion(_q).inverse(),
              _q.multiply(camera.quaternion),
              mesh.quaternion.copy(_q))
            : mesh.quaternion.copy(World.CAMERA.quaternion);
      }),
      (this.getQuad = function () {
        let geom = new Geometry(),
          position = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
          uv = new Float32Array([0, 0, 2, 0, 0, 2]);
        return (
          geom.addAttribute("position", new GeometryAttribute(position, 3)),
          geom.addAttribute("uv", new GeometryAttribute(uv, 2)),
          geom
        );
      });
  }, "static"),
  window.WebGLRenderingContext &&
    (function () {
      "use strict";
      function r(r, t) {
        var i;
        (e[r] = !0),
          void 0 !== t &&
            ((i = t),
            window.console && window.console.error && window.console.error(i));
      }
      var e = {},
        t = function e(r) {
          var t = r.gl;
          (this.ext = r),
            (this.isAlive = !0),
            (this.hasBeenBound = !1),
            (this.elementArrayBuffer = null),
            (this.attribs = new Array(r.maxVertexAttribs));
          for (var i = 0; i < this.attribs.length; i++) {
            var a = new e.VertexAttrib(t);
            this.attribs[i] = a;
          }
          this.maxAttrib = 0;
        };
      (t.VertexAttrib = function (e) {
        (this.enabled = !1),
          (this.buffer = null),
          (this.size = 4),
          (this.type = e.FLOAT),
          (this.normalized = !1),
          (this.stride = 16),
          (this.offset = 0),
          (this.cached = ""),
          this.recache();
      }).prototype.recache = function () {
        this.cached = [
          this.size,
          this.type,
          this.normalized,
          this.stride,
          this.offset,
        ].join(":");
      };
      var i = function (r) {
        var t,
          i,
          a = this;
        (this.gl = r),
          (i = (t = r).getError),
          (t.getError = function () {
            do {
              (r = i.apply(t)) != t.NO_ERROR && (e[r] = !0);
            } while (r != t.NO_ERROR);
            for (var r in e) if (e[r]) return delete e[r], parseInt(r);
            return t.NO_ERROR;
          });
        var n = (this.original = {
          getParameter: r.getParameter,
          enableVertexAttribArray: r.enableVertexAttribArray,
          disableVertexAttribArray: r.disableVertexAttribArray,
          bindBuffer: r.bindBuffer,
          getVertexAttrib: r.getVertexAttrib,
          vertexAttribPointer: r.vertexAttribPointer,
        });
        (r.getParameter = function (e) {
          return e == a.VERTEX_ARRAY_BINDING_OES
            ? a.currentVertexArrayObject == a.defaultVertexArrayObject
              ? null
              : a.currentVertexArrayObject
            : n.getParameter.apply(this, arguments);
        }),
          (r.enableVertexAttribArray = function (e) {
            var r = a.currentVertexArrayObject;
            return (
              (r.maxAttrib = Math.max(r.maxAttrib, e)),
              (r.attribs[e].enabled = !0),
              n.enableVertexAttribArray.apply(this, arguments)
            );
          }),
          (r.disableVertexAttribArray = function (e) {
            var r = a.currentVertexArrayObject;
            return (
              (r.maxAttrib = Math.max(r.maxAttrib, e)),
              (r.attribs[e].enabled = !1),
              n.disableVertexAttribArray.apply(this, arguments)
            );
          }),
          (r.bindBuffer = function (e, t) {
            switch (e) {
              case r.ARRAY_BUFFER:
                a.currentArrayBuffer = t;
                break;
              case r.ELEMENT_ARRAY_BUFFER:
                a.currentVertexArrayObject.elementArrayBuffer = t;
            }
            return n.bindBuffer.apply(this, arguments);
          }),
          (r.getVertexAttrib = function (e, t) {
            var i = a.currentVertexArrayObject.attribs[e];
            switch (t) {
              case r.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
                return i.buffer;
              case r.VERTEX_ATTRIB_ARRAY_ENABLED:
                return i.enabled;
              case r.VERTEX_ATTRIB_ARRAY_SIZE:
                return i.size;
              case r.VERTEX_ATTRIB_ARRAY_STRIDE:
                return i.stride;
              case r.VERTEX_ATTRIB_ARRAY_TYPE:
                return i.type;
              case r.VERTEX_ATTRIB_ARRAY_NORMALIZED:
                return i.normalized;
              default:
                return n.getVertexAttrib.apply(this, arguments);
            }
          }),
          (r.vertexAttribPointer = function (e, r, t, i, s, A) {
            var o = a.currentVertexArrayObject;
            o.maxAttrib = Math.max(o.maxAttrib, e);
            var c = o.attribs[e];
            return (
              (c.buffer = a.currentArrayBuffer),
              (c.size = r),
              (c.type = t),
              (c.normalized = i),
              (c.stride = s),
              (c.offset = A),
              c.recache(),
              n.vertexAttribPointer.apply(this, arguments)
            );
          }),
          r.instrumentExtension &&
            r.instrumentExtension(this, "OES_vertex_array_object"),
          r.canvas.addEventListener(
            "webglcontextrestored",
            function () {
              var e;
              (e = "OESVertexArrayObject emulation library context restored"),
                window.console && window.console.log && window.console.log(e),
                a.reset_();
            },
            !0
          ),
          this.reset_();
      };
      (i.prototype.VERTEX_ARRAY_BINDING_OES = 34229),
        (i.prototype.reset_ = function () {
          if (void 0 !== this.vertexArrayObjects)
            for (var e = 0; e < this.vertexArrayObjects.length; ++e)
              this.vertexArrayObjects.isAlive = !1;
          var r = this.gl;
          (this.maxVertexAttribs = r.getParameter(r.MAX_VERTEX_ATTRIBS)),
            (this.defaultVertexArrayObject = new t(this)),
            (this.currentVertexArrayObject = null),
            (this.currentArrayBuffer = null),
            (this.vertexArrayObjects = [this.defaultVertexArrayObject]),
            this.bindVertexArrayOES(null);
        }),
        (i.prototype.createVertexArrayOES = function () {
          var e = new t(this);
          return this.vertexArrayObjects.push(e), e;
        }),
        (i.prototype.deleteVertexArrayOES = function (e) {
          (e.isAlive = !1),
            this.vertexArrayObjects.splice(
              this.vertexArrayObjects.indexOf(e),
              1
            ),
            this.currentVertexArrayObject == e && this.bindVertexArrayOES(null);
        }),
        (i.prototype.isVertexArrayOES = function (e) {
          return !!(e && e instanceof t && e.hasBeenBound && e.ext == this);
        }),
        (i.prototype.bindVertexArrayOES = function (e) {
          var t = this.gl;
          if (!e || e.isAlive) {
            var i = this.original,
              a = this.currentVertexArrayObject;
            (this.currentVertexArrayObject =
              e || this.defaultVertexArrayObject),
              (this.currentVertexArrayObject.hasBeenBound = !0);
            var n = this.currentVertexArrayObject;
            if (a != n) {
              (a && n.elementArrayBuffer == a.elementArrayBuffer) ||
                i.bindBuffer.call(
                  t,
                  t.ELEMENT_ARRAY_BUFFER,
                  n.elementArrayBuffer
                );
              for (
                var s = this.currentArrayBuffer,
                  A = Math.max(a ? a.maxAttrib : 0, n.maxAttrib),
                  o = 0;
                o <= A;
                o++
              ) {
                var c = n.attribs[o],
                  b = a ? a.attribs[o] : null;
                if (
                  ((a && c.enabled == b.enabled) ||
                    (c.enabled
                      ? i.enableVertexAttribArray.call(t, o)
                      : i.disableVertexAttribArray.call(t, o)),
                  c.enabled)
                ) {
                  var u = !1;
                  (a && c.buffer == b.buffer) ||
                    (s != c.buffer &&
                      (i.bindBuffer.call(t, t.ARRAY_BUFFER, c.buffer),
                      (s = c.buffer)),
                    (u = !0)),
                    (u || c.cached != b.cached) &&
                      i.vertexAttribPointer.call(
                        t,
                        o,
                        c.size,
                        c.type,
                        c.normalized,
                        c.stride,
                        c.offset
                      );
                }
              }
              this.currentArrayBuffer != s &&
                i.bindBuffer.call(t, t.ARRAY_BUFFER, this.currentArrayBuffer);
            }
          } else
            r(
              t.INVALID_OPERATION,
              "bindVertexArrayOES: attempt to bind deleted arrayObject"
            );
        }),
        (function () {
          var e = WebGLRenderingContext.prototype.getSupportedExtensions;
          WebGLRenderingContext.prototype.getSupportedExtensions = function () {
            var r = e.call(this) || [];
            return (
              r.indexOf("OES_vertex_array_object") < 0 &&
                r.push("OES_vertex_array_object"),
              r
            );
          };
          var r = WebGLRenderingContext.prototype.getExtension;
          WebGLRenderingContext.prototype.getExtension = function (e) {
            return (
              r.call(this, e) ||
              ("OES_vertex_array_object" !== e
                ? null
                : (this.__OESVertexArrayObject ||
                    (console.log("Setup OES_vertex_array_object polyfill"),
                    (this.__OESVertexArrayObject = new i(this))),
                  this.__OESVertexArrayObject))
            );
          };
        })();
    })(),
  Class(function Fluid(_simSize = 128, _dyeSize = 512, _rect = Stage) {
    function initFBOs() {
      (_fbos.density = _this.initClass(
        FluidFBO,
        DYE_WIDTH,
        DYE_HEIGHT,
        Texture.LINEAR
      )),
        (_fbos.velocity = _this.initClass(
          FluidFBO,
          SIM_WIDTH,
          SIM_HEIGHT,
          Texture.LINEAR
        )),
        (_fbos.divergence = _this.initClass(
          FluidFBO,
          SIM_WIDTH,
          SIM_HEIGHT,
          Texture.NEAREST
        )),
        (_fbos.curl = _this.initClass(
          FluidFBO,
          SIM_WIDTH,
          SIM_HEIGHT,
          Texture.NEAREST
        )),
        (_fbos.pressure = _this.initClass(
          FluidFBO,
          SIM_WIDTH,
          SIM_HEIGHT,
          Texture.NEAREST
        ));
    }
    function initScenes() {
      (_scenes.curl = _this.initClass(FluidScene, "fluidBase", "curlShader", {
        texelSize: { value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT) },
        uVelocity: { value: null },
        depthWrite: !1,
      })),
        (_scenes.vorticity = _this.initClass(
          FluidScene,
          "fluidBase",
          "vorticityShader",
          {
            texelSize: { value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT) },
            uVelocity: { value: null },
            uCurl: { value: null },
            curl: { value: config.CURL },
            dt: { value: 0.016 },
          }
        )),
        (_scenes.divergence = _this.initClass(
          FluidScene,
          "fluidBase",
          "divergenceShader",
          {
            texelSize: { value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT) },
            uVelocity: { value: null },
          }
        )),
        (_scenes.clear = _this.initClass(
          FluidScene,
          "fluidBase",
          "clearShader",
          {
            uTexture: { value: null },
            value: { value: config.PRESSURE_DISSIPATION },
          }
        )),
        (_scenes.pressure = _this.initClass(
          FluidScene,
          "fluidBase",
          "pressureShader",
          {
            texelSize: { value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT) },
            uPressure: { value: null },
            uDivergence: { value: null },
          }
        )),
        (_scenes.gradientSubtract = _this.initClass(
          FluidScene,
          "fluidBase",
          "gradientSubtractShader",
          {
            texelSize: { value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT) },
            uPressure: { value: null },
            uVelocity: { value: null },
          }
        )),
        (_scenes.advection = _this.initClass(
          FluidScene,
          "fluidBase",
          "advectionShader",
          {
            texelSize: { value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT) },
            uVelocity: { value: null },
            uSource: { value: null },
            dt: { value: 0.016 },
            dissipation: { value: config.VELOCITY_DISSIPATION },
          }
        )),
        (_scenes.display = _this.initClass(
          FluidScene,
          "fluidBase",
          "displayShader",
          {
            texelSize: {
              value: new Vector2(1 / _rect.width, 1 / _rect.height),
            },
            uTexture: { value: null },
          }
        )),
        (_scenes.splat = _this.initClass(
          FluidScene,
          "fluidBase",
          "splatShader",
          {
            uTarget: { value: null },
            aspectRatio: { value: _rect.width / _rect.height },
            point: { value: new Vector2() },
            color: { value: new Vector3() },
            radius: { value: config.SPLAT_RADIUS / 100 },
            canRender: { value: 0 },
          }
        ));
    }
    function drawMouse() {
      _this.drawInput(
        Mouse.x,
        Mouse.y,
        10 * Mouse.delta.x,
        10 * Mouse.delta.y,
        new Color("#777777")
      );
    }
    function loop() {
      config.DEBUG_MOUSE && drawMouse(),
        (_scenes.curl.uniforms.uVelocity.value = _fbos.velocity.read),
        _scenes.curl.render(_fbos.curl.fbo),
        (_scenes.vorticity.uniforms.uVelocity.value = _fbos.velocity.read),
        (_scenes.vorticity.uniforms.uCurl.value = _fbos.curl.fbo),
        (_scenes.vorticity.uniforms.curl.value = config.CURL),
        _scenes.vorticity.render(_fbos.velocity.write),
        _fbos.velocity.swap(),
        (_scenes.divergence.uniforms.uVelocity.value = _fbos.velocity.read),
        _scenes.divergence.render(_fbos.divergence.fbo),
        (_scenes.clear.uniforms.uTexture.value = _fbos.pressure.read),
        (_scenes.clear.uniforms.value.value = config.PRESSURE_DISSIPATION),
        _scenes.clear.render(_fbos.pressure.write),
        _fbos.pressure.swap(),
        (_scenes.pressure.uniforms.uDivergence.value = _fbos.divergence.fbo);
      for (let i = 0; i < config.PRESSURE_ITERATIONS; i++)
        (_scenes.pressure.uniforms.uPressure.value = _fbos.pressure.read),
          _scenes.pressure.render(_fbos.pressure.write),
          _fbos.pressure.swap();
      (_scenes.gradientSubtract.uniforms.uPressure.value = _fbos.pressure.read),
        (_scenes.gradientSubtract.uniforms.uVelocity.value =
          _fbos.velocity.read),
        _scenes.gradientSubtract.render(_fbos.velocity.write),
        _fbos.velocity.swap(),
        _scenes.advection.uniforms.texelSize.value.set(
          1 / SIM_WIDTH,
          1 / SIM_HEIGHT
        ),
        (_scenes.advection.uniforms.uVelocity.value = _fbos.velocity.read),
        (_scenes.advection.uniforms.uSource.value = _fbos.velocity.read),
        (_scenes.advection.uniforms.dissipation.value =
          config.VELOCITY_DISSIPATION),
        _scenes.advection.render(_fbos.velocity.write),
        _fbos.velocity.swap(),
        _scenes.advection.uniforms.texelSize.value.set(
          1 / DYE_WIDTH,
          1 / DYE_HEIGHT
        ),
        (_scenes.advection.uniforms.uVelocity.value = _fbos.velocity.read),
        (_scenes.advection.uniforms.uSource.value = _fbos.density.read),
        (_scenes.advection.uniforms.dissipation.value =
          config.DENSITY_DISSIPATION),
        _scenes.advection.render(_fbos.density.write),
        _fbos.density.swap(),
        (_scenes.display.uniforms.uTexture.value = _fbos.density.read),
        _scenes.display.uniforms.texelSize.value.set(
          1 / _rect.width,
          1 / _rect.height
        ),
        _scenes.display.render(_this.rt);
    }
    if ((Inherit(this, Component), !Tests.useFluid())) return;
    const _this = this;
    var _fbos = {},
      _scenes = {};
    const DYE_WIDTH = _dyeSize,
      DYE_HEIGHT = _dyeSize,
      SIM_WIDTH = _simSize,
      SIM_HEIGHT = _simSize,
      config = {
        DENSITY_DISSIPATION: 0.97,
        VELOCITY_DISSIPATION: 0.98,
        PRESSURE_DISSIPATION: 0.8,
        PRESSURE_ITERATIONS: 20,
        CURL: 30,
        DEBUG_MOUSE: !0,
        SPLAT_RADIUS: 0.25,
      };
    (this.rt = Utils3D.createRT(_rect.width, _rect.height)),
      (this.fbos = _fbos),
      (_this.rt.disableDepth = !0),
      initFBOs(),
      initScenes(),
      _this.startRender(loop),
      (this.updateConfig = function (key, value) {
        config[key] = value;
      }),
      (this.drawInput = function (
        x,
        y,
        dx,
        dy,
        color,
        radius = config.SPLAT_RADIUS
      ) {
        (_scenes.splat.uniforms.uTarget.value = _fbos.velocity.read),
          (_scenes.splat.uniforms.radius.value = radius / 1e4),
          (_scenes.splat.uniforms.aspectRatio.value =
            _rect.width / _rect.height),
          _scenes.splat.uniforms.point.value.set(
            x / _rect.width,
            1 - y / _rect.height
          ),
          _scenes.splat.uniforms.color.value.set(dx, -dy, 1),
          _scenes.splat.render(_fbos.velocity.write),
          _fbos.velocity.swap(),
          (_scenes.splat.uniforms.uTarget.value = _fbos.density.read),
          _scenes.splat.uniforms.color.value.set(color.r, color.g, color.b),
          _scenes.splat.render(_fbos.density.write),
          _fbos.density.swap(),
          (_scenes.splat.uniforms.canRender.value = 1);
      });
  }),
  Class(function FluidFBO(_width, _height, _filter) {
    Inherit(this, Component);
    const _this = this;
    var _fbo1 = new RenderTarget(_width, _height, {
        minFilter: _filter,
        magFilter: _filter,
        format: Texture.RGBAFormat,
        type: Texture.HALF_FLOAT,
      }),
      _fbo2 = new RenderTarget(_width, _height, {
        minFilter: _filter,
        magFilter: _filter,
        format: Texture.RGBAFormat,
        type: Texture.HALF_FLOAT,
      });
    (this.fbo = _fbo1),
      (this.uniform = { value: _fbo1 }),
      (_fbo1.disableDepth = !0),
      (_fbo2.disableDepth = !0),
      (_fbo1.generateMipmaps = !1),
      (_fbo2.generateMipmaps = !1),
      (this.swap = function () {
        let temp = _fbo1;
        (_fbo1 = _fbo2), (_fbo2 = temp), (_this.uniform.value = _fbo1);
      }),
      this.get("read", (_) => _fbo1),
      this.get("write", (_) => _fbo2);
  }),
  Class(function FluidLayer(_input, _group) {
    function initConfig() {
      (_config = InputUIL.create(_input.prefix + "fluid", _group)).setLabel(
        "Fluid Config"
      ),
        _config.add("dyeSize", 512),
        _config.add("simSize", 128),
        _config.add("velocity", 0.98),
        _config.add("density", 0.97),
        _config.add("pressure", 0.8),
        _config.add("iterations", 20),
        _config.add("curl", 30),
        _config.add("defaultRadius", 25),
        _config.addToggle("debugMouse", !1);
    }
    function initFluid() {
      (_fluid = _this.initClass(
        Fluid,
        _config.getNumber("simSize"),
        _config.getNumber("dyeSize"),
        Stage
      )),
        (_this.rt = _fluid.rt),
        (_this.fbos = _fluid.fbos),
        (_config.onUpdate = (key) => {
          switch (key) {
            case "velocity":
              _fluid.updateConfig(
                "VELOCITY_DISSIPATION",
                _config.getNumber(key)
              );
              break;
            case "density":
              _fluid.updateConfig(
                "DENSITY_DISSIPATION",
                _config.getNumber(key)
              );
              break;
            case "pressure":
              _fluid.updateConfig(
                "PRESSURE_DISSIPATION",
                _config.getNumber(key)
              );
              break;
            case "iterations":
              _fluid.updateConfig(
                "PRESSURE_ITERATIONS",
                _config.getNumber(key)
              );
              break;
            case "curl":
              _fluid.updateConfig("CURL", _config.getNumber(key));
              break;
            case "defaultRadius":
              _fluid.updateConfig("SPLAT_RADIUS", _config.getNumber(key));
              break;
            case "debugMouse":
              _fluid.updateConfig("DEBUG_MOUSE", _config.get(key));
          }
        }),
        [
          "velocity",
          "density",
          "pressure",
          "iterations",
          "curl",
          "defaultRadius",
          "debugMouse",
        ].forEach(_config.onUpdate);
    }
    function initMesh() {
      let shader = _this.initClass(Shader, "ScreenQuad", {
          tMap: { value: _fluid.rt },
        }),
        mesh = new Mesh(World.QUAD, shader);
      _this.add(mesh), (_this.mesh = mesh);
    }
    if ((Inherit(this, Object3D), Tests.useFluid())) {
      var _fluid,
        _config,
        _this = this;
      initConfig(),
        initFluid(),
        initMesh(),
        (this.drawInput = _fluid.drawInput);
    }
  }),
  Class(function FluidScene(_vs, _fs, _uniforms) {
    Inherit(this, Component);
    const _this = this;
    var _scene = new Scene();
    !(function () {
      _uniforms.depthWrite = !1;
      let shader = _this.initClass(Shader, _vs, _fs, _uniforms),
        mesh = new Mesh(World.QUAD, shader);
      (shader.depthWrite = !1),
        (mesh.noMatrices = !0),
        _scene.add(mesh),
        (_this.uniforms = shader.uniforms);
    })(),
      (this.render = function (rt) {
        (World.RENDERER.autoClear = !1),
          World.RENDERER.renderSingle(_scene.children[0], World.CAMERA, rt),
          (World.RENDERER.autoClear = !0);
      });
  }),
  Class(function Fullscreen() {
    function addHandlers() {
      [
        "onfullscreenchange",
        "onwebkitfullscreenchange",
        "onmozfullscreenchange",
        "onmsfullscreenchange",
        "onfullscreenerror",
        "onwebkitfullscreenerror",
        "onmozfullscreenerror",
        "onmsfullscreenerror",
      ].forEach((evt) => {
        void 0 !== document[evt] && (document[evt] = update);
      });
    }
    function update() {
      const isOpen = !!(
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        document.msFullscreenElement
      );
      isOpen !== _this.isOpen &&
        ((_this.isOpen = isOpen),
        _this.events.fire(Events.FULLSCREEN, { fullscreen: _this.isOpen }));
    }
    Inherit(this, Events);
    const _this = this;
    (this.isOpen = !1),
      addHandlers(),
      (this.open = function (element) {
        (element = element || document.body),
          [
            "requestFullscreen",
            "webkitRequestFullscreen",
            "mozRequestFullScreen",
            "msRequestFullscreen",
          ].every((method) => {
            if (void 0 === element[method]) return !0;
            element[method]();
          });
      }),
      (this.close = function () {
        [
          "exitFullscreen",
          "webkitExitFullscreen",
          "mozCancelFullScreen",
          "msExitFullscreen",
        ].every((method) => {
          if (void 0 === document[method]) return !0;
          document[method]();
        });
      });
  }, "static"),
  Class(function FXAA() {
    Inherit(this, NukePass);
    (this.uniforms = {}), this.init("FXAA", "FXAA");
  }),
  Class(
    function GLText({
      font: font,
      text: text,
      width: width = 1 / 0,
      align: align = "left",
      size: size = 1,
      letterSpacing: letterSpacing = 0,
      lineHeight: lineHeight = 1.4,
      wordSpacing: wordSpacing = 0,
      wordBreak: wordBreak = !1,
      langBreak: langBreak = !1,
      color: color = new Color("#000000"),
      alpha: alpha = 1,
      shader: shader = "DefaultText",
    }) {
      function init() {
        overrideParams(),
          (_this.charLength = text.length),
          (_this.text = new GLTextGeometry({
            font: font,
            text: text,
            width: width,
            align: align,
            wordSpacing: wordSpacing,
            letterSpacing: letterSpacing,
            size: size,
            lineHeight: lineHeight,
            wordBreak: wordBreak,
            langBreak: langBreak,
            config: config,
          })),
          (_this.string = text),
          resetOverride(),
          _this.text.loaded.then(
            ({
              buffers: buffers,
              image: image,
              height: height,
              numLines: numLines,
            }) => {
              (_this.texture = GLText.getTexture(image)),
                (_this.shader = new Shader(shader, {
                  tMap: { value: _this.texture },
                  uColor: { value: color },
                  uAlpha: { value: alpha },
                  transparent: !0,
                })),
                createGeometry(buffers),
                (_this.mesh = new Mesh(_this.geometry, _this.shader)),
                (_this.height = height);
            }
          );
      }
      function overrideParams() {
        if (GLText.overrideParams) {
          _override = {
            letterSpacing: letterSpacing,
            size: size,
            wordSpacing: wordSpacing,
            lineHeight: lineHeight,
          };
          let obj = GLText.overrideParams({
            letterSpacing: letterSpacing,
            size: size,
            wordSpacing: wordSpacing,
            lineHeight: lineHeight,
          });
          (letterSpacing = obj.letterSpacing),
            (size = obj.size),
            (wordSpacing = obj.wordSpacing),
            (lineHeight = obj.lineHeight);
        }
      }
      function resetOverride() {
        _override &&
          ((letterSpacing = _override.letterSpacing),
          (size = _override.size),
          (wordSpacing = _override.wordSpacing),
          (lineHeight = _override.lineHeight));
      }
      function createGeometry(buffers) {
        (_this.geometry = new Geometry()),
          _this.geometry.addAttribute(
            "position",
            new GeometryAttribute(buffers.position, 3)
          ),
          _this.geometry.addAttribute(
            "uv",
            new GeometryAttribute(buffers.uv, 2)
          ),
          _this.geometry.addAttribute(
            "animation",
            new GeometryAttribute(buffers.animation, 3)
          ),
          _this.geometry.setIndex(new GeometryAttribute(buffers.index, 1)),
          (_this.geometry.boundingBox = buffers.boundingBox),
          (_this.geometry.letterCount = buffers.letterCount + 1),
          (_this.geometry.wordCount = buffers.wordCount + 1),
          (_this.geometry.lineCount = buffers.lineCount + 1);
      }
      function setVars(options) {
        (font = options.font || font),
          (width = options.width || width),
          (align = options.align || align),
          (wordSpacing = options.wordSpacing || wordSpacing),
          (letterSpacing = options.letterSpacing || letterSpacing),
          (size = options.size || size),
          (lineHeight = options.lineHeight || lineHeight),
          (wordBreak = options.wordBreak || wordBreak),
          (langBreak = options.langBreak || langBreak);
      }
      function match(options) {
        return (
          !options ||
          (options.font == font &&
            options.width == width &&
            options.align == align &&
            !(
              wordSpacing > 0 &&
              options.wordSpacing > 0 &&
              options.wordSpacing != wordSpacing
            ) &&
            !(
              letterSpacing > 0 &&
              options.letterSpacing > 0 &&
              options.letterSpacing != letterSpacing
            ) &&
            options.size == size &&
            options.lineHeight == lineHeight &&
            !(
              (!0 === options.wordBreak && !options.wordBreak) ||
              (0 == options.wordBreak && options.wordBreak)
            ))
        );
      }
      const _this = this;
      var _override;
      const config = GLText.FONT_CONFIG[font];
      init(),
        (this.onDestroy = function () {
          _this.mesh.destroy();
        }),
        (this.ready = this.loaded =
          function () {
            return _this.text.loaded;
          }),
        (this.centerY = function () {
          (_this.mesh.position.y = 0.5 * _this.height),
            (_this.needsCenterY = !0);
        }),
        (this.resize = function (options) {
          this.setText(text, options);
        }),
        (this.tweenColor = function (c, time = 300, ease = "easeOutCubic") {
          c && color.tween(c, time, ease);
        }),
        (this.setColor = function (c) {
          c && color.set(c);
        }),
        (this.setText = function (txt, options) {
          (text == txt && match(options)) ||
            ((text = txt) &&
              (setVars(options || {}),
              overrideParams(),
              (_this.string = text),
              (_this.charLength = text.length),
              (_this.text = new GLTextGeometry({
                font: font,
                text: text,
                width: width,
                align: align,
                wordSpacing: wordSpacing,
                letterSpacing: letterSpacing,
                size: size,
                lineHeight: lineHeight,
                wordBreak: wordBreak,
                langBreak: langBreak,
                config: config,
              })),
              resetOverride(),
              _this.text.loaded.then(
                ({
                  buffers: buffers,
                  image: image,
                  height: height,
                  numLines: numLines,
                }) => {
                  _this.geometry.destroy(_this.mesh),
                    createGeometry(buffers),
                    (_this.mesh.geometry = _this.geometry),
                    (_this.height = height),
                    _this.needsCenterY && _this.centerY();
                }
              )));
        }),
        (this.getData = function () {
          return {
            font: font,
            text: text,
            width: width,
            align: align,
            wordSpacing: wordSpacing,
            letterSpacing: letterSpacing,
            size: size,
            lineHeight: lineHeight,
            wordBreak: wordBreak,
            langBreak: langBreak,
            color: color,
          };
        });
    },
    (_) => {
      GLText.FONT_CONFIG = {};
      var _map = new Map();
      GLText.getTexture = function (image) {
        if (!_map.get(image)) {
          let texture = new Texture(image);
          (texture.generateMipmaps = !1),
            (texture.minFilter = Texture.LINEAR),
            _map.set(image, texture);
        }
        return _map.get(image);
      };
    }
  ),
  Class(
    function GLTextGeometry({
      font: font,
      text: text,
      width: width = 1 / 0,
      align: align = "left",
      size: size = 1,
      letterSpacing: letterSpacing = 0,
      lineHeight: lineHeight = 1.4,
      wordSpacing: wordSpacing = 0,
      wordBreak: wordBreak = !1,
      langBreak: langBreak = !1,
      config: config = {},
    }) {
      async function loadFont() {
        [json, image, glyphs] = await GLTextGeometry.loadFont(font);
      }
      async function createGeometry() {
        let buffers = await GLTextThread.generate({
          font: font,
          text: text,
          width: width,
          align: align,
          size: size,
          letterSpacing: letterSpacing,
          lineHeight: lineHeight,
          wordSpacing: wordSpacing,
          wordBreak: wordBreak,
          langBreak: langBreak,
          json: json,
          glyphs: glyphs,
          config: config,
        });
        (_this.buffers = buffers),
          (_this.image = image),
          (_this.numLines = buffers.lineLength),
          (_this.height = _this.numLines * size * lineHeight),
          _this.onLayout &&
            _this.onLayout(buffers, image, _this.height, _this.numLines),
          _this.loaded.resolve({
            buffers: buffers,
            image: image,
            height: _this.height,
            numLines: _this.numLines,
          });
      }
      let json,
        image,
        glyphs,
        _this = this;
      (_this.loaded = Promise.create()),
        (async function init() {
          await loadFont(), createGeometry();
        })();
    },
    (_) => {
      async function loadJSON(font) {
        return await get(getPathTo(font, "json"));
      }
      async function loadImage(font) {
        return await new Promise((resolve) => {
          let img = new Image();
          (img.onload = () => resolve(img)),
            (img.crossOrigin = "anonymous"),
            (img.src = getPathTo(font, "png"));
        });
      }
      function getPathTo(font, ext) {
        let mapped = !1,
          fontName = (function () {
            for (let key in GLTextGeometry.fontMapping) {
              let mapping = GLTextGeometry.fontMapping[key];
              if (key == font) return (mapped = !0), mapping;
            }
            return font;
          })(),
          path =
            mapped && GLTextGeometry.fontPath
              ? GLTextGeometry.fontPath
              : "assets/fonts/";
        return Assets.getPath(
          path + fontName + "." + ext + `?${window._CACHE_ || Date.now()}`
        );
      }
      var _promises = {};
      (GLTextGeometry.fontMapping = {}),
        (GLTextGeometry.chars = {}),
        (GLTextGeometry.loadFont = function (font) {
          if (!_promises[font]) {
            let promise = Promise.create();
            (_promises[font] = promise),
              (async function () {
                let [json, image] = await Promise.all([
                  loadJSON(font),
                  loadImage(font),
                ]);
                (glyphs = {}),
                  json.chars.forEach((d) => (glyphs[d.char] = d)),
                  promise.resolve([json, image, glyphs]),
                  (GLTextGeometry.chars[font] = json.chars);
              })();
          }
          return _promises[font];
        });
    }
  ),
  Class(function GLTextThread() {
    function loadTextGeometry(
      {
        font: font,
        text: text,
        width: width,
        align: align,
        size: size,
        letterSpacing: letterSpacing,
        lineHeight: lineHeight,
        wordSpacing: wordSpacing,
        wordBreak: wordBreak,
        langBreak: langBreak,
        json: json,
        glyphs: glyphs,
        config: config,
      },
      pid
    ) {
      function layout() {
        function newLine() {
          const line = { width: 0, glyphs: [] };
          return lines.push(line), (wordCursor = cursor), (wordWidth = 0), line;
        }
        const lines = [];
        let cursor = 0,
          wordCursor = 0,
          wordWidth = 0,
          line = newLine();
        for (; cursor < text.length; ) {
          let char = text[cursor];
          text[cursor + 1];
          if (!line.width && whitespace.test(char)) {
            (wordCursor = ++cursor), (wordWidth = 0);
            continue;
          }
          if (newline.test(char)) {
            cursor++, (line = newLine());
            continue;
          }
          let glyph = glyphs[char];
          if (
            (glyph ||
              (console.log(`missing glyph: ${char}`), (glyph = glyphs.X)),
            line.glyphs.length)
          ) {
            const prevGlyph = line.glyphs[line.glyphs.length - 1][0];
            let kern = getKernPairOffset(glyph.id, prevGlyph.id) * scale;
            (line.width += kern), (wordWidth += kern);
          }
          line.glyphs.push([glyph, line.width]);
          let advance = 0;
          if (
            (whitespace.test(char)
              ? ((wordCursor = cursor),
                (wordWidth = 0),
                (advance += wordSpacing * size))
              : (advance += letterSpacing * size),
            (advance += glyph.xadvance * scale),
            (line.width += advance),
            (wordWidth += advance),
            line.width > width)
          ) {
            if (
              (wordBreak || (char && langBreak && !langbreak.test(char))) &&
              line.glyphs.length > 1
            ) {
              (line.width -= advance), line.glyphs.pop(), (line = newLine());
              continue;
            }
            if (!wordBreak && wordWidth !== line.width) {
              let numGlyphs = cursor - wordCursor + 1;
              line.glyphs.splice(-numGlyphs, numGlyphs),
                (cursor = wordCursor),
                (line.width -= wordWidth),
                (line = newLine());
              continue;
            }
          }
          cursor++;
        }
        line.width || lines.pop(), populateBuffers(lines);
      }
      function populateBuffers(lines) {
        const texW = json.common.scaleW,
          texH = json.common.scaleH;
        let y = (config.baseOffset ? config.baseOffset : 0.07) * size,
          j = 0,
          glyphIndex = 0,
          wordIndex = -1,
          lineId = -1;
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          let line = lines[lineIndex];
          wordIndex++, lineId++;
          for (let i = 0; i < line.glyphs.length; i++) {
            const glyph = line.glyphs[i][0];
            let x = line.glyphs[i][1];
            if (
              ("center" === align
                ? (x -= 0.5 * line.width)
                : "right" === align && (x -= line.width),
              whitespace.test(glyph.char))
            ) {
              wordIndex++;
              continue;
            }
            (x += glyph.xoffset * scale), (y -= glyph.yoffset * scale);
            let w = glyph.width * scale,
              h = glyph.height * scale;
            buffers.position.set(
              [x, y - h, 0, x, y, 0, x + w, y - h, 0, x + w, y, 0],
              4 * j * 3
            ),
              buffers.animation.set(
                [
                  glyphIndex,
                  wordIndex,
                  lineId,
                  glyphIndex,
                  wordIndex,
                  lineId,
                  glyphIndex,
                  wordIndex,
                  lineId,
                  glyphIndex,
                  wordIndex,
                  lineId,
                ],
                3 * glyphIndex * 4
              ),
              glyphIndex++;
            let u = glyph.x / texW,
              uw = glyph.width / texW,
              v = 1 - glyph.y / texH,
              vh = glyph.height / texH;
            buffers.uv.set(
              [u, v - vh, u, v, u + uw, v - vh, u + uw, v],
              4 * j * 2
            ),
              (y += glyph.yoffset * scale),
              j++;
          }
          y -= size * lineHeight;
        }
        let geom;
        window.zUtils3D &&
          ((geom = new Geometry()).addAttribute(
            "position",
            new GeometryAttribute(buffers.position, 3)
          ),
          geom.computeBoundingBox());
        let backing = [];
        for (let key in buffers) backing.push(buffers[key].buffer);
        (buffers.lineLength = lines.length),
          geom && (buffers.boundingBox = geom.boundingBox),
          (buffers.letterCount = glyphIndex),
          (buffers.lineCount = lineId),
          (buffers.wordCount = wordIndex),
          resolve(buffers, pid, backing);
      }
      function getKernPairOffset(id1, id2) {
        for (let i = 0; i < json.kernings.length; i++) {
          let k = json.kernings[i];
          if (!(k.first < id1) && !(k.second < id2))
            return k.first > id1
              ? 0
              : k.first === id1 && k.second > id2
              ? 0
              : k.amount;
        }
        return 0;
      }
      const newline = /\n/,
        whitespace = /\s/,
        langbreak = !!langBreak && new RegExp(langBreak);
      config || (config = {});
      var buffers;
      !(function createGeometry() {
        (fontHeight = json.common.lineHeight),
          (baseline = json.common.base),
          (scale = size / baseline);
        let numChars = text.replace(/[ \n]/g, "").length;
        buffers = {
          position: new Float32Array(4 * numChars * 3),
          uv: new Float32Array(4 * numChars * 2),
          animation: new Float32Array(3 * numChars * 4),
          index: new Uint16Array(6 * numChars),
        };
        for (let i = 0; i < numChars; i++)
          buffers.index.set(
            [4 * i, 4 * i + 2, 4 * i + 1, 4 * i + 1, 4 * i + 2, 4 * i + 3],
            6 * i
          );
        layout();
      })();
    }
    var _list = Thread.shared(!0);
    Thread.upload(loadTextGeometry),
      (this.generate = async function (obj) {
        let thread = _list.get();
        thread.queue && (await thread.queue), (thread.queue = Promise.create());
        let data = await thread.loadTextGeometry(obj);
        return thread.queue.resolve(), data;
      });
  }, "static"),
  Class(function GLUI() {
    function loop() {
      _this.Scene && _this.Scene.render(), _this.Stage && _this.Stage.render();
    }
    Inherit(this, Component);
    const _this = this;
    (window.$gl = function (width, height, map) {
      return new GLUIObject(width, height, map);
    }),
      (window.$glText = function (text, fontName, fontSize, options) {
        return new GLUIText(text, fontName, fontSize, options);
      }),
      (this.init = async function (is2D, is3D) {
        _this.initialized ||
          (void 0 === is2D && ((is2D = !0), (is3D = !0)),
          await AssetLoader.waitForLib("zUtils3D"),
          (_this.initialized = !0),
          is2D && (_this.Stage = new GLUIStage()),
          is3D &&
            ((_this.Scene = new GLUIStage3D()),
            (_this.Scene.interaction.input = Mouse)),
          _this.wait(World, "NUKE", (_) => {
            _this.Scene && (World.NUKE.onBeforeRender = _this.Scene.mark),
              (World.NUKE.postRender = loop);
          }));
      }),
      (this.ready = function () {
        return _this.wait(_this, "initialized");
      });
  }, "static"),
  Class(function GLUIElement() {
    Inherit(this, Component);
    (this.element = $gl(0, 0)),
      (this.create = function (w, h, t) {
        return this.element.create(w, h, t);
      });
  }),
  Class(function GLUIStageInteraction2D(_camera) {
    function testObjects() {
      _test.length = 0;
      for (let i = _objects.length - 1; i > -1; i--) {
        let obj = _objects[i];
        obj.determineVisible() && _test.push(obj);
      }
      return _test;
    }
    function addListeners() {
      _this.events.sub(Mouse.input, Interaction.MOVE, move),
        _this.events.sub(Mouse.input, Interaction.START, start),
        _this.events.sub(Mouse.input, Interaction.END, end);
    }
    function move(e) {
      if (GLUI.PREVENT_INTERACTION) return;
      _ray || ((_ray = new Raycaster(_camera)).testVisibility = !1);
      let hit = _ray.checkHit(testObjects(), e);
      if (hit[0]) {
        GLUI.HIT = !0;
        let obj = hit[0].object.glui;
        _over ||
          ((_over = obj)._onOver({ action: "over", object: obj }),
          Stage.css("cursor", "pointer")),
          _over != obj &&
            (_over._onOver({ action: "out", object: _over }),
            (_over = obj)._onOver({ action: "over", object: obj }),
            Stage.css("cursor", "pointer"));
      } else (GLUI.HIT = !1), _over && (_over._onOver({ action: "out", object: _over }), (_over = null), Stage.css("cursor", "auto"));
    }
    function start(e) {
      GLUI.PREVENT_INTERACTION ||
        (Device.mobile && move(e),
        _over && ((_click = _over), _hold.copy(e), (_hold.time = Date.now())));
    }
    function end(e) {
      if (!GLUI.PREVENT_INTERACTION) {
        if (((GLUI.HIT = !1), _click)) {
          if (
            Date.now() - _hold.time > 750 ||
            _calc.subVectors(e, _hold).length() > 50
          )
            return (_click = null);
          _click == _over &&
            _click._onClick({ action: "click", object: _click });
        }
        _click = null;
      }
    }
    Inherit(this, Component);
    const _this = this;
    var _ray,
      _over,
      _click,
      _test = [],
      _objects = [],
      _hold = new Vector2(),
      _calc = new Vector2();
    addListeners(),
      (this.add = function (obj) {
        _objects.push(obj.mesh || obj);
      }),
      (this.remove = function (obj) {
        _objects.remove(obj.mesh || obj);
      });
  }),
  Class(function GLUIStageInteraction3D() {
    function onHover(e) {
      e.mesh.glui._onOver({ action: e.action, object: e.mesh.glui });
    }
    function onClick(e) {
      e.mesh.glui._onClick({ action: e.action, object: e.mesh.glui });
    }
    Inherit(this, Component);
    (this.add = function (obj, camera = World.CAMERA) {
      Interaction3D.find(camera).add(obj.mesh || obj, onHover, onClick);
    }),
      (this.remove = function (group, camera = World.CAMERA) {
        Interaction3D.find(camera).remove(obj.mesh || obj);
      });
  });
class GLUIObject {
  constructor(width, height, map) {
    let shader = new Shader("GLUIObject", {
      tMap: {
        value:
          "string" == typeof map
            ? "empty" === map || "" === map
              ? null
              : Utils3D.getTexture(map, { premultiplyAlpha: !1 })
            : map,
      },
      uAlpha: { type: "f", value: 1 },
      transparent: !0,
      depthTest: !1,
    });
    (shader.persists = !0),
      map || (shader.visible = !1),
      (this.usingMap = void 0 != map && "empty" != map && "" != map),
      (this.tMap = shader.uniforms.tMap),
      (this.group = new Group()),
      (this.alpha = 1),
      (this._x = 0),
      (this._y = 0),
      (this._z = 0),
      (this._scaleX = 1),
      (this._scaleY = 1),
      (this._scale = 1),
      (this._rotation = 0),
      (this.multiTween = !0),
      (this.dimensions = new Vector3(width, height, 1)),
      (this._shader = shader),
      (this.mesh = new Mesh(GLUIObject.getGeometry("2d"), shader)),
      (this.mesh.glui = this),
      this.group.add(this.mesh);
    const _this = this;
    (this.mesh.onBeforeRender = (_) => {
      if (!_this.mesh.determineVisible() && !_this.firstRender) return;
      let alpha = _this.getAlpha();
      if (
        (_this.mesh.shader.uniforms.uAlpha &&
          (_this.mesh.shader.uniforms.uAlpha.value = alpha),
        _this.usingMap)
      ) {
        if (0 == alpha) return void (_this.mesh.shader.visible = !1);
        _this.mesh.shader.visible = !0;
      }
      if (!_this.isDirty && !_this.firstRender) return;
      (_this.group.position.x = _this._x),
        (_this.group.position.y = _this._3d ? _this._y : -_this._y),
        (_this.group.position.z = _this._z),
        1 != _this.scale &&
          ((_this.group.position.x +=
            (_this.dimensions.x - _this.dimensions.x * _this.scale) / 2),
          (_this.group.position.y -=
            (_this.dimensions.y - _this.dimensions.y * _this.scale) / 2));
      _this.mesh.shader;
      if (_this.calcMask) {
        let v = _this.isMasked;
        v.copy(v.origin),
          _this.group.localToWorld(v),
          (v.z = v.width),
          (v.w = v.height);
      }
      map
        ? (_this.mesh.scale.set(1, 1, 1).multiply(_this.dimensions),
          (_this.group.scale.x = _this._scaleX * _this._scale),
          (_this.group.scale.y = _this._scaleY * _this._scale))
        : _this.group.scale.set(
            _this._scaleX * _this._scale,
            _this._scaleY * _this._scale,
            1
          ),
        _this._3d || (_this.group.rotation.z = Math.radians(_this._rotation)),
        _this.anchor && _this.anchor._parent
          ? (_this.anchor.position.copy(_this.group.position),
            _this.anchor.scale.copy(_this.group.scale),
            _this.anchor.quaternion.setFromEuler(_this._rotation),
            (_this.anchor.isDirty = !0))
          : (_this.group.quaternion.setFromEuler(_this._rotation),
            (_this.group.matrixDirty = !0)),
        _this.firstRender ||
          (_this.group.updateMatrixWorld(!0), (_this.firstRender = !0)),
        (_this.isDirty = !1);
    }),
      (_this.isDirty = !0);
  }
  get width() {
    return this.dimensions.x;
  }
  set width(w) {
    (this.dimensions.x = w), (this.isDirty = !0);
  }
  get height() {
    return this.dimensions.y;
  }
  set height(h) {
    (this.dimensions.y = h), (this.isDirty = !0);
  }
  get x() {
    return this._x;
  }
  set x(v) {
    (this._x = v), (this.isDirty = !0);
  }
  get y() {
    return this._y;
  }
  set y(v) {
    (this._y = v), (this.isDirty = !0);
  }
  get z() {
    return this._z;
  }
  set z(v) {
    (this._z = v), (this.isDirty = !0);
  }
  get scale() {
    return this._scale;
  }
  set scale(v) {
    (this._scale = v), (this.isDirty = !0);
  }
  get scaleX() {
    return this._scaleX;
  }
  set scaleX(v) {
    (this._scaleX = v), (this.isDirty = !0);
  }
  get scaleY() {
    return this._scaleY;
  }
  set scaleY(v) {
    (this._scaleY = v), (this.isDirty = !0);
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(v) {
    (this._rotation = v), (this.isDirty = !0);
  }
  style(props) {
    for (let prop in props) void 0 !== this[prop] && (this[prop] = props[prop]);
    return this;
  }
  size(w, h) {
    return (this.width = w), (this.height = h), this;
  }
  add($obj) {
    return (
      ($obj.parent = this),
      this.group.add($obj.group),
      this.isMasked && $obj.mask(this.isMasked, this.maskShader),
      this._3d && !$obj._3d && $obj.enable3D(),
      this.deferred &&
        ($obj.deferRender(!0),
        $obj.anchor && this.anchor && this.anchor.add($obj.anchor)),
      this
    );
  }
  interact(over, click) {
    (this._onOver = over), (this._onClick = click);
    let stage = this._3d ? GLUI.Scene : GLUI.Stage;
    return (
      over ? stage.interaction.add(this) : stage.interaction.remove(this), this
    );
  }
  clearInteract(over, click) {
    return (
      delete this._onOver,
      delete this._onClick,
      (this._3d ? GLUI.Scene : GLUI.Stage).interaction.remove(this),
      this
    );
  }
  remove() {
    this.mesh.parent
      ? this.group.parent.remove(this.group)
      : this._3d
      ? GLUI.Scene.remove(this)
      : GLUI.Stage.remove(this);
  }
  create(width, height, map) {
    let $obj = $gl(width, height, map);
    return this.add($obj), this._3d && $obj.enable3D(), $obj;
  }
  removeChild(obj) {
    return this.group.remove(obj.group), this;
  }
  tween(obj, time, ease, delay) {
    return tween(this, obj, time, ease, delay);
  }
  enable3D(style2d) {
    (this._3d = !0),
      (this.mesh.geometry = GLUIObject.getGeometry(style2d ? "2d" : "3d")),
      (this.mesh.shader.depthTest = !0),
      (this._rotation = new Euler());
    const _this = this;
    return (
      _this._rotation.onChange((_) => {
        _this.isDirty = !0;
      }),
      this
    );
  }
  setZ(z) {
    return (this.mesh.renderOrder = z), this;
  }
  bg(path) {
    if (void 0 === path) throw "Do not set undefined bg path";
    return (
      (this._shader.uniforms.tMap.value =
        "string" == typeof path
          ? Utils3D.getTexture(path, { premultiplyAlpha: !1 })
          : path),
      this
    );
  }
  show() {
    return (
      (this.group.matrixDirty = !0),
      (this.mesh.matrixDirty = !0),
      (this.group.visible = !0),
      this
    );
  }
  hide() {
    return (this.group.visible = !1), this;
  }
  useShader(shader) {
    return (
      shader &&
        ((shader.uniforms.tMap = this.mesh.shader.uniforms.tMap),
        (shader.uniforms.uAlpha = this.mesh.shader.uniforms.uAlpha)),
      (this.mesh.shader = shader || this._shader),
      this
    );
  }
  depthTest(bool) {
    this.mesh.shader.depthTest = bool;
  }
  useGeometry(geom) {
    return (this.mesh.geometry = geom), this;
  }
  updateMap(src) {
    this.shader.uniforms.tMap.value =
      "string" == typeof src ? Utils3D.getTexture(src) : src;
  }
  mask(d, shaderName) {
    var v;
    if (
      (d instanceof Vector4
        ? ((this.isMasked = !0), (v = d))
        : (((v = new Vector4(d.x, d.y, 0, 1)).origin = new Vector4().copy(v)),
          (v.width = d.width),
          (v.height = d.height),
          (this.calcMask = !0),
          (this.isMasked = v)),
      (this.maskShader = shaderName),
      this.usingMap)
    ) {
      let shader = new Shader(shaderName || "GLUIObjectMask", {
        tMap: this.tMap,
        uAlpha: { value: 1 },
        mask: { type: "v4", value: v },
        transparent: !0,
        depthWrite: !1,
        depthTest: !1,
      });
      this.useShader(shader);
    }
    return (
      this.group.traverse((obj) => {
        obj.glui && obj.glui != this && obj.glui.mask(v, shaderName);
      }),
      v
    );
  }
  deferRender(parent) {
    (this.deferred = !0),
      parent || ((this.anchor = new Group()), GLUI.Scene.addDeferred(this));
  }
  clearTween() {
    return (
      this._mathTweens &&
        this._mathTweens.forEach((t) => {
          t.tween.stop();
        }),
      this
    );
  }
  getAlpha() {
    if (this._gluiParent) {
      let alpha = this._gluiParent.getAlpha();
      return (this.alpha = alpha), alpha;
    }
    let alpha = this.alpha,
      $parent = this.parent;
    for (; $parent; ) (alpha *= $parent.alpha), ($parent = $parent.parent);
    return alpha;
  }
}
!(function () {
  var _geom2d, _geom3d;
  (GLUIObject.getGeometry = function (type) {
    return "2d" == type
      ? (_geom2d ||
          (_geom2d = new PlaneGeometry(1, 1)).applyMatrix(
            new Matrix4().makeTranslation(0.5, -0.5, 0)
          ),
        _geom2d)
      : (_geom3d || (_geom3d = World.PLANE), _geom3d);
  }),
    (GLUIObject.clear = function () {
      _geom2d = _geom3d = null;
    });
})();
class GLUIText {
  constructor(text, fontName, fontSize, options = {}) {
    (options.font = fontName || options.font),
      (options.text = text),
      (options.width = options.width),
      (options.align = options.align || "left"),
      (options.size = fontSize || options.size),
      (options.lineHeight = options.lineHeight),
      (options.letterSpacing = options.letterSpacing),
      (options.wordSpacing = options.wordSpacing),
      (options.wordBreak = options.wordBreak),
      (options.langBreak = options.langBreak),
      (options.color = new Color(options.color)),
      (this.text = new GLText(options)),
      (this.group = new Group()),
      (this.alpha = 1),
      (this._x = 0),
      (this._y = 0),
      (this._z = 0),
      (this._scaleX = 1),
      (this._scaleY = 1),
      (this._scale = 1),
      (this._rotation = 0),
      (this.multiTween = !0);
    const _this = this;
    this.text.ready().then((_) => {
      let mesh = _this.text.mesh;
      (mesh.glui = _this),
        (mesh.shader.visible = !1),
        (_this.mesh = mesh),
        _this.group.add(mesh),
        _this._3d && !_this._style2d && _this.text.centerY(),
        _this._3d || (_this.text.mesh.shader.depthTest = !1),
        (mesh.onBeforeRender = (_) => {
          if (!mesh.determineVisible() && !_this.firstRender) return;
          let alpha = _this.getAlpha();
          mesh.shader.uniforms.uAlpha &&
            (mesh.shader.uniforms.uAlpha.value = alpha),
            0 != alpha
              ? ((mesh.shader.visible = !0),
                (_this.isDirty || _this.firstRender) &&
                  ((_this.group.position.x = _this._x),
                  (_this.group.position.y = _this._3d ? _this._y : -_this._y),
                  (_this.group.position.z = _this._z),
                  _this.group.scale.set(
                    _this._scaleX * _this._scale,
                    _this._scaleY * _this._scale,
                    1
                  ),
                  _this._3d
                    ? _this.anchor && _this.anchor._parent
                      ? (_this.anchor.position.copy(_this.group.position),
                        _this.anchor.scale.copy(_this.group.scale),
                        _this.anchor.quaternion.setFromEuler(_this._rotation))
                      : _this.group.quaternion.setFromEuler(_this._rotation)
                    : (_this.group.rotation.z = Math.radians(_this._rotation)),
                  _this.firstRender ||
                    (_this.group.updateMatrixWorld(!0),
                    (_this.firstRender = !0),
                    (mesh.shader.visible = !0)),
                  (_this.isDirty = !1)))
              : (mesh.shader.visible = !1);
        });
    });
  }
  get x() {
    return this._x;
  }
  set x(v) {
    (this._x = v), (this.isDirty = !0);
  }
  get y() {
    return this._y;
  }
  set y(v) {
    (this._y = v), (this.isDirty = !0);
  }
  get z() {
    return this._z;
  }
  set z(v) {
    (this._z = v), (this.isDirty = !0);
  }
  get scale() {
    return this._scale;
  }
  set scale(v) {
    (this._scale = v), (this.isDirty = !0);
  }
  get scaleX() {
    return this._scaleX;
  }
  set scaleX(v) {
    (this._scaleX = v), (this.isDirty = !0);
  }
  get scaleY() {
    return this._scaleY;
  }
  set scaleY(v) {
    (this._scaleY = v), (this.isDirty = !0);
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(v) {
    (this._rotation = v), (this.isDirty = !0);
  }
  get dimensions() {
    return (
      this._dimensions || (this._dimensions = {}),
      this.text &&
        this.text.geometry &&
        !this._dimensions.max &&
        ((this._dimensions = this.text.geometry.boundingBox),
        (this._dimensions.width = Math.abs(
          this._dimensions.min.x - this._dimensions.max.x
        )),
        (this._dimensions.height = Math.abs(
          this._dimensions.min.y - this._dimensions.max.y
        ))),
      this._dimensions
    );
  }
  interact(over, click) {
    (this._onOver = over), (this._onClick = click);
    let stage = this._3d ? GLUI.Scene : GLUI.Stage;
    const _this = this;
    return (
      _this.text.ready().then((_) => {
        if (over) {
          if (
            (_this.text.geometry.boundingBox ||
              _this.text.geometry.computeBoundingBox(),
            !_this.hitArea)
          ) {
            let bb = _this.text.geometry.boundingBox,
              shader = Utils3D.getTestShader();
            (shader.visible = !1),
              (_this.hitArea = new Mesh(World.PLANE, shader)),
              (_this.hitArea.glui = _this),
              _this.hitArea.scale.set(
                Math.abs(bb.min.x) + Math.abs(bb.max.x),
                Math.abs(bb.min.y) + Math.abs(bb.max.y),
                1
              ),
              (_this._3d && !_this._style2d) ||
                (_this.hitArea.position.x = (bb.max.x - bb.min.x) / 2),
              (_this.hitArea.position.y = (bb.min.y - bb.max.y) / 2),
              _this.text.mesh.add(_this.hitArea);
          }
          stage.interaction.add(_this.hitArea);
        } else stage.interaction.remove(_this.hitArea);
      }),
      this
    );
  }
  remove() {
    this.mesh && this.mesh.parent
      ? this.group.parent.remove(this.group)
      : this._3d
      ? GLUI.Scene.remove(this)
      : GLUI.Stage.remove(this),
      this.text.destroy();
  }
  tween(obj, time, ease, delay) {
    return tween(this, obj, time, ease, delay);
  }
  enable3D(style2d) {
    (this._3d = !0), (this._style2d = style2d), (this._rotation = new Euler());
    const _this = this;
    return (
      _this._rotation.onChange((_) => {
        _this.isDirty = !0;
      }),
      _this.text.ready().then((_) => {
        _this.text.mesh.shader.depthTest = !0;
      }),
      (_this.isDirty = !0),
      this
    );
  }
  depthTest(bool) {
    const _this = this;
    return (
      _this.text.ready().then((_) => {
        _this.text.mesh.shader.depthTest = bool;
      }),
      this
    );
  }
  setZ(z) {
    const _this = this;
    return (
      _this.text.ready().then((_) => {
        _this.text.mesh.renderOrder = z;
      }),
      this
    );
  }
  height() {
    return this.mesh ? this.text.height : 0;
  }
  setText(text, options) {
    const _this = this;
    return (
      (this._dimensions = null),
      _this.text.ready().then((_) => _this.text.setText(text, options)),
      this
    );
  }
  getTextString() {
    return this.text.string;
  }
  setColor(color) {
    const _this = this;
    return _this.text.ready().then((_) => _this.text.setColor(color)), this;
  }
  tweenColor(color, time, ease, delay) {
    const _this = this;
    return (
      _this.text
        .ready()
        .then((_) => _this.text.tweenColor(color, time, ease, delay)),
      this
    );
  }
  resize(options) {
    const _this = this;
    _this.text.ready().then((_) => _this.text.resize(options));
  }
  show() {
    return (
      this.text.ready().then((_) => {
        (this.text.mesh.visible = !0), this.text.mesh.updateMatrixWorld(!0);
      }),
      this
    );
  }
  hide() {
    const _this = this;
    return _this.text.ready().then((_) => (_this.text.mesh.visible = !1)), this;
  }
  loaded() {
    return this.text.ready();
  }
  length() {
    return this.text.charLength;
  }
  deferRender(parent) {
    (this.deferred = !0),
      parent || ((this.anchor = new Group()), GLUI.Scene.addDeferred(this));
  }
  getAlpha() {
    if (this._gluiParent) {
      let alpha = this._gluiParent.getAlpha();
      return (this.alpha = alpha), alpha;
    }
    let alpha = this.alpha,
      $parent = this.parent;
    for (; $parent; ) (alpha *= $parent.alpha), ($parent = $parent.parent);
    return alpha;
  }
  size() {}
  upload() {
    const _this = this;
    return _this.text.ready().then((_) => _this.text.mesh.upload()), this;
  }
  async useShader(shader) {
    await this.text.ready(),
      (shader.uniforms.tMap = this.text.shader.uniforms.tMap),
      (shader.uniforms.uAlpha = this.text.shader.uniforms.uAlpha),
      (shader.uniforms.uColor = this.text.shader.uniforms.uColor),
      (!this._3d || this._3d || this.parent) && (shader.depthTest = !1),
      (this.text.mesh.shader = shader || text.shader);
  }
}
Class(function GLUIStage() {
  function addListeners() {
    _this.events.sub(Events.RESIZE, resizeHandler);
  }
  function resizeHandler() {
    (_camera.left = Stage.width / -2),
      (_camera.right = Stage.width / 2),
      (_camera.top = Stage.height / 2),
      (_camera.bottom = Stage.height / -2),
      (_camera.near = 0.01),
      (_camera.far = 1e3),
      _camera.updateProjectionMatrix(),
      (_camera.position.x = Stage.width / 2),
      (_camera.position.y = -Stage.height / 2);
  }
  Inherit(this, Component);
  const _this = this;
  var _scene = new Scene(),
    _camera = new OrthographicCamera(1, 1, 1, 1, 0.1, 1);
  (this.interaction = new GLUIStageInteraction2D(_camera)),
    (this.alpha = 1),
    (_scene.disableAutoSort = !0),
    (_camera.position.z = 1),
    addListeners(),
    resizeHandler(),
    (this.add = function ($obj) {
      ($obj.parent = _this), _scene.add($obj.group || $obj.mesh);
    }),
    (this.remove = function ($obj) {
      ($obj.parent = null), _scene.remove($obj.group);
    }),
    (this.renderToRT = function (scene, rt) {
      let clearAlpha;
      rt.fxscene &&
        rt.fxscene.clearAlpha > -1 &&
        ((clearAlpha = World.RENDERER.getClearAlpha()),
        World.RENDERER.setClearAlpha(0)),
        World.RENDERER.render(scene, _camera, rt),
        clearAlpha && World.RENDERER.setClearAlpha(clearAlpha);
    }),
    (this.render = function loop() {
      if (!_scene.children.length) return;
      let clear = World.RENDERER.autoClear;
      (World.RENDERER.autoClear = !1),
        World.RENDERER.render(_scene, _camera),
        (World.RENDERER.autoClear = clear);
    });
}),
  Class(function GLUIStage3D() {
    Inherit(this, Object3D);
    const _this = this;
    var _camera,
      _scene = new Scene(),
      _list = new LinkedList();
    (this.alpha = 1),
      (this.interaction = new GLUIStageInteraction3D()),
      (this.add = function (obj, parent) {
        (obj.parent = _this),
          (obj._gluiParent = parent),
          obj._3d || obj.enable3D(),
          obj.deferRender();
      }),
      (this.addDeferred = function (obj) {
        _list.push(obj), _scene.add(obj.group || obj.mesh);
      }),
      (this.remove = function (obj) {
        this.interaction.remove(obj.group),
          _scene.remove(obj.group || obj.mesh),
          _list.remove(obj);
      }),
      (this.disableAutoSort = function () {
        _scene.disableAutoSort = !0;
      }),
      (this.render = function loop() {
        if (!_list.length) return;
        let obj = _list.start();
        for (; obj; )
          obj._marked &&
            ((obj._marked = !1), Utils3D.decompose(obj.anchor, obj.group)),
            (obj = _list.next());
        let clear = World.RENDERER.autoClear;
        Renderer.context.clear(Renderer.context.DEPTH_BUFFER_BIT),
          (World.RENDERER.autoClear = !1),
          World.RENDERER.render(_scene, _camera || World.CAMERA),
          (World.RENDERER.autoClear = clear);
      }),
      (this.mark = function mark() {
        let obj = _list.start();
        for (; obj; )
          obj.anchor._parent &&
            (obj.group.visible = obj.anchor.determineVisible()),
            obj.mesh &&
              obj.mesh.determineVisible() &&
              obj.anchor._parent &&
              (obj._marked = !0),
            (obj = _list.next());
      }),
      this.set("camera", (c) => {
        _camera = c.camera || c;
      });
  }),
  Class(function GPU() {
    function test() {
      function factors(n) {
        var i,
          out = [],
          sqrt_n = Math.sqrt(n);
        for (i = 2; i <= sqrt_n; i++) n % i == 0 && out.push(i);
        return out;
      }
      function primep(n) {
        return 0 === factors(n).length;
      }
      function largest_prime_factor(n) {
        return factors(n).filter(primep).pop();
      }
      let time = performance.now();
      return (
        (function getPrime() {
          return largest_prime_factor(1e11);
        })(),
        10 * (performance.now() - time)
      );
    }
    function matchiOS() {
      let res =
          Math.min(screen.width, screen.height) +
          "x" +
          Math.max(screen.width, screen.height),
        time = test();
      switch (res) {
        case "320x480":
          Device.graphics.webgl.gpu = "legacy";
          break;
        case "320x568":
          Device.graphics.webgl.gpu =
            time <= 400 ? "apple a8" : time <= 500 ? "apple a7" : "legacy";
          break;
        case "375x812":
        case "414x896":
          Device.graphics.webgl.gpu = time <= 180 ? "apple a12" : "apple a11";
          break;
        default:
        case "414x736":
        case "375x667":
        case "768x1024":
          Device.graphics.webgl.gpu =
            time <= 180
              ? "apple a12"
              : time <= 220
              ? "apple a11"
              : time <= 250
              ? "apple a10"
              : time <= 360
              ? "apple a9"
              : time <= 400
              ? "apple a8"
              : time <= 600
              ? "apple a7"
              : "legacy";
          break;
        case "834x1112":
          Device.graphics.webgl.gpu =
            time <= 180 ? "apple a12" : time <= 220 ? "apple a11" : "apple a10";
          break;
        case "834x1194":
          Device.graphics.webgl.gpu = "apple a12";
          break;
        case "1024x1366":
          Device.graphics.webgl.gpu =
            time <= 180
              ? "apple a12"
              : time <= 220
              ? "apple a11"
              : time <= 250
              ? "apple a10"
              : "apple a9";
      }
    }
    Inherit(this, Component);
    var _this = this,
      _split = {};
    Hydra.ready(async () => {
      function splitGPU(string) {
        if (_split[string]) return _split[string];
        if (!_this.detect(string)) return -1;
        try {
          var num = Number(_this.gpu.split(string)[1].split(" ")[0]);
          return (_split[string] = num), num;
        } catch (e) {
          return -1;
        }
      }
      (_this.detect = function (match) {
        if (Device.graphics.webgl) return Device.graphics.webgl.detect(match);
      }),
        (_this.detectAll = function () {
          if (Device.graphics.webgl) {
            for (var match = !0, i = 0; i < arguments.length; i++)
              Device.graphics.webgl.detect(arguments[i]) || (match = !1);
            return match;
          }
        }),
        (_this.matchGPU = function (str, min, max = 99999) {
          let num = splitGPU(str);
          return num >= min && num < max;
        }),
        (_this.gpu = Device.graphics.webgl ? Device.graphics.webgl.gpu : ""),
        "ios" == Device.system.os && "apple gpu" == _this.gpu && matchiOS(),
        (_this.BLACKLIST = require("GPUBlacklist").match()),
        (_this.T0 =
          !Device.mobile &&
          (!!_this.BLACKLIST ||
            !!_this.detect("radeon(tm) r5") ||
            (_this.detectAll("intel", "hd")
              ? _this.matchGPU("hd graphics ", 1e3, 5001)
              : "intel iris opengl engine" === _this.gpu.toLowerCase() ||
                !!_this.matchGPU("iris(tm) graphics ", 1e3)))),
        (_this.T1 =
          !_this.BLACKLIST &&
          !Device.mobile &&
          (!!_this.matchGPU("iris(tm) graphics ", 540, 1e3) ||
            !!_this.matchGPU("hd graphics ", 514, 1e3) ||
            (!_this.detect(["nvidia", "amd", "radeon", "geforce"]) &&
              !_this.T0))),
        (_this.T2 =
          !_this.BLACKLIST &&
          !Device.mobile &&
          !(
            !_this.detect(["nvidia", "amd", "radeon", "geforce"]) ||
            _this.T1 ||
            _this.T0
          )),
        (_this.T3 =
          !_this.BLACKLIST &&
          !Device.mobile &&
          (!!_this.detect(["titan", "amd radeon pro", "quadro"]) ||
            !!_this.matchGPU("gtx ", 940) ||
            !!_this.matchGPU("radeon (tm) rx ", 400) ||
            !!_this.matchGPU("radeon rx ", 400) ||
            !!_this.matchGPU("radeon pro ", 420))),
        (_this.T4 =
          !_this.BLACKLIST &&
          !Device.mobile &&
          (!!_this.detect(["titan", "quadro", "vega", "radeon vii"]) ||
            !!_this.matchGPU("gtx ", 1040) ||
            !!_this.matchGPU("rtx") ||
            !!_this.matchGPU("radeon rx ", 500))),
        (_this.T5 =
          !_this.BLACKLIST &&
          !Device.mobile &&
          (!!_this.detect(["titan", "vega", "radeon vii"]) ||
            !!_this.matchGPU("gtx ", 1080) ||
            !!_this.matchGPU("rtx ", 2060))),
        (_this.MT0 =
          !!Device.mobile &&
          (!!_this.BLACKLIST ||
            !("ios" != Device.system.os || !_this.detect("a7")) ||
            !("android" != Device.system.os || !_this.detect("sgx")) ||
            (_this.detect("adreno")
              ? _this.matchGPU("adreno (tm) ", 0, 330)
              : !!_this.detect("mali") && _this.matchGPU("mali-t", 0, 628)))),
        (_this.MT1 =
          !!Device.mobile &&
          !_this.BLACKLIST &&
          (!("ios" != Device.system.os || !_this.detect("a8")) ||
            ("android" == Device.system.os && !_this.MT0))),
        (_this.MT2 =
          !!Device.mobile &&
          !_this.BLACKLIST &&
          (!("ios" != Device.system.os || !_this.detect("a9")) ||
            (_this.detect("adreno")
              ? _this.matchGPU("adreno (tm) ", 399)
              : !!_this.detect("mali-g")))),
        (_this.MT3 =
          !!Device.mobile &&
          !_this.BLACKLIST &&
          (!("ios" != Device.system.os || !_this.detect(["a10"])) ||
            !(!_this.detect("nvidia tegra") || !Device.detect("pixel c")) ||
            (_this.detect("adreno")
              ? _this.matchGPU("adreno (tm) ", 530)
              : _this.detect("mali-g")
              ? _this.matchGPU("mali-g", 71)
              : !!navigator.platform.toLowerCase().includes("mac")))),
        (_this.MT4 =
          !!Device.mobile &&
          !_this.BLACKLIST &&
          (!(
            "ios" != Device.system.os ||
            !_this.detect([
              "a11",
              "a12",
              "a13",
              "a14",
              "a15",
              "a16",
              "a17",
              "a18",
            ])
          ) ||
            (_this.detect("adreno")
              ? _this.matchGPU("adreno (tm) ", 630)
              : !!navigator.platform.toLowerCase().includes("mac")))),
        (_this.lt = function (num) {
          return _this.TIER > -1 && _this.TIER <= num;
        }),
        (_this.gt = function (num) {
          return _this.TIER > -1 && _this.TIER >= num;
        }),
        (_this.eq = function (num) {
          return _this.TIER > -1 && _this.TIER == num;
        }),
        (_this.mobileEq = function (num) {
          return _this.M_TIER > -1 && _this.M_TIER == num;
        }),
        (_this.mobileLT = function (num) {
          return _this.M_TIER > -1 && _this.M_TIER <= num;
        }),
        (_this.mobileGT = function (num) {
          return _this.M_TIER > -1 && _this.M_TIER >= num;
        });
      for (var key in _this)
        "T" == key.charAt(0) &&
          !0 === _this[key] &&
          (_this.TIER = Number(key.charAt(1))),
          "MT" == key.slice(0, 2) &&
            !0 === _this[key] &&
            (_this.M_TIER = Number(key.charAt(2)));
      !1 !== Utils.query("gpu") &&
        (Device.mobile || Utils.query("gpu").toString().includes("m")
          ? ((_this.TIER = -1),
            (_this.M_TIER = Number(Utils.query("gpu").slice(1))))
          : (_this.TIER = Number(Utils.query("gpu")))),
        (_this.OVERSIZED =
          !Device.mobile &&
          _this.TIER < 2 &&
          Math.max(window.innerWidth, window.innerHeight) > 1600),
        (_this.initialized = !0);
    }),
      (this.ready = function () {
        return this.wait("initialized");
      });
  }, "static"),
  Module(function GPUBlacklist() {
    this.exports = {
      match: function () {
        return (
          !Device.graphics.webgl ||
          Device.graphics.webgl.detect([
            "radeon hd 6970m",
            "radeon hd 6770m",
            "radeon hd 6490m",
            "radeon hd 6630m",
            "radeon hd 6750m",
            "radeon hd 5750",
            "radeon hd 5670",
            "radeon hd 4850",
            "radeon hd 4870",
            "radeon hd 4670",
            "geforce 9400m",
            "geforce 320m",
            "geforce 330m",
            "geforce gt 130",
            "geforce gt 120",
            "geforce gtx 285",
            "geforce 8600",
            "geforce 9600m",
            "geforce 9400m",
            "geforce 8800 gs",
            "geforce 8800 gt",
            "quadro fx 5",
            "quadro fx 4",
            "radeon hd 2600",
            "radeon hd 2400",
            "radeon hd 2600",
            "radeon r9 200",
            "mali-4",
            "mali-3",
            "mali-2",
          ])
        );
      },
    };
  }),
  Class(function Initializer3D() {
    async function resolve() {
      await Promise.all(_promises),
        clearTimeout(_this.fire),
        (_this.fire = _this.delayedCall((_) => {
          _this.events.fire(_this.READY),
            (_this.resolved = !0),
            (Utils3D.onTextureCreated = null),
            _loader && _loader.trigger(50);
        }, 100));
    }
    async function workQueue() {
      _working = !0;
      let promise = _queue.shift();
      if (!promise) return (_working = !1);
      promise.resolve(workQueue);
    }
    function incCompleted() {
      _loader && _loader.trigger(1);
    }
    Inherit(this, Component);
    const _this = this;
    var _loader,
      _working,
      _promises = [],
      _queue = [];
    (this.READY = "initializer_ready"),
      (this.bundle = function () {
        return new (function PromiseBundler() {
          function run() {
            clearTimeout(timer),
              (timer = _this.delayedCall((_) => {
                Promise.all(promises).then((_) => ready.resolve());
              }, 100));
          }
          const promises = [],
            ready = Promise.create();
          var timer;
          (this.capture = function (promise) {
            promises.push(promise), run();
          }),
            (this.ready = function () {
              return run(), ready;
            });
        })();
      }),
      (this.promise = this.capture =
        function (promise) {
          return (
            _loader && _loader.add(1),
            promise.then(incCompleted),
            _promises.push(promise),
            clearTimeout(_this.timer),
            (_this.timer = _this.delayedCall(resolve, 100)),
            promise
          );
        }),
      (this.ready = this.loaded =
        function () {
          return _this.wait(_this, "resolved");
        }),
      (this.createWorld = async function () {
        await Promise.all([
          AssetLoader.waitForLib("zUtils3D"),
          Shaders.ready(),
          UILStorage.ready(),
        ]),
          World.instance();
      }),
      (this.linkSceneLayout = function (loader) {
        _this.captureTextures(),
          (SceneLayout.initializer = _this.capture),
          (_loader = loader);
      }),
      (this.queue = function () {
        let promise = Promise.create();
        return _queue.push(promise), _working || workQueue(), promise;
      }),
      (this.captureTextures = function () {
        Utils3D.onTextureCreated = (texture) => {
          _this.promise(texture.promise);
        };
      }),
      (this.uploadAll = function (group) {
        let promises = [];
        return (
          group.traverse((obj) => {
            if (obj.shader)
              for (let key in obj.shader.uniforms) {
                let uniform = obj.shader.uniforms[key];
                uniform.value instanceof Texture &&
                  uniform.value.promise &&
                  promises.push(
                    uniform.value.promise.then((_) => uniform.value.upload())
                  );
              }
            obj.upload && obj.upload();
          }),
          Promise.all(promises)
        );
      }),
      (this.uploadAllDistributed = function (group) {
        let uploads = [],
          promises = [];
        group.traverse((obj) => {
          if (obj.shader)
            for (let key in obj.shader.uniforms) {
              let uniform = obj.shader.uniforms[key];
              uniform.value instanceof Texture &&
                uniform.value.promise &&
                promises.push(
                  uniform.value.promise.then((_) =>
                    uploads.push(uniform.value.upload.bind(uniform.value))
                  )
                );
            }
          obj.upload && uploads.push(obj.upload.bind(obj));
        });
        let canFinish = !1,
          promise = Promise.create(),
          worker = new Render.Worker((_) => {
            let upload = uploads.shift();
            upload
              ? upload()
              : canFinish
              ? (worker.stop(), promise.resolve())
              : worker.pause();
          }, 1);
        return (
          Promise.all(promises).then((_) => {
            worker.resume(), (canFinish = !0);
          }),
          promise
        );
      }),
      this.set("loader", (loader) => {
        _loader = loader;
      });
  }, "static"),
  Class(function LineGeometry({
    index: index = 0,
    points: points = [],
    taperFunction: taperFunction = () => 1,
    defaultCount: defaultCount = 200,
  }) {
    function initBuffers(count) {
      _geometry.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(3 * count * 2), 3)
      ),
        _geometry.addAttribute(
          "previous",
          new GeometryAttribute(new Float32Array(3 * count * 2), 3)
        ),
        _geometry.addAttribute(
          "next",
          new GeometryAttribute(new Float32Array(3 * count * 2), 3)
        ),
        _geometry.addAttribute(
          "side",
          new GeometryAttribute(new Float32Array(1 * count * 2), 1)
        ),
        _geometry.addAttribute(
          "lineIndex",
          new GeometryAttribute(new Float32Array(1 * count * 2), 1)
        ),
        _geometry.addAttribute(
          "width",
          new GeometryAttribute(new Float32Array(1 * count * 2), 1)
        ),
        _geometry.addAttribute(
          "uv",
          new GeometryAttribute(new Float32Array(2 * count * 2), 2)
        ),
        _geometry.addAttribute(
          "uv2",
          new GeometryAttribute(new Float32Array(2 * count * 2), 2)
        ),
        _geometry.setIndex(
          new GeometryAttribute(new Uint16Array(3 * (count - 1) * 2), 1)
        ),
        (_length = 0),
        (_count = 0),
        setStaticBuffers(count);
    }
    function setStaticBuffers(count) {
      for (let i = 0; i < count; i++) {
        if (
          (_attr.side.setXY(2 * i, 1, -1),
          _attr.lineIndex.setXY(2 * i, _this.index, _this.index),
          i === count - 1)
        )
          continue;
        let ind = 2 * i;
        (_geometry.index[3 * (ind + 0) + 0] = ind + 0),
          (_geometry.index[3 * (ind + 0) + 1] = ind + 1),
          (_geometry.index[3 * (ind + 0) + 2] = ind + 2),
          (_geometry.index[3 * (ind + 1) + 0] = ind + 2),
          (_geometry.index[3 * (ind + 1) + 1] = ind + 1),
          (_geometry.index[3 * (ind + 1) + 2] = ind + 3);
      }
    }
    function increaseBuffers() {
      initBuffers(_attr.position.count / 2 + defaultCount);
    }
    function getPos(index) {
      let i = 3 * index;
      return [points[i], points[i + 1], points[i + 2]];
    }
    function update(isReset) {
      isReset && (_count = 0);
      let newLength = points.length / 3;
      2 * newLength > _attr.position.count && increaseBuffers();
      let oldLength = _count;
      if (oldLength) {
        let nxt = getPos(oldLength);
        _attr.next.setXYZ(2 * (oldLength - 1) + 0, nxt[0], nxt[1], nxt[2]),
          _attr.next.setXYZ(2 * (oldLength - 1) + 1, nxt[0], nxt[1], nxt[2]);
      }
      for (let i = oldLength; i < newLength; i++) {
        _attr.position.setXYZ(
          2 * i + 0,
          points[3 * i + 0],
          points[3 * i + 1],
          points[3 * i + 2]
        ),
          _attr.position.setXYZ(
            2 * i + 1,
            points[3 * i + 0],
            points[3 * i + 1],
            points[3 * i + 2]
          );
        let prv = getPos(Math.max(0, i - 1)),
          nxt = getPos(Math.min(newLength - 1, i + 1));
        0 === i &&
          ((prv[0] -= nxt[0] - prv[0]),
          (prv[1] -= nxt[1] - prv[1]),
          (prv[2] -= nxt[2] - prv[2])),
          i === newLength - 1 &&
            ((nxt[0] += nxt[0] - prv[0]),
            (nxt[1] += nxt[1] - prv[1]),
            (nxt[2] += nxt[2] - prv[2])),
          _attr.previous.setXYZ(2 * i + 0, prv[0], prv[1], prv[2]),
          _attr.previous.setXYZ(2 * i + 1, prv[0], prv[1], prv[2]),
          _attr.next.setXYZ(2 * i + 0, nxt[0], nxt[1], nxt[2]),
          _attr.next.setXYZ(2 * i + 1, nxt[0], nxt[1], nxt[2]),
          _prev.fromArray(prv),
          _curr.fromArray(getPos(i)),
          (_length += _prev.distanceTo(_curr)),
          _attr.uv2.setX(2 * i + 0, _length),
          _attr.uv2.setX(2 * i + 1, _length);
      }
      for (let i = 0; i < newLength; i++) {
        _attr.uv.setXY(2 * i + 0, i / newLength, 0),
          _attr.uv.setXY(2 * i + 1, i / newLength, 1),
          _attr.uv2.setY(2 * i + 0, _length),
          _attr.uv2.setY(2 * i + 1, _length);
        let w = _this.taperFunction(i / (newLength - 1), i, newLength);
        _attr.width.setXY(2 * i, w, w);
      }
      (_attr.position.needsUpdate = !0),
        (_attr.previous.needsUpdate = !0),
        (_attr.next.needsUpdate = !0),
        (_attr.width.needsUpdate = !0),
        (_attr.uv.needsUpdate = !0),
        (_attr.uv2.needsUpdate = !0),
        (_count = newLength);
    }
    Inherit(this, Component);
    const _this = this;
    (_this.index = index),
      (_this.points = points),
      (_this.taperFunction = taperFunction);
    const _geometry = (_this.geometry = new Geometry()),
      _attr = _geometry.attributes;
    let _prev = new Vector3(),
      _curr = new Vector3(),
      _length = 0,
      _count = 0;
    initBuffers(points.length ? points.length / 3 : defaultCount),
      points.length && update(),
      (this.update = update);
  }),
  Class(function MouseFlowMapRenderer(_size) {
    function init() {
      _camera.position.z = 1;
    }
    Inherit(this, Component);
    const _this = this;
    let _shader;
    const _scene1 = new Scene(),
      _scene2 = new Scene(),
      _camera = new OrthographicCamera(0, 1, 1, 0, 0.1, 2);
    let _count = 0;
    const _rtPing = Utils3D.createRT(_size, _size),
      _rtPong = Utils3D.createRT(_size, _size);
    (this.rt = Utils3D.createRT(_size, _size, null, Texture.RGBAFormat)),
      (this.textureUniform = { type: "t", value: null, ignoreUIL: !0 }),
      init(),
      (this.add = function (mesh) {
        _scene1.add(mesh);
      }),
      (this.setShader = function (shader) {
        _shader = shader;
        let mesh = new Mesh(new PlaneGeometry(2, 2), shader);
        _scene2.add(mesh);
      }),
      (this.draw = function () {
        if (!_shader) return;
        _count++;
        const clearAlphaCache = Renderer.CLEAR[3];
        (Renderer.CLEAR[3] = 0),
          World.RENDERER.render(_scene1, _camera, _this.rt),
          _count % 2 == 0
            ? ((_shader.uniforms.uTexture.value = _rtPing.texture),
              World.RENDERER.render(_scene2, _camera, _rtPong),
              (_this.textureUniform.value = _rtPong.texture))
            : ((_shader.uniforms.uTexture.value = _rtPong.texture),
              World.RENDERER.render(_scene2, _camera, _rtPing),
              (_this.textureUniform.value = _rtPing.texture)),
          (_shader.uniforms.uFirstDraw.value = 0),
          (Renderer.CLEAR[3] = clearAlphaCache);
      });
  }),
  Class(function MouseFlowMapTouch() {
    Inherit(this, Component);
    const _this = this,
      _touch = (new Vector2(), new Vector2()),
      _touchLast = new Vector2(),
      _touchStep = new Vector2(),
      _velocity = new Vector2(),
      _current = new Vector2(),
      _delta = new Vector2(),
      _last = new Vector2();
    (this.velocity = new Vector2()),
      (this.ticks = 0),
      (this.render = function (decay, numStamps) {
        _velocity.multiplyScalar(decay),
          _this.velocity.lerp(_velocity, 0.5),
          _touch.lerp(_current, 0.4),
          _touchStep
            .copy(_touch)
            .sub(_touchLast)
            .multiplyScalar(1 / numStamps),
          _touchLast.copy(_touch);
      }),
      (this.move = function (e) {
        _this.isMouseLeft &&
          ((_this.isMouseLeft = !1),
          _touch.copy(Mouse.inverseNormal),
          _touchLast.copy(_touch)),
          e.x != _last.x &&
            ((_current.x = e.x / Stage.width),
            (_current.y = 1 - e.y / Stage.height),
            (_delta.x = e.x - _last.x),
            (_delta.y = e.y - _last.y),
            (_last.x = e.x),
            (_last.y = e.y),
            _velocity.copy(_delta).multiplyScalar(0.03));
      }),
      this.get("step", (_) => _touchStep),
      this.get("pos", (_) => _touch);
  }),
  Class(function NeutrinoAttributes(_antimatter, _segments, _particleCount) {
    function initParticles() {
      let data = { vertices: new Float32Array(3 * _particleCount) };
      (_engine = _this.initClass(
        ParticleEngine,
        data,
        null,
        ParticleEngineCPU,
        { threads: 1 },
        null
      )),
        (_system = _engine.system).importClass(
          NeutrinoThread,
          Emitter,
          NeutrinoLifeBehavior
        ),
        (_thread = _system.initialize("NeutrinoThread")),
        _system.getChunks((chunk) => {
          (_thread.chunk = chunk), chunk.handleBufferData(bufferDownload);
        }),
        _thread.exec("init", { segments: _segments }),
        _system.update();
    }
    function initAttributeTextures() {
      (_attributes = {}).active = new AntimatterAttribute(
        _antimatter.createFloatArray(4),
        4
      );
      let attribs = _antimatter.createFloatArray(4);
      var count = attribs.length / 4;
      for (let i = 0; i < count; i++)
        (attribs[4 * i + 0] = Math.random(0, 1, 5)),
          (attribs[4 * i + 1] = Math.random(0, 1, 5)),
          (attribs[4 * i + 2] = Math.random(0, 1, 5)),
          (attribs[4 * i + 3] = Math.random(0, 1, 5));
      _attributes.attribs = new AntimatterAttribute(attribs, 4);
      let indices = _antimatter.createFloatArray(3);
      count = indices.length / 3;
      for (let i = 0; i < count; i++)
        (indices[3 * i + 0] = i % _segments),
          (indices[3 * i + 1] = Math.floor(i / _segments)),
          (indices[3 * i + 2] = i % 10);
      (_attributes.indices = new AntimatterAttribute(indices, 3)),
        (_this.store = _attributes);
    }
    function bufferDownload(key, value) {
      if ("active" == key) {
        let active = _attributes.active.buffer,
          count = value.length / 3;
        for (let i = 0; i < count; i++) {
          let texIndex = i * _segments,
            x = value[4 * i + 0],
            y = value[4 * i + 1],
            z = value[4 * i + 2],
            a = value[4 * i + 3];
          ((a > 0.7 && a < 0.8) || (a > 0.05 && a < 0.15)) &&
            ((active[4 * texIndex + 0] = x), (active[4 * texIndex + 1] = y)),
            a > 0.01 && (active[4 * texIndex + 2] = z),
            (active[4 * texIndex + 3] = a);
        }
        _attributes.active.needsUpdate = !0;
      } else if ("recycled" == key) {
        let buffer = _emissionBuffers[value.length / 3];
        buffer && buffer.put(value);
      }
    }
    Inherit(this, Component);
    const _this = this;
    var _attributes,
      _engine,
      _system,
      _thread,
      _message = { transfer: !0, msg: { buffers: [] } },
      _emissionBuffers = {};
    initParticles(),
      initAttributeTextures(),
      (this.update = function () {
        _system.update();
      }),
      (this.uploadDecaySpeed = function (speed) {
        _thread.exec("decaySpeed", { speed: speed });
      }),
      (this.emit = function (buffer) {
        (_message.msg.buffers.length = 0),
          (_message.msg.buffer = buffer),
          _message.msg.buffers.push(buffer.buffer),
          _thread.chunk.transferData(_message);
      }),
      (this.getEmissionBuffer = function (count) {
        if (!_emissionBuffers[count]) {
          let pool = new ObjectPool();
          for (let i = 0; i < 5; i++) pool.insert(new Float32Array(3 * count));
          _emissionBuffers[count] = pool;
        }
        return _emissionBuffers[count].get() || new Float32Array(3 * count);
      }),
      (this.release = function (position) {
        _thread.exec("release", { position: position });
      });
  }),
  Class(function ParticleEngine(_data, _shader, _system, _config) {
    function initSubSystem() {
      (_system = _this.initClass(
        ParticleEngineCPU,
        _data,
        _shader || "ParticleEngineDefault",
        _config || {}
      )),
        _this.group.add(_system.group),
        (_this.system = _system);
    }
    function loop() {
      _system && _system.update();
    }
    Inherit(this, Component);
    var _system,
      _shader,
      _this = this;
    (this.group = new Group()),
      (this.initialized = !1),
      initSubSystem(),
      (this.onDestroy = function () {
        Render.stop(loop);
      }),
      (this.stopRender = function () {
        Render.stop(loop);
      }),
      (this.startRender = function () {
        Render.start(loop);
      }),
      (this.ready = function () {
        return _system.ready();
      }),
      (this.update = function () {
        loop();
      }),
      (this.__ready = function () {
        _this.events.fire(Events.READY, null, !0), (_this.initialized = !0);
      });
  }),
  Class(function ParticleEngineCPU(_data, _vs, _config) {
    function initChunks() {
      for (var num = _config.threads || 1, i = 0; i < num; i++) {
        var chunk = _this.initClass(
          ParticleEngineCPUChunk,
          _data,
          i,
          _shader,
          _config
        );
        _chunks.push(chunk);
      }
    }
    function callChunks(fn, a, b) {
      for (var i = _chunks.length - 1; i > -1; i--) _chunks[i][fn](a, b);
    }
    Inherit(this, Component);
    var _shader,
      _execPool,
      _this = this,
      _exec = [],
      _chunks = [],
      _uniforms = [],
      _behaviors = [];
    (this.group = new Group()),
      (this.id = Utils.timestamp()),
      initChunks(),
      (this.update = function () {
        _uniforms.length = 0;
        for (var i = 0; i < _behaviors.length; i++) {
          var behavior = _behaviors[i];
          (behavior.uniformUpload.name = behavior.name),
            (behavior.uniformUpload.uniforms = behavior.uniforms),
            _uniforms.push(behavior.uniformUpload);
        }
        for (
          callChunks("update", _uniforms, _exec), i = 0;
          i < _exec.length;
          i++
        )
          _execPool.put(_exec[i]);
        _exec.length = 0;
      }),
      (this.addBehavior = function (behavior) {
        behavior.onReady && behavior.onReady(), (behavior.system = this);
        var name = Utils.getConstructorName(behavior);
        callChunks("addBehavior", "ParticleBehaviors." + name),
          (behavior.name = "ParticleBehaviors." + name),
          _behaviors.push(behavior);
      }),
      (this.removeBehavior = function (behavior) {
        (behavior.system = null),
          callChunks(
            "removeBehavior",
            "ParticleBehaviors." + Utils.getConstructorName(behavior)
          ),
          _behaviors.remove(behavior);
      }),
      (this.exec = function (name, fn, data, index) {
        "number" == typeof index && _chunks[index].exec(name, fn, data),
          _execPool || (_execPool = new ObjectPool(Object, 20));
        let obj = _execPool.get();
        (obj.name = name), (obj.cb = fn), (obj.data = data), _exec.push(obj);
      }),
      (this.importClass = function () {
        for (var i = _chunks.length - 1; i > -1; i--)
          _chunks[i].importClass.apply(_this, arguments);
      }),
      (this.importScript = function (path) {
        callChunks("importScript", path);
      }),
      (this.initialize = function () {
        for (var i = _chunks.length - 1; i > -1; i--)
          _chunks[i].initialize.apply(_this, arguments);
        return new (function SystemInterface(_name) {
          this.exec = function (fn, params = {}) {
            _this.exec(_name, fn, params);
          };
        })(arguments[0]);
      }),
      (this.getChunks = function (callback) {
        if (!callback) return _chunks;
        for (var i = 0; i < _chunks.length; i++) callback(_chunks[i], i);
      }),
      (this.ready = function () {
        return Promise.resolve();
      });
  }),
  Class(function ParticleConverter(_particles) {
    function createPool(attr, size) {
      (attr.pool = new ObjectPool()),
        (attr.pool.size = size || _particles.length * attr.size);
      for (var i = 0; i < 5; i++)
        attr.pool.put(new Float32Array(attr.pool.size));
    }
    function findAttribute(name) {
      for (var i = 0; i < _attributes.length; i++) {
        var attr = _attributes[i];
        if (attr.name == name) return attr;
      }
    }
    Inherit(this, Component);
    var _customExec,
      _attributes = [],
      _output = {};
    (this.addAttribute = this.add =
      function (name, params) {
        var attr = { name: name, size: params.length, params: params };
        return _attributes.push(attr), attr;
      }),
      (this.exec = function () {
        if (_customExec) return _customExec(_attributes, _output);
        for (var i = 0; i < _attributes.length; i++) {
          var attr = _attributes[i];
          if (attr.disabled) delete _output[attr.name];
          else {
            attr.pool || createPool(attr);
            for (
              var array =
                  attr.pool.get() ||
                  new Float32Array(_particles.length * attr.size),
                p = _particles.start(),
                index = 0;
              p;

            ) {
              for (var j = 0; j < attr.size; j++)
                array[index * attr.size + j] =
                  p[attr.params[j]] || p.pos[attr.params[j]] || 0;
              index++, (p = _particles.next());
            }
            _output[attr.name] = array;
          }
        }
        return _output;
      }),
      (this.customExec = function (callback) {
        _customExec = callback;
      }),
      (this.recycle = function (e) {
        var attr = findAttribute(e.name);
        attr.pool && attr.pool.length() < 20 && attr.pool.put(e.array);
      }),
      (this.clear = function () {
        _attributes.forEach(function (attr) {
          attr.pool = attr.pool.destroy();
        });
      }),
      (this.createPool = function (attr, size) {
        createPool(attr, size);
      }),
      (this.findAttribute = findAttribute);
  }),
  Class(function ParticleEngineCPUChunk(_data, _index, _shader, _config) {
    function initChunk() {
      for (
        var vertices = [],
          count = _data.vertices.length / 3,
          skip = _config.threads || 1,
          index = 0,
          i = _index;
        i < count;
        i += skip
      )
        (vertices[3 * index + 0] = _data.vertices[3 * i + 0]),
          (vertices[3 * index + 1] = _data.vertices[3 * i + 1]),
          (vertices[3 * index + 2] = _data.vertices[3 * i + 2]),
          index++;
      _this.init(new Float32Array(vertices), _config);
    }
    Inherit(this, ParticleEngineCPUChunkBase);
    var _this = this;
    initChunk();
  }),
  Class(function ParticleEngineCPUChunkBase() {
    function initThread(config) {
      (_thread = _this.initClass(Thread, ParticleEngineCPUThread)),
        Utils3D.loadEngineOnThread(_thread),
        _thread.importClass(
          ParticlePhysics,
          LinkedList,
          Particle,
          ObjectPool,
          ParticleConverter
        ),
        (_thread.debug = !0),
        (_this.thread = _thread);
      var clone = new Float32Array(_vertices.length);
      clone.set(_vertices),
        _thread.init({
          transfer: !0,
          msg: { vertices: clone, buffer: [clone.buffer] },
        }),
        _thread.on("transfer", transfer),
        (_this.importClass = _thread.importClass);
    }
    function recycle(buffer, key) {
      _config.preventRecycle ||
        (_recycle || (_recycle = { transfer: !0, msg: { buffers: [] } }),
        (_recycle.msg.name = key),
        (_recycle.msg.array = buffer),
        (_recycle.msg.buffers.length = 0),
        _recycle.msg.buffers.push(buffer.buffer),
        _thread.recycleBuffer(_recycle));
    }
    function transfer(e) {
      for (var key in e) {
        var buffer = e[key];
        _bufferCallback &&
          (_bufferCallback(key, buffer),
          "recycled" != key && recycle(buffer, key));
      }
    }
    Inherit(this, Component);
    var _vertices,
      _thread,
      _recycle,
      _bufferCallback,
      _config,
      _this = this,
      _msg = {},
      _exec = {};
    (this.init = function (vertices, config) {
      (_this = this), (_vertices = vertices), (_config = config), initThread();
    }),
      (this.update = function (uniforms, exec) {
        (_msg.data = uniforms),
          (_msg.exec = exec),
          (_msg._id = _this.parent.id),
          _thread.send("update", _msg);
      }),
      (this.addBehavior = function (name) {
        _thread.addBehavior({ name: name });
      }),
      (this.removeBehavior = function (name) {
        _thread.removeBehavior({ name: name });
      }),
      (this.exec = function (name, fn, data) {
        (_exec.name = name),
          (_exec.cb = fn),
          (_exec.data = data),
          (_exec._id = _this.parent.id),
          _thread.send("exec", _exec);
      }),
      (this.transferData = function (data, buffer) {
        buffer
          ? _thread.transferData({ transfer: { buffer: buffer }, msg: data })
          : _thread.transferData(data);
      }),
      (this.initialize = function () {
        for (var i = 0; i < arguments.length; i++)
          _thread.initialize({ name: arguments[i], _id: _this.parent.id });
      }),
      (this.importScript = function (path) {
        _thread.importScript(path);
      }),
      (this.handleBufferData = function (callback) {
        _bufferCallback = callback;
      });
  }),
  Class(function ParticleEngineCPUThread() {
    function initSystem(vertices) {
      (_system = new ParticlePhysics()), (Global.SYSTEM = _system);
      for (var count = vertices.length / 3, i = 0; i < count; i++) {
        var p = new Particle(new Vector3());
        (p.pos.x = vertices[3 * i + 0]),
          (p.pos.y = vertices[3 * i + 1]),
          (p.pos.z = vertices[3 * i + 2]),
          _system.addParticle(p);
      }
    }
    function initConverter() {
      (_converter = _this.initClass(
        ParticleConverter,
        _system.particles
      )).addAttribute("position", ["x", "y", "z"]),
        (_this.recycleBuffer = _converter.recycle),
        (Global.CONVERTER = _converter);
    }
    function loop() {
      if (
        (_system.update(),
        _system.onUpdate && _system.onUpdate(),
        !Global.CUSTOM_CONVERTER)
      ) {
        var outgoing = _converter.exec();
        _buffers.length = 0;
        for (var key in outgoing) _buffers.push(outgoing[key].buffer);
        emit("transfer", outgoing, _buffers);
      }
    }
    function updateUniforms(e) {
      for (var uniforms = e.data, i = 0; i < uniforms.length; i++) {
        var uni = uniforms[i],
          behavior = _behaviors[uni.name];
        for (var key in uni.uniforms)
          behavior.writeUniform(key, uni.uniforms[key]);
      }
    }
    function handleExec(array, id) {
      for (let i = 0; i < array.length; i++) {
        let e = array[i],
          clss = Global[e.name + "_" + id];
        clss && clss[e.cb](e.data);
      }
    }
    Inherit(this, Component);
    var _system,
      _converter,
      _this = this,
      _behaviors = {},
      _buffers = [];
    (this.init = function (e) {
      initSystem(e.vertices), initConverter();
    }),
      (this.update = function (e) {
        updateUniforms(e), handleExec(e.exec, e._id), loop();
      }),
      (this.addBehavior = function (e) {
        var name = e.name,
          namespace = window,
          behavior = null;
        if (name.includes(".")) {
          var split = name.split(".");
          (name = split[1]),
            (namespace = split[0]),
            (behavior = new window[namespace][name]());
        } else behavior = new window[name]();
        (_behaviors[e.name] = behavior),
          _system.addBehavior(behavior),
          behavior.onReady && behavior.onReady();
      }),
      (this.removeBehavior = function (e) {
        var behavior = _behaviors[e.name];
        _system.removeBehavior(behavior), delete _behaviors[e.mame];
      }),
      (this.initialize = function (e) {
        Global[e.name + "_" + e._id] = new window[e.name]();
      }),
      (this.exec = function (e) {
        Global[e.name + "_" + e._id][e.cb](e.data);
      }),
      (this.transferData = function (e) {
        _system.onDataTransfer && _system.onDataTransfer(e);
      }),
      (Global.emit = loop);
  }),
  Class(function Particle(_pos, _mass, _radius) {
    function initVectors() {
      var Vector = "number" == typeof _pos.z ? Vector3 : Vector2;
      (_vel = new Vector()),
        (_acc = new Vector()),
        ((_old = {}).pos = new Vector()),
        (_old.acc = new Vector()),
        (_old.vel = new Vector()),
        _old.pos.copy(_pos),
        (_this.pos = _this.position = _pos),
        (_this.vel = _this.velocity = _vel),
        (_this.acc = _this.acceleration = _acc),
        (_this.old = _old);
    }
    var _vel,
      _acc,
      _old,
      _this = this,
      prototype = Particle.prototype;
    (this.mass = _mass || 1),
      (this.massInv = 1 / this.mass),
      (this.enabled = !0),
      (this.radius = _radius || 1),
      (this.radiusSq = this.radius * this.radius),
      (this.behaviors = new LinkedList()),
      (this.fixed = !1),
      initVectors(),
      (this.moveTo = function (pos) {
        _pos.copy(pos),
          _old.pos.copy(_pos),
          _acc.set(0, 0, 0),
          _vel.set(0, 0, 0);
      }),
      void 0 === prototype.setMass &&
        ((prototype.setMass = function (mass) {
          (this.mass = mass || 1), (this.massInv = 1 / this.mass);
        }),
        (prototype.setRadius = function (radius) {
          (this.radius = radius), (this.radiusSq = radius * radius);
        }),
        (prototype.update = function (dt) {
          if (this.behaviors.length)
            for (var b = this.behaviors.start(); b; )
              b.applyBehavior(this, dt), (b = this.behaviors.next());
        }),
        (prototype.applyForce = function (force) {
          this.acc.add(force);
        }),
        (prototype.addBehavior = function (behavior) {
          if (!behavior || void 0 === behavior.applyBehavior)
            throw "Behavior must have applyBehavior method";
          this.behaviors.push(behavior);
        }),
        (prototype.removeBehavior = function (behavior) {
          if (!behavior || void 0 === behavior.applyBehavior)
            throw "Behavior must have applyBehavior method";
          this.behaviors.remove(behavior);
        }),
        (prototype.addParticle = function (p) {
          this.children ||
            ((this.children = []), (this.childList = new LinkedList())),
            this.children.push(p),
            this.childList.push(p);
        }));
  }),
  Class(function ParticlePhysics() {
    function init(p) {
      for (var i = _this.initializers.start(); i; )
        i(p), (i = _this.initializers.next());
    }
    function updateSprings(dt) {
      for (var s = _this.springs.start(); s; )
        s.update(dt), (s = _this.springs.next());
    }
    function deleteParticles() {
      for (var i = _toDelete.length - 1; i > -1; i--) {
        var particle = _toDelete[i];
        _this.particles.remove(particle), (particle.system = null);
      }
      _toDelete.length = 0;
    }
    function updateParticles(dt, list = _this.particles) {
      for (var index = 0, p = list.start(); p; ) {
        if (p.enabled) {
          for (var b = _this.behaviors.start(); b; )
            b.applyBehavior(p, dt, index), (b = _this.behaviors.next());
          p.behaviors.length && p.update(dt, index),
            p.childList && updateParticles(dt, p.childList);
        }
        index++, (p = list.next());
      }
    }
    function integrate(dt) {
      updateParticles(dt), _this.springs.length && updateSprings(dt);
    }
    Inherit(this, Component);
    var _this = this,
      _time = 0,
      _step = 0,
      _clock = null,
      _buffer = 0,
      _toDelete = [];
    (this.friction = 1),
      (this.maxSteps = 1),
      (this.emitters = new LinkedList()),
      (this.initializers = new LinkedList()),
      (this.behaviors = new LinkedList()),
      (this.particles = new LinkedList()),
      (this.springs = new LinkedList()),
      (this.addEmitter = function (emitter) {
        if (!emitter.emit) throw "Emitter must be Emitter";
        this.emitters.push(emitter), (emitter.parent = emitter.system = this);
      }),
      (this.removeEmitter = function (emitter) {
        if (!emitter.emit) throw "Emitter must be Emitter";
        this.emitters.remove(emitter), (emitter.parent = emitter.system = null);
      }),
      (this.addInitializer = function (init) {
        if ("function" != typeof init) throw "Initializer must be a function";
        this.initializers.push(init);
      }),
      (this.removeInitializer = function (init) {
        this.initializers.remove(init);
      }),
      (this.addBehavior = function (b) {
        this.behaviors.push(b), (b.system = this);
      }),
      (this.removeBehavior = function (b) {
        this.behaviors.remove(b);
      }),
      (this.addParticle = function (p) {
        (p.system = this),
          this.particles.push(p),
          this.initializers.length && init(p);
      }),
      (this.removeParticle = function (p) {
        (p.system = null), _toDelete.push(p);
      }),
      (this.addSpring = function (s) {
        (s.system = this), this.springs.push(s);
      }),
      (this.removeSpring = function (s) {
        (s.system = null), this.springs.remove(s);
      }),
      (this.update = function (force) {
        _clock || (_clock = THREAD ? Date.now() : Render.TIME);
        var time = THREAD ? Date.now() : Render.TIME,
          delta = time - _clock;
        if (force || !(delta <= 0)) {
          if (((delta *= 0.001), (_clock = time), (_buffer += delta), force))
            integrate(0.016);
          else
            for (var i = 0; _buffer >= 1 / 60 && i++ < _this.maxSteps; )
              integrate(1 / 60), (_buffer -= 1 / 60), (_time += 1 / 60);
          (_step = Date.now() - time), _toDelete.length && deleteParticles();
        }
      });
  }),
  Class(function Emitter(_position, _startNumber) {
    function initObjectPool() {
      (_pool = _this.initClass(ObjectPool)), (_this.pool = _pool);
    }
    function addParticles(total) {
      _total += total;
      for (var particles = [], i = 0; i < total; i++)
        particles.push(new Particle());
      _pool.insert(particles);
    }
    Inherit(this, Component);
    var _pool,
      _this = this,
      _total = 0;
    _position.type;
    (this.initializers = []),
      (this.position = _position),
      (this.autoEmit = 1),
      (this.persist = !0),
      initObjectPool(),
      0 != _startNumber && addParticles(_startNumber || 100),
      (this.addInitializer = function (callback) {
        if ("function" != typeof callback)
          throw "Initializer must be a function";
        this.initializers.push(callback);
      }),
      (this.removeInitializer = function (callback) {
        var index = this.initializers.indexOf(callback);
        index > -1 && this.initializers.splice(index, 1);
      }),
      (this.emit = function (num) {
        if (!this.parent) throw "Emitter needs to be added to a System";
        num = num || this.autoEmit;
        for (var i = 0; i < num; i++) {
          var p = _pool.get();
          if (!p) return;
          p.moveTo(this.position),
            (p.emitter = this),
            (p.enabled = !0),
            p.system || this.parent.addParticle(p);
          for (var j = 0; j < this.initializers.length; j++)
            this.initializers[j](p, i / num);
        }
      }),
      (this.remove = function (particle) {
        _pool.put(particle),
          _this.persist || _this.parent.removeParticle(particle),
          (particle.enabled = !1);
      }),
      (this.mix = function () {
        for (var i = 0; i < 6; i++) Utils.shuffleArray(_pool.array);
      }),
      (this.addToPool = function (particle) {
        _pool.put(particle),
          !_this.persist &&
            particle.system &&
            _this.parent.removeParticle(particle),
          (particle.enabled = !1);
      });
  }),
  Class(function NeutrinoLifeBehavior() {
    function init(p) {
      (p.ax = Math.random(0.5, 1.5, 3)),
        (p.ay = Math.random(0.5, 1.5, 3)),
        (p.az = Math.random(0.5, 1.5, 3));
    }
    Inherit(this, Component);
    const _this = this;
    (this.decay = 1),
      (this.applyBehavior = function (p) {
        p.ax || init(p),
          ++p.activeFrame,
          p.activeFrame > 2 &&
            ((p.activeValue = 1),
            (p.life -= 0.01 * _this.decay),
            (p.pos.z = p.life)),
          p.life <= 0 &&
            ((p.activeValue = 0.25),
            p.life < -0.1 &&
              ((p.pos.x = 99999),
              (p.activeValue = 0.1),
              p.life < -0.5 && _this.endParticle(p)));
      });
  }),
  Class(function NeutrinoThread() {
    function initParticles(segments) {
      (_system.skipIntegration = !0),
        (_emitter = _this.initClass(Emitter, new Vector3(), 0)).addInitializer(
          initializer
        ),
        ((_life = _this.initClass(NeutrinoLifeBehavior)).endParticle =
          endParticle),
        _system.addBehavior(_life),
        (_system.onDataTransfer = transferData);
      let p = _particles.start(),
        i = 0;
      for (; p; )
        (p.index = i * segments),
          (p.enabled = !1),
          _emitter.addToPool(p),
          i++,
          (p = _particles.next());
    }
    function initAttributes() {
      (_converter.findAttribute("position").disabled = !0),
        _converter.add("active", ["x", "y", "z", "activeValue"]);
    }
    function initializer(p) {
      (p.life = 1),
        (p.activeValue = 0.75),
        (p.activeFrame = 0),
        (p.enabled = !0);
    }
    function endParticle(p) {
      (p.pos.x = 99999),
        (p.activeValue = 0),
        (p.enabled = !1),
        _emitter.addToPool(p);
    }
    function transferData(e) {
      let buffer = e.buffer,
        count = buffer.length / 3;
      for (let i = 0; i < count; i++) {
        let x = buffer[3 * i + 0],
          y = buffer[3 * i + 1],
          z = buffer[3 * i + 2];
        _emitter.position.set(x, y, z), _emitter.emit(1);
      }
      emit("transfer", { recycled: buffer }, [buffer.buffer]);
    }
    Inherit(this, Component);
    const _this = this;
    var _emitter,
      _life,
      _converter = Global.CONVERTER,
      _system = Global.SYSTEM,
      _particles = _system.particles;
    (this.init = function (e) {
      initParticles(e.segments), initAttributes();
    }),
      (this.release = function (e) {
        _emitter.position.set(e.position.x, e.position.y, e.position.z),
          _emitter.emit(1);
      }),
      (this.decaySpeed = function (e) {
        _life.decay = e.speed;
      });
  }),
  Module(function NeutrinoMathUtil() {
    this.exports = function (geom) {
      function mergeVertices(geom) {
        var v,
          key,
          i,
          il,
          face,
          indices,
          j,
          jl,
          verticesMap = {},
          unique = [],
          changes = [],
          precision = Math.pow(10, 4);
        for (i = 0, il = geom.vertices.length; i < il; i++)
          (v = geom.vertices[i]),
            void 0 ===
            verticesMap[
              (key =
                Math.round(v.x * precision) +
                "_" +
                Math.round(v.y * precision) +
                "_" +
                Math.round(v.z * precision))
            ]
              ? ((verticesMap[key] = i),
                unique.push(geom.vertices[i]),
                (changes[i] = unique.length - 1))
              : (changes[i] = changes[verticesMap[key]]);
        var faceIndicesToRemove = [];
        for (i = 0, il = geom.faces.length; i < il; i++) {
          ((face = geom.faces[i]).a = changes[face.a]),
            (face.b = changes[face.b]),
            (face.c = changes[face.c]),
            (indices = [face.a, face.b, face.c]);
          for (var n = 0; n < 3; n++)
            if (indices[n] === indices[(n + 1) % 3]) {
              faceIndicesToRemove.push(i);
              break;
            }
        }
        for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
          var idx = faceIndicesToRemove[i];
          for (
            geom.faces.splice(idx, 1), j = 0, jl = geom.faceVertexUvs.length;
            j < jl;
            j++
          )
            geom.faceVertexUvs[j].splice(idx, 1);
        }
        var diff = geom.vertices.length - unique.length;
        return (geom.vertices = unique), diff;
      }
      !(function buildFaces(geom) {
        function Face3(a, b, c) {
          (this.a = a), (this.b = b), (this.c = c);
        }
        let attributes = geom.attributes,
          positions = attributes.position.array,
          normals = attributes.normal.array,
          uvs = attributes.uv.array,
          tempNormals = [],
          tempUVs = [];
        (geom.vertices = []), (geom.faceVertexUvs = [[]]), (geom.faces = []);
        let indices = geom.index;
        for (let i = 0, j = 0; i < positions.length; i += 3, j += 2)
          geom.vertices.push(
            new Vector3(positions[i], positions[i + 1], positions[i + 2])
          ),
            tempNormals.push(
              new Vector3(normals[i], normals[i + 1], normals[i + 2])
            ),
            tempUVs.push(new Vector2(uvs[j], uvs[j + 1]));
        for (var i = 0; i < indices.length; i += 3)
          !(function addFace(a, b, c, materialIndex) {
            let face = new Face3(a, b, c, [
              tempNormals[a].clone(),
              tempNormals[b].clone(),
              tempNormals[c].clone(),
            ]);
            geom.faces.push(face),
              geom.faceVertexUvs[0].push([
                tempUVs[a].clone(),
                tempUVs[b].clone(),
                tempUVs[c].clone(),
              ]);
          })(indices[i], indices[i + 1], indices[i + 2]);
        mergeVertices(geom);
      })(geom);
    };
  }),
  Class(function NeutrinoTubes(
    _dimension,
    _count,
    _segments,
    _sides,
    _fs,
    _shaderClass
  ) {
    function initGeometry() {
      let shape = generate(_sides, _segments - 1, !1),
        geom = new Geometry();
      geom.addAttribute(
        "cNumber",
        new GeometryAttribute(new Float32Array(_count), 1, 1)
      );
      for (let key in shape.attributes)
        geom.addAttribute(key, shape.attributes[key]);
      for (let i = 0; i < _count; i++) geom.attributes.cNumber.array[i] = i;
      _geom = geom;
    }
    function initShader() {
      let _vs = _fs;
      if (
        ((_shader = _this.initClass(
          _shaderClass || Shader,
          "NeutrinoTube",
          _fs || "NeutrinoTube",
          {
            noAttributes: !0,
            unique: _fs,
            thickness: { type: "f", value: 1, ignoreUIL: !0 },
            textureSize: { type: "f", value: _dimension, ignoreUIL: !0 },
            lineSegments: { type: "f", value: _segments, ignoreUIL: !0 },
            radialSegments: { type: "f", value: _sides, ignoreUIL: !0 },
            taper: { type: "f", value: 0.5, ignoreUIL: !0 },
            tPositions: { type: "t", value: null, ignoreUIL: !0 },
            tLife: { type: "t", value: null, ignoreUIL: !0 },
          }
        )),
        _vs)
      ) {
        let vs = Shaders.getShader(_vs + ".vs"),
          params = (vs = vs.split("void main() {"))[0].split("\n"),
          main = vs[1].split("}")[0],
          paramOutput = [];
        for (let line of params)
          _shader.vertexShader.includes(line) || paramOutput.push(line);
        (_shader.vertexShader = _shader.vertexShader.replace(
          "//neutrinoparams",
          paramOutput.join("\n")
        )),
          (_shader.vertexShader = _shader.vertexShader.replace(
            "//neutrinovs",
            main
          ));
      }
      _this.startRender(() => {
        _shader.set("tPositions", _this.parent.antimatter.getOutput().value),
          _shader.set("tLife", _this.parent.attributes.store.active.texture);
      }),
        (_this.shader = _shader);
    }
    function initMesh() {
      let mesh = new Mesh(_geom, _shader);
      (mesh.frustumCulled = !1), _this.add(mesh), (_this.mesh = mesh);
    }
    function generate(numSides = 8, subdivisions = 50, openEnded = !1) {
      let geom = new CylinderGeometry(
        1,
        1,
        1,
        numSides,
        subdivisions,
        openEnded
      );
      geom.applyMatrix(new Matrix4().makeRotationZ(Math.PI / 2)),
        require("NeutrinoMathUtil")(geom);
      let tmpVec = new Vector2(),
        xPositions = [],
        angles = [],
        uvs = [],
        vertices = geom.vertices,
        faceVertexUvs = geom.faceVertexUvs[0],
        indices = [];
      geom.faces.forEach((face, i) => {
        let { a: a, b: b, c: c } = face,
          verts = [vertices[a], vertices[b], vertices[c]],
          faceUvs = faceVertexUvs[i];
        verts.forEach((v, j) => {
          tmpVec.set(v.y, v.z).normalize();
          let angle = Math.atan2(tmpVec.y, tmpVec.x);
          angles.push(angle),
            xPositions.push(v.x),
            uvs.push(faceUvs[j].toArray()),
            indices.push(
              Math.abs(
                Math.round(Math.range(v.x, -0.5, 0.5, 0, subdivisions - 1))
              )
            );
        });
      });
      let posArray = new Float32Array(xPositions),
        angleArray = new Float32Array(angles),
        uvArray = new Float32Array(2 * uvs.length);
      for (let i = 0; i < posArray.length; i++) {
        let [u, v] = uvs[i];
        (uvArray[2 * i + 0] = u), (uvArray[2 * i + 1] = v);
      }
      let geometry = new Geometry();
      return (
        geometry.addAttribute(
          "position",
          new GeometryAttribute(new Float32Array(3 * posArray.length), 3)
        ),
        geometry.addAttribute("angle", new GeometryAttribute(angleArray, 1)),
        geometry.addAttribute(
          "cIndex",
          new GeometryAttribute(new Float32Array(indices), 1)
        ),
        geometry.addAttribute("tuv", new GeometryAttribute(uvArray, 2)),
        (geometry.indexLookup = indices),
        geom.destroy(),
        geometry
      );
    }
    Inherit(this, Object3D);
    const _this = this;
    var _geom, _shader;
    initGeometry(),
      initShader(),
      initMesh(),
      this.set("thickness", (v) => {
        _shader.set("thickness", v);
      }),
      this.set("taper", (v) => {
        _shader.set("taper", v);
      }),
      this.get("geometry", (_) => _geom),
      this.get("shader", (_) => _shader),
      (this.ready = function () {
        return _this.wait(_this, "mesh");
      }),
      (this.createFloatArray = function (components) {
        return new Float32Array(_count * components);
      }),
      (this.addUniforms = function (object) {
        for (let key in object) {
          let uniform = object[key],
            lookup = UILStorage.parse(_this.UILPrefix + key);
          lookup && (uniform.value = lookup.value),
            (_shader.uniforms[key] = uniform);
        }
      });
  }),
  Class(function Performance() {
    function save(key, value) {
      (_overrides[key] = value),
        Storage.set("performance_override", _overrides);
    }
    function convert(tier) {
      if (GPU.BLACKLIST) return "F";
      switch (tier) {
        case 4:
          return "A+";
        case 3:
          return "A";
        case 2:
          return "B";
        case 1:
          return "C";
        case 0:
          return "D";
      }
    }
    Inherit(this, Component);
    var _overrides = Storage.get("performance_override") || {};
    !(async function () {
      if (
        (Utils.query("performance") && Utils.query("editing")) ||
        Utils.query("custom")
      ) {
        await defer();
        for (let key in _overrides) Tests[key] = (_) => _overrides[key];
      }
    })(),
      (this.displayResults = async function () {
        let editing = Utils.query("edit");
        await GPU.ready(), __body.bg("#000");
        let $results = __body.create("PerformanceResults");
        __body.css({ overflowY: "scroll" }),
          $results
            .fontStyle("Arial", 18, "#fff")
            .css({ marginLeft: 50, marginRight: 50, "user-select": "auto" }),
          Mobile.allowNativeScroll(),
          CSS.style(".PerformanceResults *", {
            position: "relative",
            "user-select": "auto",
          });
        Tests.constructor.toString();
        let tests = "";
        for (let key in Tests) {
          let result = Tests[key]();
          (tests += `<p><b>${key}:</b> `),
            editing
              ? ("number" == typeof result &&
                  (tests += `<input class="${key}" value="${result.toString()}" /></p>`),
                "boolean" == typeof result &&
                  (tests += `<input class="${key}" type="checkbox" ${
                    result ? "checked" : ""
                  }/></p>`))
              : (tests += result + "</p>");
        }
        let html = `<h1>Performance Results</h1>\n                    <p><b>GPU:</b> ${
          Device.graphics.webgl
            ? Device.graphics.webgl.gpu
            : "WEBGL UNAVAILABLE"
        }</p>\n                    <p><b>WebGL Version:</b> ${
          Device.graphics.webgl
            ? Device.graphics.webgl.version
            : "WEBGL UNAVAILABLE"
        }</p>\n                    <p><b>GPU Tier:</b> ${convert(
          Device.mobile ? GPU.M_TIER : GPU.TIER
        )}</p>\n                    <p><b>Mobile:</b> ${
          Device.mobile
        }</p>\n                    <p><b>User Agent:</b> ${
          Device.agent
        }</p>\n                    \n                    <h2>Project-Specific Tests</h2>\n                    ${
          editing ? '<button class="resetBtn">Reset All</button>' : ""
        }\n                    ${tests}\n        `;
        if (($results.html(html), editing)) {
          await defer(),
            (document.querySelector(".resetBtn").onclick = (_) => {
              Storage.set("performance_override", null), location.reload();
            });
          for (let key in Tests)
            !(function (div, key) {
              div.onchange = (_) => {
                let value = div.value;
                (value = isNaN(value) ? div.checked : Number(value)),
                  save(key, value);
              };
            })(document.querySelector(`.${key}`), key);
        }
      });
  }, "static"),
  Class(function RenderManager() {
    function resizeHandler() {
      _this.renderer && _this.renderer.setSize(Stage.width, Stage.height);
    }
    Inherit(this, Component);
    const _this = this;
    var _dpr = null;
    (this.NORMAL = "normal"),
      (this.MAGIC_WINDOW = "magic_window"),
      (this.VR = this.WEBVR = "webvr"),
      (this.AR = this.WEBAR = "webar"),
      (this.RENDER = "RenderManager_render"),
      (this.PRE_RENDER = "RenderManager_pre_render"),
      (this.POST_RENDER = "RenderManager_post_render"),
      (this.BEFORE_RENDER = "RenderManager_before_render"),
      (this.READY = "render_gl_ready"),
      _this.events.sub(Events.RESIZE, resizeHandler),
      this.set("DPR", (v) => {
        (_dpr = v),
          _this.renderer && _this.renderer.setSize(Stage.width, Stage.height);
      }),
      this.get("DPR", (v) => _dpr),
      (this.initialize = async function (type, params = {}) {
        if (
          (_this.camera && _this.camera.destroy(),
          _this.renderer && _this.renderer.destroy(),
          type == _this.WEBVR)
        )
          try {
            let canvas = document.createElement("canvas"),
              context = canvas.getContext("xrpresent"),
              session = await XRDeviceManager.getVRSession(context);
            (params.compatibleXRDevice = session.device),
              (canvas.width = Stage.width),
              (canvas.height = Stage.height),
              Stage.add(canvas);
          } catch (e) {
            throw e;
          }
        if (type == _this.WEBAR)
          try {
            let canvas = document.createElement("canvas"),
              context = canvas.getContext("xrpresent"),
              session = await XRDeviceManager.getARSession(context);
            (canvas.width = Stage.width),
              (canvas.height = Stage.height),
              Stage.add(canvas),
              (params.compatibleXRDevice = session.device);
          } catch (e) {
            throw e;
          }
        if (!_this.gl) {
          let camera = new PerspectiveCamera(
            45,
            Stage.width / Stage.height,
            0.01,
            200
          );
          (_this.gl = (function () {
            if (!Device.graphics.webgl)
              return {
                render: (_) => {},
                setPixelRatio: (_) => {},
                setSize: (_) => {},
                readRenderTargetPixels: (_) => {},
              };
            let renderer = new Renderer(params);
            return (
              renderer.setSize(Stage.width, Stage.height),
              renderer.setPixelRatio(
                window.AURA
                  ? Device.pixelRatio
                  : Math.max(1.25, Math.max(World.DPR, Device.pixelRatio))
              ),
              renderer
            );
          })()),
            (_this.scene = new Scene()),
            (_this.nuke = _this.initClass(
              Nuke,
              Stage,
              Object.assign(
                {
                  renderer: _this.gl,
                  scene: _this.scene,
                  camera: camera,
                  dpr: World.DPR,
                },
                params
              )
            ));
        }
        switch (((_dpr = _dpr || World.DPR || 1), type)) {
          case _this.WEBVR:
            (_this.renderer = _this.initClass(
              VRRenderer,
              _this.gl,
              _this.nuke
            )),
              (_this.camera = _this.initClass(VRCamera));
            break;
          case _this.WEBAR:
            (_this.renderer = _this.initClass(
              ARRenderer,
              _this.gl,
              _this.nuke
            )),
              (_this.camera = _this.initClass(ARCamera));
            break;
          case _this.MAGIC_WINDOW:
            (_this.renderer = _this.initClass(
              MagicWindowRenderer,
              _this.gl,
              _this.nuke
            )),
              (_this.camera = _this.initClass(VRCamera));
            break;
          case _this.NORMAL:
            (_this.renderer = _this.initClass(
              RenderManagerRenderer,
              _this.gl,
              _this.nuke
            )),
              (_this.camera = _this.initClass(RenderManagerCamera));
        }
        (_this.type = type), (_this.nuke.camera = _this.camera.worldCamera);
      }),
      (this.render = function (scene, camera, renderTarget, forceClear) {
        _this.renderer.render(
          scene || _this.scene,
          camera || _this.camera.worldCamera,
          renderTarget,
          forceClear
        ),
          _this.events.fire(_this.POST_RENDER);
      }),
      (this.startRender = function () {
        Render.start(_this.render);
      }),
      (this.stopRender = function () {
        Render.stop(_this.render);
      }),
      (this.requestPresent = function (bool) {
        _this.renderer.requestPresent && _this.renderer.requestPresent(bool);
      }),
      (this.setSize = function (width, height) {
        _this.events.unsub(Events.RESIZE, resizeHandler),
          _this.renderer.setSize(width, height);
      }),
      this.set("onRenderEye", (callback) => {
        _this.renderer.onRenderEye = callback;
      });
  }, "static"),
  Class(function RenderManagerCamera() {
    Inherit(this, Component);
    const _this = this;
    (this.worldCamera = window.THREE
      ? new THREE.PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1e3)
      : new PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1e3)),
      _this.events.sub(Events.RESIZE, () => {
        (_this.worldCamera.aspect = Stage.width / Stage.height),
          _this.worldCamera.updateProjectionMatrix();
      });
  }),
  Class(function RenderManagerRenderer(_renderer, _nuke) {
    Inherit(this, Component);
    const _this = this;
    var _evt = {};
    (_nuke.onBeforeProcess = (_) => {
      (_evt.stage = Stage),
        (_evt.camera = _nuke.camera),
        _this.events.fire(RenderManager.RENDER, _evt);
    }),
      (this.render = function (scene, camera) {
        (_nuke.camera = camera),
          _nuke ? _nuke.render() : _renderer.render(scene, camera);
      }),
      (this.setSize = function (width, height) {
        _renderer.setSize(width, height);
      });
  }),
  Class(
    function SceneLayout(_name, _options = {}) {
      function initialize(promise) {
        let initializer = _this.initializer || SceneLayout.initializer;
        return initializer && initializer(promise), promise;
      }
      function createFolder(name) {
        let folder = new UILFolder(`sl_${_name}_${name}`, {
          label: name,
          closed: !0,
        });
        return (
          folder.hide(), (_folders[`sl_${_name}_${name}`] = folder), folder
        );
      }
      async function initConfig() {
        let input = InputUIL.create(`CONFIG_sl_${_name}`, _uil);
        input.add("Animation"),
          input.addNumber("AnimationScale", 1),
          input.add("Layout"),
          input.addNumber("LayoutScale", 1),
          _graph && _graph.addSpecial("Config", `Config (${_name})`, "Config"),
          input.setLabel("Config");
        let animation = input.get("Animation"),
          layout = input.get("Layout");
        if (animation) {
          if (
            (await ready(),
            (_this.animation = _this.initClass(
              HierarchyAnimation,
              animation,
              linkObjects
            )),
            (_this.animation.scale = input.getNumber("AnimationScale")),
            _timeline)
          )
            _this.startRender((_) => {
              (_this.animation.elapsed = _timeline.elapsed),
                _this.animation.update();
            });
          else if (_uil) {
            let range = new UILControlRange("Animation", {
              min: 0,
              max: 1,
              step: 0.001,
            });
            range.onChange((val) => {
              (_this.animation.elapsed = val), _this.animation.update();
            }),
              _uil.add(range);
          }
          (_this.animation.group.prefix = `ANIMATION_sl_${_name}`),
            MeshUIL.add(_this.animation.group, _uil).setLabel(
              "Animation Group"
            ),
            await _this.animation.ready(),
            _this.animation.update();
        } else
          layout &&
            (await ready(),
            (_this.layout = _this.initClass(
              HierarchyLayout,
              layout,
              linkObjects
            )),
            (_this.layout.scale = input.getNumber("LayoutScale")),
            await _this.layout.ready(),
            (_this.layout.group.prefix = `LAYOUT_sl_${_name}`),
            MeshUIL.add(_this.layout.group, _uil).setLabel("Layout Group"));
        await defer(), (_this.configured = !0);
      }
      async function linkObjects(data) {
        let array = [];
        for (let i = 0; i < data.length; i++) {
          let name = data[i].name,
            exists = _this.exists(name);
          exists ||
            "null" == name.toLowerCase() ||
            console.warn(`linkAnimation :: ${name} does not exist`);
          let group = new Group(),
            mesh = exists ? await _this.getLayer(name) : null;
          exists && (group = mesh.group || mesh),
            (group.name = name),
            array.push(group);
        }
        return array;
      }
      async function initGraph() {
        _options.noGraph ||
          ((_graph = UILGraph.instance().getGraph(_name, _this)) &&
            (UIL.sidebar.element.show(),
            await _this.ready(),
            _graph.syncVisibility(_layers),
            Global.PLAYGROUND &&
              Utils.getConstructorName(_this.parent) == Global.PLAYGROUND &&
              _graph.open()));
      }
      function initParams() {
        if (
          (_options.rootPath
            ? "/" != _options.rootPath.charAt(_options.rootPath.length - 1) &&
              (_options.rootPath += "/")
            : (_options.rootPath = ""),
          (_this.timeline = _timeline = _options.timeline),
          _timeline && (_timeline.add({ v: 0 }, { v: 1 }, 100, "linear"), _uil))
        ) {
          let range = new UILControlRange("Timeline", {
            min: 0,
            max: 1,
            step: 0.001,
          });
          range.onChange((val) => {
            (_timeline.elapsed = val), _timeline.update();
          }),
            _uil.add(range),
            range.hide(),
            _graph && _graph.addSpecial("Timeline", "Timeline");
        }
        (_this.baseRenderOrder = _options.baseRenderOrder || 0),
          (_this.data = _options.data),
          (_breakpoint = _options.breakpoint || SceneLayout.breakpoint),
          _options.breakpoint && (_this.localBreakpoint = !0),
          _options.uil && (_uil = _options.uil);
      }
      async function initData() {
        if (
          (await UILStorage.ready(),
          (_dataStore = InputUIL.create(`scenelayout_${_name}`, null)),
          void 0 ===
            (_data = JSON.parse(_dataStore.get("data") || "{}")).layers &&
            (_data.layers = -1),
          _options.perFrame)
        )
          _data.layers > 0 && createLayers();
        else {
          for (let i = 0, c = _data.layers + 1; i < c; i++)
            initialize(createLayer(i));
          _this.loaded = !0;
        }
      }
      function createLayers() {
        let index = 0,
          renderWorker = new Render.Worker(function () {
            initialize(createLayer(index)),
              index++ == _data.layers &&
                (renderWorker.stop(), (_this.loaded = !0));
          }, _options.perFrame);
      }
      function getGroup(name) {
        if (!name) return _this.group;
        if (name == _name) return _this.group;
        if (!_groups[name]) {
          let uilGroup = _uil ? createFolder(name) : null;
          uilGroup &&
            (uilGroup.setLabel(`${name} (Group)`),
            _uil.add(uilGroup),
            _graph && _graph.addGroup(uilGroup.id, name));
          let config = InputUIL.create(`GROUP_${name}_${name}`, uilGroup);
          config.setLabel("Parameters"),
            _timeline && config.add("tween"),
            config.addToggle("billboard");
          let group = new Group();
          (_groups[name] = group),
            (_layers[name] = group),
            (_exists[name] = "group"),
            (group.prefix = `${name}_${_name}`),
            MeshUIL.add(group, uilGroup).setLabel("Mesh"),
            _this.add(group),
            config.get("billboard") &&
              _this.startRender((_) => Utils3D.billboard(group)),
            config.get("tween") && applyTween(group, name, uilGroup);
        }
        return _groups[name];
      }
      async function applyTween(mesh, id, group, shader) {
        let config = TweenUIL.create(`Element_${id}_${_name}`, group),
          a = config.add(
            tween(
              mesh.position,
              mesh.position.clone(),
              100,
              "linear",
              0,
              null,
              !0
            ),
            "position"
          ),
          b = config.add(
            tween(
              mesh.rotation,
              mesh.rotation.clone(),
              100,
              "linear",
              0,
              null,
              !0
            ),
            "rotation"
          ),
          c = config.add(
            tween(mesh.scale, mesh.scale.clone(), 100, "linear", 0, null, !0),
            "scale"
          ),
          d =
            shader && shader.uniforms.uAlpha
              ? config.add(
                  tween(
                    shader.uniforms.uAlpha,
                    { value: 1 },
                    100,
                    "linear",
                    0,
                    null,
                    !0
                  ),
                  "alpha"
                )
              : null;
        await defer(),
          await defer(),
          config.setLabel("Tween"),
          mesh.position.equals(a.props) ||
            (0 == a.props.x && 0 == a.props.y && 0 == a.props.z) ||
            _timeline.add(a),
          mesh.rotation.equals(b.props) ||
            (0 == b.props.x && 0 == b.props.y && 0 == b.props.z) ||
            _timeline.add(b),
          mesh.scale.equals(c.props) ||
            (1 == c.props.x && 1 == c.props.y && 1 == c.props.z) ||
            _timeline.add(c),
          d &&
            shader.uniforms.uAlpha.value != d.props.uAlpha &&
            _timeline.add(d),
          (mesh.tweens = { position: a, rotation: b, scale: c, alpha: d });
      }
      async function createLayer(index, groupName) {
        let id = "number" == typeof index ? index : ++_data.layers;
        if (UILStorage.get(`sl_${_name}_${id}_deleted`)) return;
        let group = _uil ? createFolder(id) : void 0,
          shader,
          mesh,
          input = InputUIL.create(`Config_${id}_${_name}`, group);
        input.setLabel("Parameters"),
          input
            .add("name", "hidden")
            .add("geometry")
            .addToggle("visible", !0)
            .addToggle("transparent")
            .addToggle("depthWrite", !0)
            .addToggle("depthTest", !0)
            .addToggle("billboard")
            .addToggle("snapToAspect", !0)
            .add("shader")
            .add("customClass")
            .add("wildcard")
            .add("renderOrder", "hidden")
            .add("group", "hidden")
            .add("breakpoints")
            .addSelect("side", [
              { label: "Front Side", value: "Shader.FRONT_SIDE" },
              { label: "Back Side", value: "Shader.BACK_SIDE" },
              { label: "Double Side", value: "Shader.DOUBLE_SIDE" },
            ])
            .addSelect("blending", [
              { label: "Normal", value: "Shader.NORMAL_BLENDING" },
              { label: "Additive", value: "Shader.ADDITIVE_BLENDING" },
            ]),
          (input.name = _name),
          (input.prefix = `Element_${id}_${_name}`),
          (input.id = id),
          group && (group.params = input),
          _timeline && input.addToggle("tween"),
          _options.physics &&
            (input.addToggle("physics"), input.add("physicsCode"));
        let name = input.get("name") || id,
          shaderName = input.get("shader") || "SceneLayout",
          geomPath = input.get("geometry"),
          visible = input.get("visible"),
          transparent = input.get("transparent"),
          depthWrite = input.get("depthWrite"),
          depthTest = input.get("depthTest"),
          billboard = input.get("billboard"),
          doTween = input.get("tween"),
          renderOrder = input.getNumber("renderOrder"),
          blending = input.get("blending"),
          side = input.get("side"),
          snap = input.get("snapToAspect"),
          physics = input.get("physics"),
          breakpoints = input.get("breakpoints");
        breakpoints && (breakpoints = breakpoints.replace(/ /g, "").split(","));
        let breakpoint = breakpoints && _breakpoint ? "-" + _breakpoint : "";
        name && group && group.setLabel(name),
          groupName && input.setValue("group", groupName);
        let groupParent = getGroup(input.get("group"));
        if (group) {
          let groupName = input.get("group"),
            groupId = groupName ? `sl_${_name}_${groupName}` : void 0;
          _graph && _graph.addLayer(group.id, name || id + "", groupId);
        }
        if ((_uil && _uil.add(group), "ignore" == name)) return;
        let customClass = input.get("customClass");
        if (((_exists[name] = customClass ? "custom" : "mesh"), customClass)) {
          if (!window[customClass])
            return console.warn(
              `Tried to initialize ${customClass} but it doesn't  exist!`
            );
          let obj = _this.initClass(
            window[customClass],
            input,
            group,
            id,
            null
          );
          if (
            ((mesh = obj.group),
            "boolean" == typeof visible && mesh && (mesh.visible = visible),
            doTween && obj.group && applyTween(obj.group, id, group),
            (_custom[name] = obj),
            (_layers[name] = obj),
            _this.onCreateLayer)
          ) {
            let capture = (cb) => (
              _this.delayedCall((_) => cb(obj, name), 32), !0
            );
            if (_this.onCreateLayer(name, capture)) return;
          }
          return void (obj.group && groupParent.add(obj.group));
        }
        if (_this.onCreateLayer) {
          let capture = (cb) => {
            let mesh = new Group();
            return (
              (mesh.prefix = `Element_${id}_${_name}${breakpoint}`),
              MeshUIL.add(mesh, group),
              doTween &&
                applyTween(mesh, id, group, {
                  uniforms: { uAlpha: { value: 1 } },
                }),
              (_meshes[name] = mesh),
              (_layers[name] = mesh),
              _this.delayedCall((_) => cb(mesh, name), 32),
              !0
            );
          };
          if (_this.onCreateLayer(name, capture)) return;
        }
        let geom = World.PLANE;
        if (
          (geomPath &&
            geomPath.includes(["World", "SceneLayout"]) &&
            ((geom = eval(geomPath)), (geomPath = null)),
          shaderName.includes(".shader"))
        ) {
          let layer = await _this.getLayer(shaderName.split(".shader")[0]);
          (shader = layer.shader), (shader._copied = !0);
        } else if (shaderName.includes("PBR"))
          shader = _this.initClass(PBRShader, shaderName, {
            unique: `Element_${id}_${_name}`,
          });
        else {
          let texturePath = input.getImage("texture"),
            maskPath = input.getImage("mask");
          texturePath
            ? texturePath.includes("assets/images") ||
              (texturePath = _options.rootPath + texturePath)
            : (texturePath = "assets/images/_scenelayout/uv.jpg"),
            maskPath
              ? maskPath.includes("assets/images") ||
                (maskPath = _options.rootPath + maskPath)
              : (maskPath = "assets/images/_scenelayout/mask.jpg"),
            (shader = _this.initClass(Shader, shaderName, {
              unique: `Element_${id}_${_name}`,
              tMap: { value: Utils3D.getTexture(texturePath) },
              tMask: { value: Utils3D.getTexture(maskPath) },
              uAlpha: { value: 1 },
            })),
            defer((_) => {
              for (let key in shader.uniforms) {
                let uniform = shader.uniforms[key];
                uniform.value instanceof Texture &&
                  initialize(uniform.value.promise || defer());
              }
            });
        }
        if (
          ("boolean" == typeof depthWrite && (shader.depthWrite = depthWrite),
          "boolean" == typeof depthTest && (shader.depthTest = depthTest),
          "boolean" == typeof transparent && (shader.transparent = transparent),
          geomPath && (geom = await GeomThread.loadGeometry(geomPath)),
          (mesh = new Mesh(geom, shader)),
          "boolean" == typeof _options.frustumCulled &&
            (mesh.frustumCulled = _options.frustumCulled),
          "boolean" == typeof visible && (mesh.visible = visible),
          groupParent.add(mesh),
          (mesh.prefix = `Element_${id}_${_name}${breakpoint}`),
          snap)
        ) {
          let map = shader.uniforms.tMap
            ? shader.uniforms.tMap.value
            : shader.uniforms.tMask.value;
          map.promise.then((_) => {
            let width = map.image.width,
              height = map.image.height;
            MeshUIL.add(mesh, group).setLabel("Mesh"),
              (mesh.scale.y = mesh.scale.x * (height / width));
          }),
            await map.promise;
        } else MeshUIL.add(mesh, group).setLabel("Mesh");
        if (physics) {
          let obj = Physics.instance().create(mesh);
          (obj.prefix = `Physics_${id}_${_name}`),
            PhysicsUIL.add(obj, group).setLabel("Physics");
          let code = input.get("physicsCode");
          code && _this.initClass(window[code], obj, mesh, group, input);
        }
        (_meshes[name] = mesh),
          (_layers[name] = mesh),
          breakpoints && _breakpoints.push(mesh),
          (mesh.renderOrder = _this.baseRenderOrder + (renderOrder || 0)),
          billboard && _this.startRender((_) => Utils3D.billboard(mesh)),
          doTween && applyTween(mesh, id, group, shader),
          "SceneLayout" != shaderName &&
            window[shaderName] &&
            _this.initClass(window[shaderName], mesh, shader, group, input),
          shader._copied ||
            (shader !== mesh.shader && !shaderName.includes("PBR")) ||
            ShaderUIL.add(shader, group).setLabel("Shader"),
          "number" != typeof index &&
            _dataStore.setValue("data", JSON.stringify(_data)),
          blending && (shader.blending = eval(blending)),
          side && (shader.side = eval(side)),
          (input.onUpdate = (key) => {
            switch (key) {
              case "name":
                group.setLabel(input.get(key));
                break;
              case "visible":
                mesh.visible = input.get(key);
                break;
              case "renderOrder":
                mesh.renderOrder = _this.baseRenderOrder + input.getNumber(key);
                break;
              case "transparent":
                shader.transparent = input.get(key);
                break;
              case "depthWrite":
                shader.depthWrite = input.get(key);
                break;
              case "depthTest":
                shader.depthTest = input.get(key);
                break;
              case "side":
                shader.side = eval(input.get(key));
                break;
              case "blending":
                shader.blending = eval(input.get(key));
            }
          });
      }
      function addListeners() {
        _this.events.sub(SceneLayout.BREAKPOINT, (e) =>
          _this.localBreakpoint ? null : setBreakpoint(e)
        );
      }
      function setBreakpoint({ value: value }) {
        (_breakpoint = value),
          _breakpoints.forEach((mesh) => {
            (mesh.prefix = mesh.prefix.split("-")[0] + "-" + _breakpoint),
              new MeshUILConfig(mesh);
          });
      }
      async function ready() {
        await _this.wait(_this, "loaded"),
          UIL.sidebar && UIL.sidebar.toolbar.hideAll();
      }
      Inherit(this, Object3D);
      const _this = this;
      var _dataStore,
        _data,
        _timeline,
        _breakpoint,
        _breakpoints = [],
        _folders = {},
        _groups = {},
        _custom = {},
        _meshes = {},
        _exists = {},
        _layers = {},
        _uil = UIL.sidebar,
        _graph,
        _groupIndex = 0;
      (this.isSceneLayout = !0),
        (this.name = _name),
        (async function () {
          await initialize(defer()),
            SceneLayout.getTexture ||
              (SceneLayout.getTexture = Utils3D.getTexture),
            initGraph(),
            initParams(),
            initialize(initConfig()),
            initData(),
            addListeners(),
            ready();
        })(),
        (this.ready = async function () {
          await _this.wait(_this, "loaded"),
            await _this.wait(_this, "configured"),
            await defer(),
            await defer();
        }),
        (this.getLayer = async function (name) {
          let timer;
          return (
            Hydra.LOCAL &&
              (timer = _this.delayedCall((_) => {
                _exists[name] ||
                  console.warn(`${name} doesn't exist in SceneLayout ${_name}`);
              }, 1e3)),
            await _this.wait(_layers, name),
            timer && clearTimeout(timer),
            _layers[name]
          );
        }),
        (this.getLayers = async function () {
          let array = [];
          for (let i = 0; i < arguments.length; i++)
            array.push(_this.getLayer(arguments[i]));
          return Promise.all(array);
        }),
        (this.getAllLayers = async function () {
          return await this.ready(), _layers;
        }),
        (this.exists = function (name) {
          return _exists[name];
        }),
        (this._createLayer = function (parentId) {
          createLayer(null, parentId);
        }),
        (this._createGroup = function (parentId) {
          getGroup(`group_${_groupIndex++}`, parentId);
        }),
        (this._rename = function (id, name, value) {
          let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
          if (folder) {
            if ((folder.setLabel(value), folder.params))
              folder.params.setValue("name", value);
            else if (folder == _folders[id]) {
              let newId = id.slice(0, id.length - name.length) + value;
              (_folders[newId] = _folders[id]),
                (folder.id = newId),
                delete _folders[id];
            }
            [_groups, _custom, _meshes, _exists, _layers].forEach(function (
              store
            ) {
              store[name] && ((store[value] = store[name]), delete store[name]);
            });
          }
        }),
        (this._deleteLayer = function (id, name) {
          id.includes("_") && (id = (id = id.split("_"))[id.length - 1]);
          let folder = _folders[id] || _folders[`sl_${_name}_${id}`],
            layer = _layers[id] || _layers[name];
          return layer && layer.isGroup && layer.length > 1
            ? (alert("Can't delete a group that has nested layers."), !1)
            : !!confirm("Are you sure you want to delete this layer?") &&
                (layer &&
                  layer._parent &&
                  (layer._parent.remove(layer), (layer._parent = null)),
                folder && folder.parent && folder.parent.remove(folder),
                UILStorage.set(`sl_${_name}_${id}_deleted`, !0),
                !0);
        }),
        (this._changeParent = function (
          childId,
          childName,
          parentId,
          parentName
        ) {
          let child = _layers[childId] || _layers[childName],
            parent = _layers[parentId] || _layers[parentName] || _this;
          if (!child) return;
          let folder =
            _folders[childId] || _folders[`sl_${_name}_${childName}`];
          folder &&
            folder.params &&
            folder.params.setValue("group", parentName);
          let parentObject = parent.group || parent,
            childObject = child.group || child;
          parentObject.isObject3D &&
            childObject.isObject3D &&
            parentObject.add(childObject),
            child.updateMatrix && child.updateMatrix();
        }),
        (this._visible = function (name, visible) {
          let mesh = _layers[name];
          mesh && (mesh.group && (mesh = mesh.group), (mesh.visible = visible));
        }),
        (this._focus = function (name) {
          UIL.sidebar.toolbar.filterSingle(name);
        }),
        (this._blur = function (name) {
          let folder = _folders[name] || _folders[`sl_${_name}_${name}`];
          folder &&
            folder.forEachFolder &&
            (folder.forEachFolder((f) => f.close()), folder.close());
        }),
        (this._sort = function (order) {
          order.forEach((label, index) => {
            label.children &&
              label.children.forEach(function (child, j, all) {
                let folder = _folders[child];
                if (!folder || !folder.params) return;
                let renderOrder =
                  _this.baseRenderOrder + index + (j + 1) / (all.length + 1);
                folder.params.setValue("renderOrder", renderOrder);
                let mesh = _layers[child] || _layers[folder.label];
                mesh && (mesh.renderOrder = renderOrder);
              });
            let folder = _folders[label];
            if (!folder || !folder.params) return;
            let renderOrder = _this.baseRenderOrder + index;
            folder.params.setValue("renderOrder", renderOrder);
            let mesh = _layers[label] || _layers[folder.label];
            mesh && (mesh.renderOrder = renderOrder);
          });
        }),
        this.set("breakpoint", (value) => {
          (_this.localBreakpoint = !0), setBreakpoint({ value: value });
        }),
        this.get("breakpoint", (_) => _breakpoint);
    },
    (_) => {
      (SceneLayout.BREAKPOINT = "sl_breakpoint"),
        (SceneLayout.setBreakpoint = function (value) {
          (SceneLayout.breakpoint = value),
            Events.emitter._fireEvent(SceneLayout.BREAKPOINT, { value: value });
        });
    }
  ),
  Class(function Shaders() {
    function parseSingleShader(code, fileName) {
      let uniforms = code.split("#!UNIFORMS")[1].split("#!")[0],
        varyings = code.split("#!VARYINGS")[1].split("#!")[0],
        attributes = code.split("#!ATTRIBUTES")[1].split("#!")[0];
      for (; code.includes("#!SHADER"); ) {
        let split = (code = code.slice(code.indexOf("#!SHADER"))).split(
            "#!SHADER"
          )[1],
          br = split.indexOf("\n"),
          name = split.slice(0, br).split(": ")[1];
        name.slice(0, 6).includes("Vertex") &&
          (name = fileName.split(".")[0] + ".vs"),
          name.slice(0, 8).includes("Fragment") &&
            (name = fileName.split(".")[0] + ".fs");
        let glsl = split.slice(br);
        glsl = name.includes(".vs")
          ? attributes + uniforms + varyings + glsl
          : uniforms + varyings + glsl;
        let splitName = name.split(".");
        (_this[splitName[0] + (splitName[1].includes("vs") ? ".vs" : ".fs")] =
          glsl),
          (code = code.replace("#!SHADER", "$"));
      }
    }
    function parseCompiled(shaders) {
      var split = shaders.split("{@}");
      split.shift();
      for (var i = 0; i < split.length; i += 2) {
        var name = split[i],
          text = split[i + 1];
        text.includes("#!UNIFORMS")
          ? parseSingleShader(text, name)
          : (_this[name] = text);
      }
    }
    function parseRequirements() {
      for (var key in _this) {
        var obj = _this[key];
        "string" == typeof obj && (_this[key] = require(obj));
      }
    }
    function require(shader) {
      if (!shader.includes("require")) return shader;
      for (
        shader = shader.replace(/# require/g, "#require");
        shader.includes("#require");

      ) {
        var name = shader.split("#require(")[1].split(")")[0];
        if (((name = name.replace(/ /g, "")), !_this[name]))
          throw (
            "Shader required " +
            name +
            ", but not found in compiled shaders.\n" +
            shader
          );
        shader = shader.replace("#require(" + name + ")", _this[name]);
      }
      return shader;
    }
    Inherit(this, Component);
    var _this = this;
    (this.parse = function (code, file) {
      code.includes("{@}")
        ? (parseCompiled(code), parseRequirements())
        : ((file = (file = file.split("/"))[file.length - 1]),
          (_this[file] = code)),
        (_this.shadersParsed = !0);
    }),
      (this.onReady = this.ready =
        function (callback) {
          let promise = Promise.create();
          return (
            callback && promise.then(callback),
            _this.wait(() => promise.resolve(), _this, "shadersParsed"),
            promise
          );
        }),
      (this.getShader = function (string) {
        _this.FALLBACKS &&
          _this.FALLBACKS[string] &&
          (string = _this.FALLBACKS[string]);
        var code = _this[string];
        if (!code) throw `No shader ${string} found`;
        for (; code.includes("#test "); )
          try {
            var test = code.split("#test ")[1],
              name = test.split("\n")[0],
              glsl = code.split("#test " + name + "\n")[1].split("#endtest")[0];
            eval(name) || (code = code.replace(glsl, "")),
              (code = code.replace("#test " + name + "\n", "")),
              (code = code.replace("#endtest", ""));
          } catch (e) {
            throw "Error parsing test :: " + string;
          }
        return code;
      });
  }, "static"),
  Class(function StageLayoutUtil() {
    async function init() {
      await UILStorage.ready(),
        (_data = JSON.parse(UILStorage.get(KEY) || "[]")),
        compile();
    }
    function compile() {
      _data.forEach((key) => {
        _compiled[key] = JSON.parse(
          UILStorage.get(`INPUT_Config_${key}_compiled`) || "{}"
        );
        let resizeCode = UILStorage.get(`INPUT_Config_${key}_onResize`);
        resizeCode &&
          (_compiled[key].resize = new Function("$this", resizeCode));
      });
    }
    Inherit(this, Component);
    var _data;
    const KEY = "stagelayoututil_keys";
    var _compiled = {};
    !(async function () {
      await Hydra.ready(), (window.Platform && Platform.isPlatform) || init();
    })(),
      (this.save = function (key, data, input) {
        let compiled = JSON.parse(input.get("compiled") || "{}");
        (compiled[key] = data),
          input.setValue("compiled", JSON.stringify(compiled));
      }),
      (this.create = function (key) {
        _data.includes(key) ||
          (_data.push(key), UILStorage.set(KEY, JSON.stringify(_data)));
      }),
      (this.getCompiled = function (key) {
        return _compiled[key];
      }),
      (this.reload = function () {
        return init();
      });
  }, "static"),
  Class(function Track() {
    Inherit(this, Model);
    const DEBUG = Utils.query("debug");
    (this.page = function (path, title) {
      let data = {};
      title && (data.page_title = title),
        path && (data.page_path = path),
        window.gtag && gtag("config", Config.ANALYTICS_ID, data),
        DEBUG &&
          (window.gtag || console.log("no gtag"),
          Config.ANALYTICS_ID || console.log("Config.ANALYTICS_ID required"),
          console.log(`>>> track page: '${JSON.stringify(data)}'`));
    }),
      (this.event = function (category, action, label, value, params) {
        let data = {
          event: "event",
          event_category: null,
          event_action: null,
          event_label: null,
          value: null,
        };
        category && (data.event_category = category),
          action && (data.event_action = action),
          label && (data.event_label = label),
          value && (data.value = value),
          params && (data = Object.assign(params, data)),
          window.gtag && gtag("event", action, data),
          DEBUG &&
            (window.gtag || console.log("no gtag"),
            console.log(
              `>>> track event: '${action}', '${JSON.stringify(data)}'`
            ));
      });
  }, "Static"),
  Class(function UIL() {
    function doNotLoad() {
      Hydra.LOCAL &&
        Utils.query("remoteUIL") &&
        (_this.sidebar = _this.global = new UILPanel("null"));
    }
    function init() {
      initContainer(), initStyle(), initSidebar(), initGraph();
    }
    function initContainer() {
      ($el = $("UIL"))
        .css({ position: "fixed", contain: "strict" })
        .size("100%", "100%")
        .mouseEnabled(!1),
        document.body.insertAdjacentElement("beforeend", $el.div),
        $el.setZ(9999);
    }
    function initStyle() {
      let style = document.head.appendChild(document.createElement("style"));
      (style.type = "text/css"),
        (style.id = "uil-style"),
        style.appendChild(
          document.createTextNode(
            "\n            .UIL ::-webkit-scrollbar { width:2px; }\n            .UIL ::-webkit-scrollbar-track { background:#161616; }\n            .UIL ::-webkit-scrollbar-thumb { background:#37A1EF; }\n        "
          )
        ),
        (_style = style);
    }
    function initGraph() {
      if (!_this.sidebar) return;
      let parent = _ui.sidebar.element.div;
      parent.insertBefore(UILGraph.instance().element.div, parent.firstChild);
    }
    function initSidebar() {
      _this.add(new UILPanel("sidebar")),
        _this.add(new UILPanel("global", { side: "left" }));
    }
    Inherit(this, Component);
    const _this = this;
    let _style,
      $el,
      _ui = {};
    Hydra.ready(async (_) => {
      if (
        !Hydra.LOCAL ||
        Device.mobile ||
        window._BUILT_ ||
        (!location.search.includes("uil") && !Device.detect("hydra"))
      )
        return doNotLoad();
      init(), (_this.loaded = !0);
    }),
      (this.ready = function () {
        return _this.wait(_this, "loaded");
      }),
      (this.add = function (panel) {
        return (
          (_ui[panel.id] = panel),
          (_this[panel.id] = panel),
          $el.add(panel),
          _this
        );
      }),
      (this.remove = function (id) {
        let $panel = _ui[id];
        return (
          $panel.eliminate && $panel.eliminate(),
          $panel.destroy(),
          delete _ui[id],
          delete _this[id],
          _this
        );
      }),
      (this.find = function (id) {
        return Object.values(_ui).reduce(
          (acc, el) => acc.concat(el.find(id)),
          []
        );
      }),
      (this.enableSorting = function (id, enable) {
        let el = _this.find(id)[0];
        return el && el.enableSorting && el.enableSorting(enable), _this;
      }),
      (this.addCSS = function (control, style) {
        if (control.styled) return;
        let node = document.createTextNode(style);
        return _style && _style.appendChild(node), (control.styled = !0), _this;
      }),
      (this.REORDER = "uil_reorder");
  }, "static"),
  Class(function CameraUIL() {
    (this.UPDATE = "camera_uil_update"),
      (this.add = function (light, group) {
        return new CameraUILConfig(light, group || UIL.global);
      });
  }, "static"),
  Class(function CameraUILConfig(_camera, _uil) {
    function initFOV(key) {
      let initValue =
        UILStorage.get(`${prefix}${key}`) || _camera.camera.fov || 9999;
      if (_group) {
        let number = new UILControlNumber(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        number.onFinishChange((e) => {
          _group &&
            Events.emitter._fireEvent(CameraUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: e,
              fov: !0,
              group: _this,
            }),
            _camera.setFOV(e),
            UILStorage.set(`${prefix}${key}`, e);
        }),
          _group.add(number);
      }
      _camera.setFOV(initValue);
    }
    function initVec(key) {
      let initValue =
        UILStorage.get(`${prefix}${key}`) || _camera[key].toArray();
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        vector.onChange((e) => {
          _group &&
            Events.emitter._fireEvent(CameraUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: e,
              vec: !0,
              group: _this,
            }),
            _camera[key].fromArray(e);
        }),
          vector.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(vector);
      }
      _camera[key].fromArray(initValue);
    }
    function initNumber(key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || _camera[key] || 9999;
      if (_group) {
        let number = new UILControlNumber(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        number.onChange((e) => {
          (_camera[key] = e),
            _group &&
              Events.emitter._fireEvent(CameraUIL.UPDATE, {
                prefix: prefix,
                key: key,
                val: e,
                number: !0,
                group: _this,
              });
        }),
          number.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(number);
      }
      _camera[key] = initValue;
    }
    function initRotation() {
      let key = "rotation",
        toRadians = (array) =>
          array
            ? ((array.length = 3), array.map((x) => Math.radians(x)))
            : [0, 0, 0],
        initValue = toRadians(UILStorage.get(`${prefix}${key}`));
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: ((array) =>
            array
              ? ((array.length = 3), array.map((x) => Math.degrees(x)))
              : [0, 0, 0])(initValue),
        });
        vector.onChange((e) => {
          _group &&
            Events.emitter._fireEvent(CameraUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: toRadians(e),
              rotation: !0,
              group: _this,
            }),
            _camera.group[key].fromArray(toRadians(e));
        }),
          vector.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(vector);
      }
      _camera.group[key].fromArray(initValue);
    }
    function addListeners() {
      Events.emitter._addEvent(CameraUIL.UPDATE, update, _this);
    }
    function update(e) {
      e.prefix == prefix &&
        e.group != _this &&
        (e.fov && _camera.setFOV(e.val),
        e.number && (_camera[e.key] = e.val),
        e.rotation && _camera.group[e.key].fromArray(e.val),
        e.vec && _camera[e.key].fromArray(e.val));
    }
    const _this = this;
    if (!_camera.prefix) throw "camera.prefix required when using MeshUIL";
    var prefix = "CAMERA_" + _camera.prefix,
      _group = _uil
        ? (function createFolder() {
            if (!UIL.sidebar) return null;
            let folder = new UILFolder(prefix, {
              label: _camera.prefix,
              closed: !0,
            });
            return _uil.add(folder), folder;
          })()
        : null;
    _camera.position && initVec("position"),
      _camera.group &&
        ((_camera.groupPos = _camera.group.position),
        initVec("groupPos"),
        initRotation()),
      initFOV("fov"),
      _camera.moveXY &&
        (initVec("moveXY"),
        initVec("lookAt"),
        initNumber("lerpSpeed"),
        initNumber("lerpSpeed2")),
      _group && addListeners(),
      (this.setLabel = function (name) {
        _group && _group.setLabel(name);
      });
  }),
  Class(function InputUIL() {
    this.create = function (name, group) {
      return new InputUILConfig(
        name,
        null === group ? null : group || UIL.global
      );
    };
  }, "static"),
  Class(function InputUILConfig(_name, _uil) {
    Inherit(this, Component);
    var _this = this;
    const prefix = "INPUT_" + _name;
    var _group = _uil
        ? (function createFolder() {
            if (!UIL.sidebar) return null;
            let folder = new UILFolder(_name, { closed: !0 });
            return (
              _uil.add(folder), _uil == UIL.sidebar && folder.hide(), folder
            );
          })()
        : null,
      _fields = _uil ? {} : null;
    (this.add = function (
      key,
      initValue,
      uil = window.UILControlText,
      options,
      params = {}
    ) {
      if (!_group || "hidden" == initValue || !UIL.sidebar) return this;
      let value = UILStorage.get(`${prefix}_${key}`);
      "true" === value && (value = !0),
        "false" === value && (value = !1),
        uil == UILControlVector &&
          "string" == typeof value &&
          (value = JSON.parse(value)),
        void 0 === value && (value = initValue),
        "string" == typeof value &&
          uil == UILControlImage &&
          (value = JSON.parse(value));
      let change = (val) => {
        (val = "string" == typeof val ? val : JSON.stringify(val)),
          UILStorage.set(`${prefix}_${key}`, val),
          _this.onUpdate && _this.onUpdate(key);
      };
      ("string" != typeof initValue &&
        "number" != typeof initValue &&
        uil != UILControlVector) ||
        UILStorage.get(`${prefix}_${key}`) ||
        change(initValue);
      let opts = Utils.mergeObject(params, {
        label: key,
        value: value,
        options: options,
      });
      uil == window.UILControlButton && (opts = options);
      let config = new uil(`${prefix}_${key}`, opts);
      return (
        config.onFinishChange(change),
        _group.add(config),
        (_fields[key] = config),
        this
      );
    }),
      (this.addToggle = function (key, initValue) {
        return UIL.sidebar
          ? this.add(key, initValue, UILControlCheckbox)
          : this;
      }),
      (this.addSelect = function (key, options) {
        return UIL.sidebar
          ? this.add(key, null, UILControlSelect, options)
          : this;
      }),
      (this.addImage = function (key, options) {
        return UIL.sidebar
          ? this.add(key, null, UILControlImage, null, options)
          : this;
      }),
      (this.addNumber = function (key, initValue, step) {
        return UIL.sidebar
          ? this.add(key, initValue, UILControlNumber, null, { step: step })
          : this;
      }),
      (this.addColor = function (key, initValue = new Color()) {
        return UIL.sidebar
          ? this.add(key, initValue.getHexString(), UILControlColor)
          : this;
      }),
      (this.addTextarea = function (key, initValue) {
        return UIL.sidebar
          ? this.add(key, initValue, UILControlTextarea, null, {
              monospace: !0,
              rows: 4,
            })
          : this;
      }),
      (this.addButton = function (key, options) {
        return UIL.sidebar
          ? this.add(key, null, UILControlButton, options)
          : this;
      }),
      (this.addVector = function (key, initValue) {
        return UIL.sidebar ? this.add(key, initValue, UILControlVector) : this;
      }),
      (this.get = function (key) {
        let val = UILStorage.get(`${prefix}_${key}`);
        if ("boolean" == typeof val) return val;
        if (val && "" != val)
          return (
            "true" === val ||
            ("false" !== val &&
              (val.charAt && "[" == val.charAt(0) ? JSON.parse(val) : val))
          );
      }),
      (this.getNumber = function (key) {
        return Number(this.get(key));
      }),
      (this.getImage = function (key) {
        let data = this.get(key);
        if (data) return JSON.parse(data).src;
      }),
      (this.setValue = function (key, value) {
        if (
          (UILStorage.set(`${prefix}_${key}`, value),
          _this.onUpdate && _this.onUpdate(key),
          _fields)
        ) {
          let field = _fields[key];
          field &&
            "string" == typeof value &&
            ((field.value = value), field.update());
        }
        return this;
      }),
      (this.setLabel = function (name) {
        _group && _group.setLabel(name);
      });
  }),
  Class(function MeshUIL() {
    Inherit(this, Component);
    (this.exists = {}),
      (this.UPDATE = "mesh_uil_update"),
      (this.add = function (mesh, group) {
        return new MeshUILConfig(mesh, group || UIL.global);
      });
  }, "static"),
  Class(function MeshUILConfig(_mesh, _uil) {
    function initVec(key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || _mesh[key].toArray();
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        vector.onChange((e) => {
          _mesh[key].fromArray(e),
            _group &&
              Events.emitter._fireEvent(MeshUIL.UPDATE, {
                prefix: prefix,
                key: key,
                val: e,
                group: _this,
              });
        }),
          vector.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(vector);
      }
      _mesh[key].fromArray(initValue);
    }
    function initRotation() {
      let key = "rotation",
        toRadians = (array) =>
          array
            ? ((array.length = 3), array.map((x) => Math.radians(x)))
            : [0, 0, 0],
        initValue = toRadians(UILStorage.get(`${prefix}${key}`));
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: ((array) =>
            array
              ? ((array.length = 3), array.map((x) => Math.degrees(x)))
              : [0, 0, 0])(initValue),
        });
        vector.onChange((e) => {
          _mesh[key].fromArray(toRadians(e)),
            _group &&
              Events.emitter._fireEvent(MeshUIL.UPDATE, {
                prefix: prefix,
                key: key,
                val: toRadians(e),
                group: _this,
              });
        }),
          vector.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(vector);
      }
      _mesh[key].fromArray(initValue);
    }
    function addListeners() {
      Events.emitter._addEvent(MeshUIL.UPDATE, update, _this);
    }
    function update(e) {
      e.prefix == prefix && e.group != _this && _mesh[e.key].fromArray(e.val);
    }
    const _this = this;
    if (!_mesh.prefix) throw "mesh.prefix required when using MeshUIL";
    var prefix = "MESH_" + _mesh.prefix,
      _group =
        _uil && !MeshUIL.exists[prefix]
          ? (function createFolder() {
              if (!UIL.sidebar) return null;
              let folder = new UILFolder(prefix, {
                label: _mesh.prefix,
                closed: !0,
              });
              return _uil.add(folder), folder;
            })()
          : null;
    (this.group = _group),
      (MeshUIL.exists[prefix] = !0),
      initVec("position"),
      initVec("scale"),
      initRotation(),
      _group && addListeners(),
      (this.setLabel = function (name) {
        _group && _group.setLabel(name);
      });
  }),
  Class(function ShaderUIL() {
    (this.exists = {}),
      (this.UPDATE = "update"),
      (this.add = function (shader, group) {
        return new ShaderUILConfig(
          shader.shader || shader,
          group || UIL.global
        );
      });
  }, "static"),
  Class(function ShaderUILConfig(_shader, _uil) {
    function getName() {
      let split = _shader.UILPrefix.split("/");
      return split.length > 2 ? split[0] + "_" + split[2] : split[0];
    }
    function initItems() {
      for (var key in _shader.uniforms) {
        let obj = _shader.uniforms[key];
        obj.ignoreUIL ||
          (obj.value instanceof Color && createColor(obj, key),
          "number" == typeof obj.value && createNumber(obj, key),
          (null === obj.value || obj.value instanceof Texture) &&
            createTexture(obj, key),
          obj.value instanceof Vector2 && createVector(obj, key),
          obj.value instanceof Vector3 && createVector(obj, key),
          obj.value instanceof Vector4 && createVector(obj, key));
      }
    }
    function createVector(obj, key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || obj.value.toArray();
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        vector.onChange((val) => {
          obj.value.fromArray(val),
            _shader.ubo && (_shader.ubo.needsUpdate = !0),
            Events.emitter._fireEvent(ShaderUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: val,
              group: _this,
              vector: !0,
            });
        }),
          vector.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(vector);
      }
      obj.value.fromArray(initValue);
    }
    function createTexture(obj, key) {
      const getTexture =
          obj.getTexture || ShaderUIL.getTexture || Utils3D.getTexture,
        set =
          _shader.parent && _shader.parent.setOverride
            ? _shader.parent.setOverride
            : _shader.set || _shader.setUniform,
        get = _shader.get || _shader.getUniform;
      let prefix = _shader.UILPrefix + "_tx",
        data = UILStorage.get(`${prefix}_${key}`);
      data && (data = JSON.parse(data));
      let value = data ? data.src : null,
        change = (data) => {
          let val = data.src;
          data.compressed && (val += "-compressedKtx"),
            UILStorage.set(`${prefix}_${key}`, JSON.stringify(data)),
            set(
              key,
              getTexture(val, {
                premultiplyAlpha: obj.premultiplyAlpha,
                scale: obj.scale,
              }),
              _shader
            ),
            _group &&
              Events.emitter._fireEvent(ShaderUIL.UPDATE, {
                prefix: _shader.UILPrefix,
                key: key,
                val: val,
                texture: get(key, _shader),
                group: _this,
              });
        };
      if ((value && value.length && change(data), _group)) {
        let img = new UILControlImage(prefix + key, {
          label: key,
          value: data,
        });
        img.onFinishChange(change), _group.add(img);
      }
    }
    function createNumber(obj, key) {
      let initValue = UILStorage.get(`${prefix}${key}`);
      if ((void 0 === initValue && (initValue = obj.value), _group)) {
        let number = new UILControlNumber(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        number.onChange((val) => {
          _shader.ubo && (_shader.ubo.needsUpdate = !0),
            Events.emitter._fireEvent(ShaderUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: val,
              group: _this,
            }),
            (obj.value = val);
        }),
          number.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(number);
      }
      obj.value = initValue;
    }
    function createColor(obj, key) {
      let initValue = UILStorage.get(`${prefix}${key}`);
      if (_group) {
        let color = new UILControlColor(`${prefix}${key}`, {
          label: key,
          value: initValue,
        });
        color.onChange((val) => {
          obj.value.set(val),
            _shader.ubo && (_shader.ubo.needsUpdate = !0),
            _group &&
              Events.emitter._fireEvent(ShaderUIL.UPDATE, {
                prefix: prefix,
                key: key,
                val: val,
                color: !0,
                group: _this,
              });
        }),
          color.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(color);
      }
      initValue && obj.value.set(initValue);
    }
    function addListeners() {
      Events.emitter._addEvent(ShaderUIL.UPDATE, update, _this);
    }
    function update(e) {
      if (e.prefix == _shader.UILPrefix && e.group != _this)
        if (e.color) {
          let val = e.val,
            obj = _shader.uniforms[e.key];
          Array.isArray(val)
            ? obj.value.setRGB(val[0], val[1], val[2])
            : obj.value.set(val);
        } else
          e.texture
            ? "remote" != e.texture && _shader.set(e.key, e.texture)
            : e.vector
            ? _shader.get(e.key).fromArray(e.val)
            : (_shader.uniforms[e.key].value = e.val);
    }
    var _this = this;
    const prefix = _shader.UILPrefix;
    var _group =
      _uil && !ShaderUIL.exists[prefix]
        ? (function createFolder() {
            if (!UIL.sidebar) return null;
            let label = getName();
            "_" == label.charAt(label.length - 1) &&
              (label = label.slice(0, -1));
            let folder = new UILFolder(prefix + label, {
              label: label,
              closed: !0,
            });
            return _uil.add(folder), folder;
          })()
        : null;
    (this.group = _group),
      (ShaderUIL.exists[_shader.UILPrefix] = !0),
      initItems(),
      _group && addListeners(),
      (this.setLabel = function (name) {
        _group && _group.setLabel(name);
      });
  }),
  Class(function ShadowUIL() {
    this.add = function (light, group) {
      return new ShadowUILConfig(light, group || UIL.global);
    };
  }, "static"),
  Class(function ShadowUILConfig(_light, _uil) {
    function initNumber(key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || _light.shadow[key];
      if (_group) {
        let number = new UILControlNumber(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        number.onFinishChange((e) => {
          (_light.shadow[key] = e), UILStorage.set(`${prefix}${key}`, e);
        }),
          _group.add(number);
      }
      _light.shadow[key] = initValue;
    }
    function initVec(key) {
      let initValue =
        UILStorage.get(`${prefix}${key}`) || _light[key].toArray();
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        vector.onChange((e) => {
          _light[key].fromArray(e),
            "target" == key && _light.shadow.camera.lookAt(_light.target);
        }),
          vector.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(vector);
      }
      _light[key].fromArray(initValue);
    }
    function initTick(key) {
      let initValue = UILStorage.get(`${prefix}${key}`);
      if (_group) {
        let tick = new UILControlCheckbox(`${prefix}${key}`, {
          label: key,
          value: initValue,
        });
        tick.onFinishChange((e) => {
          (_light[key] = e), UILStorage.set(`${prefix}${key}`, e);
        }),
          _group.add(tick);
      }
      _light[key] = initValue;
    }
    if (!_light.prefix) throw "light.prefix required when using MeshUIL";
    var prefix = "SHADOW_" + _light.prefix,
      _group = _uil
        ? (function createFolder() {
            if (!UIL.sidebar) return null;
            let folder = new UILFolder(prefix, {
              label: _light.prefix,
              closed: !0,
            });
            return _uil.add(folder), folder;
          })()
        : null;
    (_light.target = _light.shadow.target),
      initVec("position"),
      initVec("target"),
      initNumber("fov"),
      initNumber("size"),
      initNumber("area"),
      initNumber("far"),
      initTick("static"),
      (this.setLabel = function (name) {
        _group && _group.setLabel(name);
      });
  }),
  Class(function TweenUIL() {
    function removeEditor() {
      _editor = _editor.destroy();
    }
    Inherit(this, Component);
    const _this = this;
    var _editor,
      _data = {},
      _created = {};
    (this.create = function (name, version = 1, group) {
      "number" != typeof version && ((group = version), (version = 1));
      let config = new TweenUILConfig(
        name,
        version,
        UIL.global && !_created[name]
      );
      return (
        UIL.global &&
          (_created[name] ||
            ((_created[name] = config),
            config.appendUILGroup(group || UIL.global))),
        config
      );
    }),
      (this.openEditor = function (name, tweens) {
        _editor && _editor.destroy(),
          (_editor = new TweenUILEditor(name, tweens)),
          _this.events.sub(_editor, Events.COMPLETE, removeEditor);
      }),
      (this.set = function (key, value) {
        _data[key] = value;
      }),
      (this.get = function (key) {
        return _data[key];
      });
  }, "static"),
  Class(function TweenUILConfig(_name, _version = 1, _store) {
    function updateConfig() {
      (_config.version = _version),
        UILStorage.setWrite("TWEEN_" + _name + "_config", _config);
    }
    function override(tween, object, props, time, ease, delay) {
      let key = "TWEEN_" + _name + "_" + tween._id,
        storage = UILStorage.get(key),
        obj = { props: props, time: time, ease: ease, delay: delay };
      for (let key in storage) obj[key] = storage[key];
      return TweenUIL.set(key, obj), obj;
    }
    function edit() {
      TweenUIL.openEditor(_name, _tweens);
    }
    var _tweens,
      _folder,
      _config = UILStorage.get("TWEEN_" + _name + "_config");
    _store && (_tweens = []),
      _config
        ? _config.version != _version &&
          (updateConfig(), UILStorage.clearMatch("TWEEN_" + _name))
        : ((_config = {}), updateConfig()),
      (this.add = function (tween, name) {
        return (
          (tween._id = name),
          (tween.overrideValues = override),
          _tweens && _tweens.push(tween),
          tween
        );
      }),
      (this.appendUILGroup = function (uil) {
        let folder = new UILFolder("TWEEN_" + _name, { closed: !0 }),
          button = new UILControlButton("button", {
            actions: [{ title: "Edit", callback: edit }],
            hideLabel: !0,
          });
        folder.add(button), uil.add(folder), (_folder = folder);
      }),
      (this.setLabel = function (name) {
        _folder && _folder.setLabel(name);
      });
  }),
  Class(function TweenUILEditor(_name, _tweens) {
    function createGroup(tween) {
      let obj = TweenUIL.get("TWEEN_" + _name + "_" + tween._id),
        group = new UILFolder(tween._id);
      _gui.add(group);
      let lookup = "TWEEN_" + _name + "_" + tween._id;
      for (let key in obj)
        if ("props" == key)
          switch (tween._id) {
            case "position":
            case "scale":
              createVector(obj, key, group, lookup);
              break;
            case "rotation":
              createRotation(obj, key, group, lookup);
              break;
            default:
              createNumber(obj, key, group, lookup);
          }
        else createString(obj, key, group, lookup);
    }
    function createString(obj, key, group, lookup) {
      let value = obj[key],
        text = new UILControlText(lookup + key, {
          label: key,
          value: value.toString(),
          monospace: !0,
        });
      text.onFinishChange((val) => {
        ("time" != key && "delay" != key) || (val = Number(val)),
          write(lookup, key, val);
      }),
        group.add(text);
    }
    function createNumber(obj, key, group, lookup) {
      let { props: props } = obj,
        keys = Object.keys(props);
      if (keys.length > 1)
        throw "TweenUIL can't deal with a basic Object with more than one key. Define position/rotation/scale or create a tween for each property.";
      let number = new UILControlNumber(`${lookup}${key}`, {
        label: key,
        value: props[keys[0]],
      });
      number.onFinishChange((val) => {
        let output = {};
        (output[keys[0]] = val), write(lookup, key, output);
      }),
        group.add(number);
    }
    function createVector(obj, key, group, lookup) {
      let { props: props } = obj,
        vector = new UILControlVector(`${lookup}${key}`, {
          label: key,
          value: [props.x, props.y, props.z],
          step: 0.05,
        });
      vector.onFinishChange((val) => {
        write(lookup, key, { x: val[0], y: val[1], z: val[2] });
      }),
        group.add(vector);
    }
    function createRotation(obj, key, group, lookup) {
      let toRadians = (array) =>
          array
            ? ((array.length = 3), array.map((x) => Math.radians(x)))
            : [0, 0, 0],
        { props: props } = obj,
        v = ((array) =>
          array
            ? ((array.length = 3), array.map((x) => Math.degrees(x)))
            : [0, 0, 0])([props.x, props.y, props.z]),
        vector = new UILControlVector(`${lookup}${key}`, {
          label: key,
          value: v,
        });
      vector.onFinishChange((val) => {
        let output = toRadians(val);
        write(lookup, key, { x: output[0], y: output[1], z: output[2] });
      }),
        group.add(vector);
    }
    function write(lookup, key, value) {
      let obj = UILStorage.get(lookup) || {};
      (obj[key] = value), UILStorage.set(lookup, obj);
    }
    function exit() {
      _this.events.fire(Events.COMPLETE);
    }
    Inherit(this, Component);
    const _this = this;
    var _gui = new UILWindow(_name, {
      label: "Tween Editor",
      width: "400px",
      height: "auto",
      drag: !0,
    });
    (this.gui = _gui),
      (function () {
        UIL.add(_gui);
        for (let tween of _tweens) createGroup(tween);
        let button = new UILControlButton("button", {
          actions: [{ title: "Exit", callback: exit }],
          hideLabel: !0,
        });
        _gui.add(button);
      })(),
      (this.onDestroy = function () {
        _gui.destroy();
      });
  }),
  Class(function UILFile(_offline) {
    Inherit(this, Component);
    (this.load = async function () {
      let path = window.UIL_STATIC_PATH || "assets/data/uil.json";
      try {
        return await get(path);
      } catch (e) {
        return {};
      }
    }),
      (this.save = async function (sessionData, data) {
        if (
          (Dev.writeFile(
            window.UIL_STATIC_PATH || "assets/data/uil.json",
            data
          ),
          _offline)
        ) {
          let partial = {};
          try {
            partial = await get("assets/data/uil-partial.json", data);
            for (let key in sessionData) partial[key] = sessionData[key];
          } catch (e) {
            partial = sessionData;
          }
          Dev.writeFile("assets/data/uil-partial.json", partial),
            Storage.set("uil_update_partial", !0);
        }
      });
  }),
  Class(function UILStorage() {
    function clearOfflineData() {
      Storage.set("uil_update_partial", !1),
        Dev.writeFile("assets/data/uil-partial.json", {});
    }
    async function init() {
      if (
        (_fs && _fs.destroy(),
        (_fs = _this.initClass(
          uilFile() ? UILFile : UILRemote,
          OFFLINE_FIREBASE
        )),
        (_data = await _fs.load()),
        (_this.loaded = !0),
        !OFFLINE_FIREBASE && Storage.get("uil_update_partial"))
      ) {
        if (
          !confirm(
            "Looks like you have UIL data captured offline, do you want to sync it to Firebase?"
          )
        )
          return clearOfflineData();
        let data = await get("assets/data/uil-partial.json");
        for (let key in data) _this.set(key, data[key]);
        write(!0, !0), clearOfflineData();
      }
    }
    async function write(direct, silent) {
      let prevent = !1,
        e = {};
      (e.prevent = (_) => (prevent = !0)),
        _this.events.fire(_this.SAVE, e),
        (!direct && (e.wait && (await e.wait()), prevent)) ||
          (_fs.save(_dataSession, _data),
          (_dataSession = {}),
          silent ||
            (__body.css({ display: "none" }),
            _this.delayedCall(() => {
              __body.css({ display: "block" });
            }, 100)));
    }
    function uilFile() {
      return (
        !Hydra.LOCAL ||
        !!Device.mobile ||
        !!OFFLINE_FIREBASE ||
        !!window._BUILT_ ||
        !!window._UIL_FILE_ ||
        (!window._FIREBASE_UIL_ && !window.UIL_ID) ||
        (!Device.detect("hydra") && !location.search.includes("uil"))
      );
    }
    Inherit(this, Component);
    const _this = this;
    var _fs,
      _data = {},
      _dataSession = {};
    this.SAVE = "uil_save";
    const OFFLINE_FIREBASE = Utils.query("offlineFB");
    Hydra.ready(async (_) => {
      (window.Platform && window.Platform.isPlatform) || init(),
        !Hydra.LOCAL ||
          Device.mobile ||
          window._BUILT_ ||
          (!location.search.includes("uil") && !Device.detect("hydra")) ||
          __window.bind("keydown", (e) => {
            (e.ctrlKey || e.metaKey) &&
              83 == e.keyCode &&
              (e.preventDefault(), write());
          });
    }),
      (this.reload = function (id, path) {
        (_this.loaded = !1),
          (window.UIL_ID = id),
          (window.UIL_STATIC_PATH = path),
          init();
      }),
      (this.set = function (key, value) {
        null === value
          ? (delete _data[key], delete _dataSession[key])
          : ((_data[key] = value), (_dataSession[key] = value));
      }),
      (this.setWrite = function (key, value) {
        this.set(key, value), write(!0);
      }),
      (this.clearMatch = function (string) {
        for (let key in _data) key.includes(string) && delete _data[key];
        write(!0);
      }),
      (this.write = function (silent) {
        write(!0, silent);
      }),
      (this.get = function (key) {
        return _data[key];
      }),
      (this.ready = function () {
        return _this.wait(_this, "loaded");
      }),
      (this.parse = function (key, hint) {
        let data = _data[key];
        if (void 0 === data) return null;
        if (Array.isArray(data)) {
          if (hint instanceof Vector2)
            return { value: new Vector2().fromArray(data) };
          if (hint instanceof Vector3)
            return { value: new Vector3().fromArray(data) };
          if (hint instanceof Vector4)
            return { value: new Vector4().fromArray(data) };
        } else if ("string" == typeof data && "#" === data.charAt(0))
          return { value: new Color(data) };
        return { value: data };
      });
  }, "static"),
  Class(function UILControlButton(_id, _opts = {}) {
    function init() {
      _this.init(_id, _opts),
        _opts.hideLabel &&
          (_this.$label.css({ display: "none" }),
          _this.$content.css({ width: "100%" }));
    }
    function initActions() {
      $view = $("inputs");
      let config = [].concat(_opts.actions);
      (_buttons = []
        .concat(_opts.actions)
        .map(({ title: title, callback: callback }) => {
          let btn = $view.create(`btn btn-${title}`, "button");
          btn.text(title).bg("#1d1d1d"),
            btn.css({
              width: `calc(100% / ${config.length || 1}`,
              border: "1px solid #2e2e2e",
              color: "#37a1ef",
              position: "relative",
            }),
            btn.interact((e) => hover(btn, e)),
            btn.click((e) => click(e, title, callback));
        })),
        (_this.view = $view);
    }
    function click(e, title, callback) {
      (_this.value = title), callback && callback(title, e), _this.finish();
    }
    function hover(btn, e) {
      "over" === e.action
        ? btn.css({ border: "1px solid #9b9c9b" })
        : btn.css({ border: "1px solid #2e2e2e" });
    }
    Inherit(this, UILControl);
    const _this = this;
    let $view,
      _buttons = [];
    init(), initActions();
  }),
  Class(function UILControlCheckbox(_id, _opts = {}) {
    function init() {
      (_opts.value = _opts.value || !1), _this.init(_id, _opts);
    }
    function initView() {
      ($view = $("view")),
        ($label = $view.create("label", "label"))
          .size(30, 15)
          .css({
            position: "relative",
            display: "inline-block",
            borderRadius: 15,
            border: "1px solid #2e2e2e",
          })
          .bg(_this.value ? "#37a1ef" : "#1d1d1d"),
        ($checkbox = $label.create("checkbox", "input")).attr(
          "type",
          "checkbox"
        ),
        $checkbox.attr("checked", _this.value),
        $checkbox.css({ opacity: 0, width: "100%", position: "absolute" }),
        ($slider = $label.create("slider"))
          .size(15, 15)
          .css({
            borderRadius: 15,
            position: "absolute",
            right: _this.value ? 0 : "auto",
            boxSizing: "border-box",
          })
          .bg("#ffffff"),
        (_this.view = $view);
    }
    function toggle() {
      $checkbox.attr("checked", _this.value),
        $slider.css({ right: _this.value ? 0 : "auto" }),
        $label.bg(_this.value ? "#37a1ef" : "#1d1d1d");
    }
    function addHandlers() {
      $checkbox.div.addEventListener("focus", focus, !1),
        $checkbox.div.addEventListener("blur", blur, !1),
        $checkbox.div.addEventListener("click", click, !1),
        $checkbox.div.addEventListener("keypress", click, !1);
    }
    function click() {
      (_this.value = !_this.value), toggle(), _this.finish();
    }
    function focus() {
      $label.css({ border: "1px solid #37a1ef" });
    }
    function blur() {
      $label.css({ border: "1px solid #2e2e2e" });
    }
    Inherit(this, UILControl);
    const _this = this;
    let $view, $label, $checkbox, $slider;
    init(),
      initView(),
      addHandlers(),
      (this.update = function () {
        toggle();
      }),
      (this.onDestroy = function () {
        $checkbox.div.removeEventListener("focus", focus, !1),
          $checkbox.div.removeEventListener("blur", blur, !1),
          $checkbox.div.removeEventListener("click", click, !1),
          $checkbox.div.removeEventListener("keypress", click, !1);
      });
  }),
  Class(function UILControlColor(_id, _opts = {}) {
    function init() {
      (_opts.value = _opts.value || "#ffffff"), _this.init(_id, _opts);
    }
    function initInput() {
      let $view = $("color");
      $view.css({ position: "relative" }).css({ padding: 1 }),
        ($display = $view.create("color")).size("100%", "100%").bg(_this.value),
        $display.css({ border: "1px solid #2E2E2E", boxSizing: "border-box" }),
        ($display.hex = $display.create("hex")),
        $display.hex.text(_this.value),
        $display.hex.css({
          color: _this.value,
          filter: "invert(100%)",
          fontSize: 12,
          fontFamily: "sans-serif",
          padding: 1,
        }),
        ($input = $view.create("input", "input")).attr("type", "color"),
        $input
          .size("100%")
          .css({
            boxSizing: "border-box",
            opacity: 0,
            position: "absolute",
            top: 0,
            left: 0,
          }),
        ($input.div.value = _this.value),
        (_this.view = $view);
    }
    function addHandlers() {
      (finishChange = _this.debounce(finishChange, 250)),
        $input.div.addEventListener("input", change, !1),
        $input.div.addEventListener("change", finishChange, !1),
        $input.div.addEventListener("focus", focus, !1),
        $input.div.addEventListener("blur", blur, !1);
    }
    function change(v) {
      (_this.value = $input.div.value),
        $display.bg(_this.value),
        $display.hex.css({ color: _this.value }).text(_this.value);
    }
    function finishChange() {
      _this.finish();
    }
    function focus() {
      $display.css({ border: "1px solid #37a1ef" });
    }
    function blur() {
      $display.css({ border: "1px solid #2E2E2E" });
    }
    Inherit(this, UILControl);
    const _this = this;
    let $input, $display;
    init(),
      initInput(),
      addHandlers(),
      (this.update = function () {
        ($input.div.value = _this.value),
          $display.bg(_this.value),
          $display.hex.css({ color: _this.value }).text(_this.value);
      }),
      (this.onDestroy = function () {
        $input.div.removeEventListener("input", change, !1),
          $input.div.removeEventListener("change", finishChange, !1),
          $input.div.removeEventListener("focus", focus, !1),
          $input.div.removeEventListener("blur", blur, !1);
      });
  }),
  Class(function UILControlImage(_id, _opts = { value: {} }) {
    function init() {
      (_opts.value = Object.assign(
        {
          src: "",
          relative: _opts.relative || "",
          prefix: _opts.prefix || "assets/images",
          filename: "",
        },
        _opts.value
      )),
        (_value = Object.assign({}, _opts.value)),
        _this.init(_id, _opts);
    }
    function initView() {
      ($view = $("view")).css({ position: "relative", padding: 5 }),
        ($input = $view.create("path", "input")).size("100%").bg("#1D1D1D"),
        $input.css({
          boxSizing: "border-box",
          border: "1px solid #2E2E2E",
          color: "#37A1EF",
          marginBottom: 5,
        }),
        _this.value.relative
          ? ($input.div.value = _this.value.relative)
          : $input.attr("placeholder", "Relative Path"),
        ($check = $view.create("#compressed", "input")).attr(
          "type",
          "checkbox"
        ),
        $check.size(20, 20),
        $check.css({ boxSizing: "border-box", position: "relative" }),
        ($check.div.checked = !!_this.value.compressed);
      let $label = $view.create("compressed-label", "label");
      $label.attr("for", "compressed"),
        $label
          .text("Compressed")
          .fontStyle("sans-serif", 11, "#9B9C9B")
          .css({ top: -6, position: "relative" }),
        ($preview = $view.create("preview")).size("100%", 60),
        $preview.css({
          boxSizing: "border-box",
          position: "relative",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "hidden",
        }),
        ($img = $preview.create("img")).size("100%"),
        $img.css({
          position: "absolute",
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          backgroundSize: "cover",
          backgroundRepeat: "no-repeat",
          backgroundPosition: "center",
          border: "1px dotted #2e2e2e",
          boxSizing: "border-box",
        }),
        _this.value.src &&
          $img.css({ backgroundImage: `url('${_this.value.src}')` }),
        ($picker = $preview.create("picker", "input")).attr("type", "file"),
        $picker.attr("accept", "image/*"),
        $picker.css({
          opacity: 0,
          position: "absolute",
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
        });
      let copy = $preview.create("copy");
      copy.html("Drag image here<br><small>or Click to Select</small>"),
        copy
          .fontStyle("sans-serif", 11, "#9B9C9B")
          .css({ textAlign: "center" }),
        (_this.view = $view);
    }
    function getRelative() {
      return _value.relative.includes(_value.prefix)
        ? _value.relative.replace(`${_value.prefix}`, "")
        : _value.relative;
    }
    function getSrc() {
      return `${
        _value.prefix ? _value.prefix + "/" : ""
      }${_value.relative ? _value.relative + "/" : ""}${_value.filename}`;
    }
    function imageExists(url) {
      return fetch(url)
        .then((e) => 404 != e.status)
        .catch((e) =>
          console.warn("UILControlImage image url validation failed", e)
        );
    }
    function addHandlers() {
      $picker.div.addEventListener("change", change, !1),
        $picker.div.addEventListener("focus", focus, !1),
        $picker.div.addEventListener("blur", blur, !1),
        $input.div.addEventListener("change", inputChange, !1),
        ($check.div.onchange = checkChange);
    }
    function checkChange() {
      (_this.value.compressed = _value.compressed = !!$check.div.checked),
        _this.finish(!1);
    }
    async function change(e) {
      let file = $picker.div.files[0];
      file &&
        ((_value.filename = file.name),
        (_value.relative = getRelative()),
        (_value.src = getSrc()),
        (_value.compressed = !!$check.div.checked),
        (await imageExists(_value.src))
          ? ((_this.value = Object.assign({}, _value)),
            $img.attr("title", _value.src),
            $img.css({ backgroundImage: `url(${_value.src})` }),
            _this.finish())
          : (($picker.div.value = ""),
            console.warn("UIL: Could not find image", _value),
            alert(
              `"${_value.src}" not found!\nMake sure "relative path" is correct.`
            )));
    }
    function focus() {
      $img.css({ border: "1px solid #37a1ef" });
    }
    function blur() {
      $img.css({ border: "1px dotted #2e2e2e" });
    }
    function inputChange() {
      _value.relative = $input.div.value;
    }
    Inherit(this, UILControl);
    const _this = this;
    let $view, $picker, $preview, $img, $input, $check, _value;
    init(),
      initView(),
      addHandlers(),
      (this.force = function (value) {
        (_value = Object.assign({}, value)),
          ($input.div.value = _value.relative),
          $img.attr("title", _value.src),
          $img.css({ backgroundImage: `url('${_value.src}')` }),
          ($check.div.checked = _value.compressed);
      }),
      (this.onDestroy = function () {
        $picker.div.removeEventListener("change", change, !1),
          $picker.div.removeEventListener("focus", focus, !1),
          $picker.div.removeEventListener("blur", blur, !1),
          $input.div.removeEventListener("change", inputChange, !1);
      });
  }),
  Class(function UILControlNumber(_id, _opts = {}) {
    function init() {
      (_opts.value = _opts.value || 0), _this.init(_id, _opts);
    }
    function initInput() {
      (_input = _this.initClass(
        UILInputNumber,
        Object.assign(_opts, { value: _this.value })
      )).onInput((v) => (_this.value = v)),
        _input.onFinish((v) => _this.finish()),
        (_this.view = _input.input);
    }
    Inherit(this, UILControl);
    const _this = this;
    let _input;
    init(),
      initInput(),
      (this.update = function (value) {
        _input.value = _this.value || 0;
      });
  }),
  Class(function UILControlRange(_id, _opts = {}) {
    function init() {
      (_opts.value = _opts.value || 0), _this.init(_id, _opts);
    }
    function style() {
      UIL.addCSS(
        UILControlRange,
        "\n            .UILControlRange input { -webkit-appearance:none; appearance:none; }\n            .UILControlRange input::-webkit-slider-thumb { -webkit-appearance: none; }\n            .UILControlRange input::-webkit-slider-thumb { \n                -webkit-appearance:none; appearance:none;\n                width:15px; height:15px;\n                background:#FFF;\n                border-radius:15px;\n            }\n            .UILControlRange input::-moz-slider-thumb { \n                -webkit-appearance:none; appearance:none;\n                width:15px; height:15px;\n                background:#FFF;\n                border-radius:15px;\n            }\n        "
      );
    }
    function initView() {
      ($view = $("view")),
        ($slider = $view.create("range", "input")).attr("type", "range"),
        $slider.attr("max", _max),
        $slider.attr("min", _min),
        $slider.attr("step", _step),
        ($slider.div.value = _this.value),
        $slider.css({
          width: "100%",
          margin: 0,
          padding: 0,
          background: "#1d1d1d",
          height: 4,
          borderRadius: 15,
          border: "1px solid #2e2e2e",
          boxSizing: "border-box",
        }),
        (_this.view = $view);
    }
    function addHandlers() {
      $slider.div.addEventListener("change", change, !1),
        $slider.div.addEventListener("input", input, !1),
        $slider.div.addEventListener("focus", focus, !1),
        $slider.div.addEventListener("blur", blur, !1);
    }
    function change() {
      _this.finish();
    }
    function input(e) {
      _this.value = Number($slider.div.value);
    }
    function focus() {
      $slider.css({ border: "1px solid #37a1ef" });
    }
    function blur() {
      $slider.css({ border: "1px solid #2e2e2e" });
    }
    Inherit(this, UILControl);
    const _this = this;
    let $view,
      $slider,
      _max = _opts.max || 100,
      _min = _opts.min || 0,
      _step = _opts.step || 1;
    init(),
      style(),
      initView(),
      addHandlers(),
      (this.force = function (value) {
        (_this.value = value), ($slider.div.value = value), _this.finish(!1);
      }),
      (this.onDestroy = function () {
        $slider.div.removeEventListener("change", change, !1),
          $slider.div.removeEventListener("input", input, !1),
          $slider.div.removeEventListener("focus", focus, !1),
          $slider.div.removeEventListener("blur", blur, !1);
      });
  }),
  Class(function UILControlSelect(_id, _opts = {}) {
    function init() {
      if (!_opts.options) throw "UILControlSelect is missing select options";
      (_opts.value = _opts.value || _opts.options[0].value),
        _this.init(_id, _opts);
    }
    function style() {
      UIL.addCSS(
        UILControlSelect,
        "\n            .UILControlSelect select { -webkit-appearance:none; appearance:none; }\n        "
      );
    }
    function initView() {
      ($view = $("view")).css({ position: "relative" }),
        ($select = $view.create("dropdown", "select")).css({
          width: "100%",
          margin: 0,
          padding: 0,
          background: "#1d1d1d",
          height: 15,
          border: "1px solid #2e2e2e",
          boxSizing: "border-box",
          color: "#37a1ef",
          borderRadius: 0,
          height: 17,
        }),
        ($select.div.value = _this.value),
        $view
          .create("arrow")
          .text("")
          .css({
            color: "#37a1ef",
            fontSize: 6,
            position: "absolute",
            right: 8,
            top: 7,
            pointerEvents: "none",
          }),
        (_this.view = $view);
    }
    function initOptions() {
      _options = _opts.options.map(({ value: value, label: label }) => {
        let el = document.createElement("option");
        return (
          el.setAttribute("value", value),
          _this.value === value && el.setAttribute("selected", !0),
          (el.text = label || value),
          (el.value = value),
          $select.add(el),
          el
        );
      });
    }
    function addHandlers() {
      $select.div.addEventListener("change", change, !1),
        $select.div.addEventListener("input", input, !1),
        $select.div.addEventListener("focus", focus, !1),
        $select.div.addEventListener("blur", blur, !1);
    }
    function change() {
      _this.finish();
    }
    function input() {
      let i = $select.div.selectedIndex;
      _this.value = _options[i].value;
    }
    function focus() {
      $select.css({ border: "1px solid #37a1ef" });
    }
    function blur() {
      $select.css({ border: "1px solid #2e2e2e" });
    }
    Inherit(this, UILControl);
    const _this = this;
    let $view, $select, _options;
    init(),
      style(),
      initView(),
      initOptions(),
      addHandlers(),
      (this.force = function (value) {
        ($select.div.value = value), (_this.value = value);
      }),
      (this.onDestroy = function () {
        $select.div.removeEventListener("change", change, !1),
          $select.div.removeEventListener("input", input, !1),
          $select.div.removeEventListener("focus", focus, !1),
          $select.div.removeEventListener("blur", blur, !1);
      });
  }),
  Class(function UILControlText(_id, _opts = {}) {
    function initInput() {
      ($input = $("input", "input")).size("100%").bg("#1D1D1D"),
        $input.css({
          boxSizing: "border-box",
          border: "1px solid #2E2E2E",
          color: "#37A1EF",
        }),
        _this.value && ($input.div.value = _this.value || ""),
        (_this.view = $input);
    }
    function addHandlers() {
      $input.div.addEventListener("input", onChange, !1),
        $input.div.addEventListener("change", onFinishChange, !1);
    }
    function onChange(v) {
      clearTimeout(_timeout),
        (_timeout = setTimeout(onFinishChange, 400)),
        (_this.value = $input.div.value);
    }
    function onFinishChange() {
      null !== _timeout &&
        (clearTimeout(_timeout), (_timeout = null), _this.finish());
    }
    Inherit(this, UILControl);
    const _this = this;
    let $input, _timeout;
    _this.init(_id, _opts),
      initInput(),
      addHandlers(),
      (this.update = function () {
        $input.div.value = _this.value || "";
      }),
      (this.onDestroy = function () {
        $input.div.removeEventListener("input", onChange, !1),
          $input.div.removeEventListener("change", onBlur, !1);
      });
  }),
  Class(function UILControlTextarea(_id, _opts = {}) {
    function initInput() {
      ($input = $("input", "textarea")).attr("maxlength", _opts.max || 1 / 0),
        $input.attr("minlength", _opts.min || -1 / 0),
        $input.attr("rows", _opts.rows || 2),
        $input.attr("readonly", _opts.readonly || !1),
        $input.size("100%").bg("#1D1D1D"),
        $input.css({
          boxSizing: "border-box",
          resize: _opts.resize || "vertical",
          minWidth: _opts.minWidth || 0,
          border: "1px solid #2E2E2E",
          color: "#37A1EF",
        }),
        (_opts.monospace || _opts.editor) &&
          $input.css({ fontFamily: "monospace" }),
        _this.value && ($input.div.value = _this.value || ""),
        (_this.view = $input);
    }
    function enableTab() {
      $input.div.onkeydown = function (e) {
        if (9 === e.keyCode) {
          let val = this.value,
            start = this.selectionStart,
            end = this.selectionEnd;
          (this.value = val.substring(0, start) + "\t" + val.substring(end)),
            (this.selectionStart = this.selectionEnd = start + 1),
            e.preventDefault();
        }
      };
    }
    function addHandlers() {
      $input.div.addEventListener("input", onChange, !1),
        $input.div.addEventListener("change", onFinishChange, !1);
    }
    function onChange(v) {
      clearTimeout(_timeout),
        (_timeout = setTimeout(onFinishChange, 400)),
        (_this.value = $input.div.value);
    }
    function onFinishChange() {
      null !== _timeout &&
        (clearTimeout(_timeout), (_timeout = null), _this.finish());
    }
    Inherit(this, UILControl);
    const _this = this;
    let $input, _timeout;
    _this.init(_id, _opts),
      initInput(),
      _opts.editor && enableTab(),
      addHandlers(),
      (this.update = function () {
        $input.div.value = _this.value || "";
      }),
      (this.onDestroy = function () {
        $input.div.removeEventListener("input", onChange, !1),
          $input.div.removeEventListener("change", onBlur, !1);
      });
  }),
  Class(function UILControlVector(_id, _opts = {}) {
    function init() {
      if (_opts.value) _length = _vector.length;
      else {
        if (!_opts.components)
          throw 'UILControlVector: Cannot detect vector type. Define "options.components" count or init with a initial value';
        _opts.value = new Array(_opts.components).fill(0);
      }
      (_length = _opts.value.length),
        _this.init(_id, _opts),
        (_vector = [..._this.value]);
    }
    function initInputs() {
      $view = $("inputs");
      for (let i = 0; i < _length; i++) {
        let input = _this.initClass(UILInputNumber, _opts);
        (input.value = _this.value[i]),
          input.onInput((v, m) => onInput(v, i, m)),
          input.onFinish((v, m) => onFinish(v, i, m)),
          input.input.css({
            display: "inline-block",
            width: `calc(100% / ${_length})`,
          }),
          _inputs.push(input),
          $view.add(input.input);
      }
      _this.view = $view;
    }
    function onInput(value, index, master) {
      master ? (_vector = _vector.map((v) => value)) : (_vector[index] = value),
        (_this.value = [..._vector]);
    }
    function onFinish(value, index, master) {
      _this.finish();
    }
    Inherit(this, UILControl);
    const _this = this;
    let $view,
      _length,
      _inputs = [],
      _vector = [];
    init(),
      initInputs(),
      (this.force = function (value) {
        (_vector = [...value]),
          (_this.value = [..._vector]),
          _inputs.forEach((input, index) => (input.value = _this.value[index])),
          _this.finish(!1);
      }),
      (this.update = function () {
        _inputs.forEach((input, index) => (input.value = _this.value[index]));
      });
  }),
  Class(function UILInputNumber(_opts = {}) {
    function initInput() {
      ($input = $("input", "input")).attr("type", "number"),
        $input.attr("step", _step),
        $input.size("100%").bg("#1D1D1D"),
        $input.css({
          boxSizing: "border-box",
          border: "1px solid #2E2E2E",
          color: "#37A1EF",
          boxShadow: "none",
        }),
        ($input.div.value = parseFloat(_value).toFixed(_precision)),
        (_this.input = $input);
    }
    function setValue(value) {
      (value = parseFloat(value) || 0) < _min && (value = _min),
        value > _max && (value = _max),
        (_value = value),
        _onInputCB(value, _this.master);
    }
    function setValueDrag(value) {
      (void 0 === value && value === $input.div.value) ||
        (setValue(value), ($input.div.value = _value.toFixed(_precision)));
    }
    function addHandlers() {
      $input.div.addEventListener("mousedown", onMouseDown, !1),
        $input.div.addEventListener("keyup", onKeyUp, !1),
        $input.div.addEventListener("change", onFinishChange, !1),
        $input.div.addEventListener("blur", onBlur, !1),
        $input.div.addEventListener("input", onInput, !1);
    }
    function onBlur() {
      onFinishChange(),
        ($input.div.value = parseFloat(_value).toFixed(_precision));
    }
    function onKeyUp(e) {
      13 === e.keyCode && e.altKey && ((_this.master = !0), onInput());
    }
    function onInput(e) {
      (_timeout = setTimeout(onFinishChange, 400)),
        (_editing = !0),
        setValue(parseFloat($input.div.value));
    }
    function onFinishChange() {
      _editing &&
        ((_editing = !1),
        clearTimeout(_timeout),
        _onFinishCB(_value, _this.master),
        (_this.master = !1));
    }
    function onMouseDown(e) {
      (1 === e.button || (0 === e.button && e.metaKey) || e.ctrlKey) &&
        (e.preventDefault(),
        $input.css({ cursor: "col-resize" }),
        (_distance = 0),
        (_onMouseDownValue = _value),
        (_prevPointer = [e.screenX, e.screenY]),
        document.addEventListener("mousemove", onMouseMove, !1),
        document.addEventListener("mouseup", onMouseUp, !1));
    }
    function onMouseMove(e) {
      clearTimeout(_timeout), (_editing = !0);
      let currentValue = _value;
      (_pointer = [e.screenX, e.screenY]),
        (_distance +=
          _pointer[0] - _prevPointer[0] - (_pointer[1] - _prevPointer[1]));
      let value =
        _onMouseDownValue + (_distance / (e.shiftKey ? 5 : 50)) * _step;
      (value = Math.min(_max, Math.max(_min, value))),
        (_this.master = e.altKey),
        currentValue !== value && setValueDrag(value),
        (_prevPointer = [e.screenX, e.screenY]);
    }
    function onMouseUp(e) {
      onFinishChange(),
        $input.css({ cursor: "" }),
        document.removeEventListener("mousemove", onMouseMove, !1),
        document.removeEventListener("mouseup", onMouseUp, !1);
    }
    Inherit(this, Component);
    const _this = this;
    let $input,
      _timeout,
      _distance,
      _onMouseDownValue,
      _editing = !1,
      _precision = _opts.precision || 3,
      _step = _opts.step || 1,
      _min = _opts.min || -1 / 0,
      _max = _opts.max || 1 / 0,
      _value = _opts.value || 0,
      _pointer = [0, 0],
      _prevPointer = [0, 0],
      _onInputCB = () => {},
      _onFinishCB = () => {};
    initInput(),
      addHandlers(),
      this.set("value", (value) => {
        (_value = value),
          _editing ||
            ($input.div.value = parseFloat(value).toFixed(_precision));
      }),
      this.get("value", () => _value),
      (this.onInput = (cb) => (_onInputCB = cb)),
      (this.onFinish = (cb) => (_onFinishCB = cb)),
      (this.onDestroy = function () {
        $input.div.removeEventListener("mousedown", onMouseDown, !1),
          $input.div.removeEventListener("change", onFinishChange, !1),
          $input.div.removeEventListener("blur", onBlur, !1),
          $input.div.removeEventListener("input", onInput, !1);
      });
  }),
  Class(
    function UILGraph() {
      function initHTML() {
        $this
          .size("100%", "auto")
          .bg("#161616")
          .mouseEnabled(!0)
          .css({
            position: "relative",
            userSelect: "none",
            marginBottom: "4px",
            borderRadius: "4px",
          }),
          CSS.style(".UILGraphLayout > .children > .UILGraphNode", {
            width: "100%",
            marginLeft: 0,
          });
      }
      function initContextMenu() {
        (_contextMenu = new UILGraphContextMenu()), __body.add(_contextMenu);
      }
      function addHandlers() {
        _this.events.sub(UILGraph.FOCUSED, onGraphFocused),
          _this.events.sub(UILGraph.OPEN_CONTEXT_MENU, openContextMenu),
          _this.events.sub(UILGraph.CLOSE_CONTEXT_MENU, closeContextMenu);
      }
      function onGraphFocused(event) {
        closeContextMenu();
        for (let key in _layouts) {
          let node = _layouts[key];
          node.id == event.id ? node.focus() : node.unfocus();
        }
      }
      function openContextMenu(event) {
        _contextMenu.show(event);
      }
      function closeContextMenu() {
        _contextMenu.hide();
      }
      Inherit(this, Element);
      const _this = this;
      var _contextMenu,
        $this = _this.element,
        _layouts = {},
        _uniq = 0;
      UIL.sidebar &&
        (initHTML(),
        initContextMenu(),
        addHandlers(),
        UIL.sidebar &&
          UIL.sidebar.toolbar &&
          UIL.sidebar.toolbar.element.hide()),
        (this.add = function (_layout) {
          _layouts[_layout.id] ||
            ((_layouts[_layout.id] = _layout), $this.add(_layout));
        }),
        (this.getGraph = function (name, layoutInstance, isGL = !0) {
          if (!UIL.sidebar) return;
          let _graph = new UILGraphLayout({
            name: name,
            layoutInstance: layoutInstance,
            isGL: isGL,
            uniq: _uniq++,
          });
          return _this.add(_graph), _graph;
        });
    },
    "singleton",
    () => {
      (UILGraph.FOCUSED = "uilgraph_focused"),
        (UILGraph.BLURRED = "uilgraph_blurred"),
        (UILGraph.GROUP_TYPE = "uilgraph_group_type"),
        (UILGraph.LAYER_TYPE = "uilgraph_layer_type"),
        (UILGraph.SPECIAL_TYPE = "uilgraph_special_type"),
        (UILGraph.LAYOUT_TYPE = "uilgraph_layout_type"),
        (UILGraph.OPEN_CONTEXT_MENU = "uilgraph_open_context_menu"),
        (UILGraph.CLOSE_CONTEXT_MENU = "uilgraph_close_context_menu"),
        (UILGraph.ACTION_DELETE = "uilgraph_action_delete"),
        (UILGraph.ACTION_LAYER = "uilgraph_action_layer"),
        (UILGraph.ACTION_GROUP = "uilgraph_action_group"),
        (UILGraph.TREE_LAST =
          "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAVAQMAAABFfO2wAAAABlBMVEUAAAC0tLQrlfMqAAAAAXRSTlMAQObYZgAAABFJREFUCNdjaGDAh/4fYMALACnuBsCqBlYuAAAAAElFTkSuQmCC')"),
        (UILGraph.TREE_GROUP =
          "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAVAQMAAABFfO2wAAAABlBMVEUAAAC0tLQrlfMqAAAAAXRSTlMAQObYZgAAABFJREFUCNdjaGDAh/4fwK8AAHduC8BoO2AxAAAAAElFTkSuQmCC')"),
        (UILGraph.TREE_LAYER =
          "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAVAQMAAABFfO2wAAAABlBMVEUAAAC0tLQrlfMqAAAAAXRSTlMAQObYZgAAAA1JREFUCNdjaGCgBAEAUE4KgSOykIMAAAAASUVORK5CYII=')"),
        (UILGraph.EYE_ICON =
          '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>'),
        (UILGraph.CONFIG_ICON =
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 219.9 261.5"><path d="M85.6,226.6c-1.7,1-9.2,1.2-28.7,0.9l-26.4-0.3l-6.7-3.2c-12.3-5.8-20.4-16-22.7-28.7C-0.3,187.7-0.4,41.8,1,33.4\n    c1.4-8.5,5-15.6,11-21.7C17.8,6,25.3,2,32.8,0.7C35.4,0.2,56.2-0.1,79,0c41.3,0.2,41.5,0.2,46,2.5c5.6,2.9,54.2,51,57.3,56.7\n    c2.1,3.8,2.2,5.3,2.5,36.2c0.3,31.3,0.2,32.3-1.7,34.2c-2.7,2.7-7.5,2.7-10.1,0.1c-1.9-1.9-2-3.4-2-29.3c0-14.9-0.5-29-1-31.1\n    c-0.7-3.3-4.6-7.7-24.7-27.8c-13.1-13.2-25-24.6-26.5-25.4c-2.2-1.1-9.9-1.4-42.6-1.4c-45.2,0-46.1,0.1-53.5,7.4\n    c-8,7.8-7.7,3.9-7.7,91.1c0,84.9-0.1,83.3,6.2,90.9c1.7,2.1,5.4,4.9,8.2,6.2c4.9,2.3,6,2.4,29.3,2.4c16,0,25.1,0.4,26.7,1.1\n    C90.3,216.1,90.5,224,85.6,226.6z M78,85.5c27.7-0.3,29.9-0.4,31.9-2.2c2.9-2.6,2.9-8.6,0-11.2c-2-1.8-4.2-1.9-32.3-2.1\n    c-24.3-0.2-30.7,0-33.3,1.1c-6,2.7-5.7,10.7,0.3,13.2C47.6,85.6,53.4,85.8,78,85.5z M43.8,131.2h47.5c45.3,0,47.6-0.1,49.6-1.9\n    c2.7-2.5,2.8-7.9,0.1-10.6c-1.9-1.9-3.3-2-49.3-2H44.3l-2.1,2.3c-2.7,2.9-2.8,6.7-0.3,9.8L43.8,131.2z M219.8,209.8\n    c-0.5,8.9-1.4,10.4-7.6,13c-2.7,1.2-4.2,2.4-3.8,3.2c1.9,4.6,2.8,8.9,2.3,10.9c-0.8,3.1-12.4,14.7-15.5,15.5\n    c-2,0.5-6.4-0.4-10.9-2.3c-0.6-0.3-2,1.3-3.1,3.8c-1,2.4-2.6,4.9-3.5,5.6c-2.2,1.9-15.3,2.7-20.5,1.3c-3.6-1-4.6-1.9-6.8-6.2\n    c-2-4-2.9-4.9-4.2-4.4c-5.7,2.4-7.1,2.7-9.5,2.1c-3.4-0.8-14.1-10.8-15.7-14.6c-1.1-2.5-1-3.7,0.4-7.3c0.9-2.3,1.6-4.6,1.6-4.9\n    c0-0.4-2-1.6-4.4-2.7c-6-2.6-7-4.9-7-15.8c-0.1-8.3,0.2-9.4,2.3-11.7c1.3-1.4,3.9-3,5.7-3.6c3.9-1.3,3.9-1.5,1.9-6.3\n    c-0.8-2-1.5-4.5-1.5-5.6c0-2.6,7.8-12,12.9-15.5c4.3-3,5.7-3,13.6,0.1c0.9,0.3,2.3-1.4,3.9-4.6c1.7-3.3,3.4-5.2,4.9-5.5\n    c1.2-0.3,3.1-0.7,4.2-1c2.4-0.6,14.7,0.2,17,1c0.9,0.4,2.7,2.8,4.1,5.5c1.3,2.7,2.8,4.9,3.3,4.9s2.5-0.7,4.4-1.5c6-2.5,7.3-2,15.2,6\n    c8.2,8.1,8.7,9.5,5.9,16.5c-0.9,2.3-1.5,4.2-1.3,4.3c0.2,0.1,2.5,1.2,5.1,2.4C219.1,195.2,220.4,198.8,219.8,209.8z M205,207.7\n    c0-2.1-0.9-3-4.5-4.8c-4.7-2.3-8.5-7.1-8.5-10.8c0-1.2,0.7-4.1,1.5-6.4c1.4-3.9,1.4-4.5-0.1-6.1c-1.4-1.6-1.9-1.6-6-0.2\n    c-8.4,2.9-14.1,0.5-17.6-7.5c-2.6-5.7-5.8-5.8-8.3-0.3c-3.6,8.1-10.2,10.9-18,7.7c-3.7-1.6-4-1.6-5.7,0.2c-1.8,1.7-1.8,2-0.2,5.7\n    c3.2,7.8,0.4,14.4-7.7,18c-5.7,2.6-5.4,5.8,0.7,8.7c7.7,3.5,10.2,10.2,6.9,18.1c-1.3,3.2-1.3,3.6,0.5,5.2s2.2,1.7,6.2,0\n    c7.4-2.9,13.8-0.2,17.3,7.4c2.7,6,5.5,5.6,9.2-1.2c2.3-4.3,3.5-5.5,7-6.7c3.8-1.3,4.7-1.2,9.4,0.4c4.7,1.7,5.2,1.7,6.7,0.2\n    c1.5-1.4,1.5-2-0.2-6.6c-1.1-3.1-1.5-6-1.1-7.9c0.8-3.7,4.7-7.7,9.1-9.3C204.3,210.6,205,209.7,205,207.7z M175.7,228.3\n    c-12.3,5.7-25.7,1-31.3-11c-4.5-9.7-2.4-19.7,5.7-27c2.7-2.4,6.6-4.8,8.6-5.4c5.4-1.4,7.3-1.4,12.9,0.3\n    C192.2,191.3,194.9,219.3,175.7,228.3z M171.1,201.6c-3.6-3.6-7-3.7-11-0.3c-2.4,2-3.1,3.4-3.1,6c0,7.7,9.4,11.3,14.5,5.8\n    C174.9,209.4,174.8,205.3,171.1,201.6z M110,164.7c-1.9-1.9-3.3-2-34-2s-32.1,0.1-34,2c-3,3-2.7,8.3,0.6,10.9\n    c2.6,2,3.8,2.1,33.5,2.1c30.5,0,30.8,0,33.3-2.3C113,172.2,113.3,168,110,164.7z"/></svg>'),
        (UILGraph.TIMELINE_ICON =
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 248.6 232"><path d="M245.3,145.4c-6.8,26.1-24.7,51.4-46.9,66.4c-20.7,13.9-41.2,20.2-66.2,20.2c-28.7-0.1-53.1-9.2-75.7-28.5\n    c-8-6.9-21.3-22.9-20.3-24.5c0.5-0.8,16.7-12.4,20.1-14.4c0.7-0.4,3.2,2,6,5.9c12.3,16.8,33.4,29.6,55,33.4c11.5,2,31,0.9,41.4-2.5\n    c36.7-11.8,61.1-42.8,62.7-79.7c1.3-27-6.6-48.3-24.6-67.2C163,19.2,108,17.7,72.3,51c-16.1,15.1-26.2,34.7-28.2,55.1l-0.7,7.1\n    l9.7-0.5c5.3-0.2,9.6-0.2,9.6,0s-7.3,9.5-16.1,20.8l-16.1,20.4l-15.2-20.2L0,113.4l8.2-0.3l8.2-0.3l0.7-7.9\n    C20.2,67.1,45.3,30.3,80,12.8c9.7-4.9,23-9.4,33.3-11.3c9.4-1.7,26.3-2,35.4-0.6c46.2,7,83.7,40,95.9,84.1\n    C249.7,103.8,250,127.2,245.3,145.4z M141.9,83.7L141.7,59l-2.7-2c-3.7-3-9.7-2.8-12.8,0.4l-2.5,2.4v31.1V122l2.5,2.4l2.4,2.5h30.5\n    c29.9,0,30.6,0,32.5-2.1c2.9-3.1,3.5-7.1,1.7-11.3c-0.8-2-1.6-3.7-1.8-3.8c-0.2-0.1-11.3-0.5-24.8-0.8l-24.5-0.5L141.9,83.7z\n     M87.1,66.9l-3.4,3.5l-3.4,3.5l6.9,7l7,7l3.5-3.5l3.5-3.5l-7-7L87.1,66.9z M171.7,88.4l7-7l7-7.1l-3.8-3.7l-3.8-3.7l-6.9,7l-7,7\n    l3.8,3.7L171.7,88.4z M67.7,110.9v5v5h10h10v-5v-5h-10H67.7z M90.2,152.9l-7,7l3.5,3.5l3.5,3.5l7-7l7-7l-3.5-3.5l-3.5-3.5\n    L90.2,152.9z M164.7,149.4l-3.4,3.5l6.9,7l6.9,7l3.8-3.7l3.8-3.7l-6.7-6.8c-3.7-3.7-7-6.8-7.3-6.8S166.6,147.5,164.7,149.4z\n     M127.7,170.4v9.5h5h5v-9.5v-9.5h-5h-5V170.4z"/></svg>');
    }
  ),
  Class(
    function UILGraphContextMenu() {
      function initHTML() {
        $this
          .size(160, "auto")
          .bg("#ADADAD")
          .fontStyle("sans-serif", 12, "black")
          .css({
            position: "absolute",
            borderRadius: 3,
            lineHeight: 25,
            overflow: "hidden",
            userSelect: "none",
          })
          .setZ(999999),
          ($addLayer = $this
            .create("context-button")
            .size("100%", 25)
            .css({
              cursor: "default",
              position: "relative",
              boxSizing: "border-box",
              padding: "0 20px",
              userSelect: "none",
            })).text("Add layer"),
          $addLayer.attr("data-action", UILGraphContextMenu.ADD_LAYER),
          $addLayer.hover(onHover),
          $addLayer.click(onClick),
          ($addGroup = $this
            .create("context-button")
            .size("100%", 25)
            .css({
              cursor: "default",
              position: "relative",
              boxSizing: "border-box",
              borderBottom: "1px solid #9c9c9c",
              padding: "0 20px",
              userSelect: "none",
            })).text("Add group"),
          $addGroup.attr("data-action", UILGraphContextMenu.ADD_GROUP),
          $addGroup.hover(onHover),
          $addGroup.click(onClick),
          ($delete = $this
            .create("context-button")
            .size("100%", 25)
            .css({
              cursor: "default",
              position: "relative",
              boxSizing: "border-box",
              borderBottom: "1px solid #9c9c9c",
              padding: "0 20px",
              userSelect: "none",
            })).text("Delete"),
          $delete.attr("data-action", UILGraphContextMenu.DELETE),
          $delete.hover(onHover),
          $delete.click(onClick);
      }
      function addHandlers() {
        window.addEventListener("keyup", onKey, !1);
      }
      function removeHandlers() {
        window.removeEventListener("keyup", onKey, !1);
      }
      function onKey(event) {
        "escape" == event.key.toLowerCase() && close();
      }
      function onHover(event) {
        let $el = event.currentTarget.hydraObject;
        switch (event.action) {
          case "over":
            $el.bg("#525252"), $el.css({ color: "white" });
            break;
          case "out":
            $el.css({ color: "" }), $el.bg("transparent");
        }
      }
      function onClick(event) {
        _this.events.fire(UILGraphContextMenu.ACTION, {
          type: event.currentTarget.hydraObject.attr("data-action"),
          layoutId: _targetLayout,
          targetId: _targetNode,
        }),
          close();
      }
      function close() {
        _this.events.fire(UILGraph.CLOSE_CONTEXT_MENU);
      }
      Inherit(this, Element);
      const _this = this;
      var $delete,
        $addGroup,
        $addLayer,
        _targetLayout,
        _targetNode,
        $this = _this.element,
        _isHidden = !0;
      $this.hide(),
        $this.mouseEnabled(!1),
        initHTML(),
        (this.show = function (event) {
          (_isHidden = !1),
            $delete.hide(),
            $addGroup.hide(),
            $addLayer.hide(),
            (_targetLayout = event.layoutId),
            (_targetNode = event.targetId),
            $this.mouseEnabled(!0),
            removeHandlers(),
            addHandlers();
          let x = Mouse.x + 5;
          x > Stage.width - 160 && (x = Mouse.x - 160 - 5);
          let y = Mouse.y + 5;
          switch (
            (y > Stage.height - 75 && (y = Mouse.y - 75 - 5),
            $this.transform({ x: x, y: y }),
            event.type)
          ) {
            case UILGraph.GROUP_TYPE:
              $delete.show(), $addLayer.show();
              break;
            case UILGraph.LAYOUT_TYPE:
              $addGroup.show(), $addLayer.show();
              break;
            case UILGraph.LAYER_TYPE:
              $delete.show();
              break;
            case UILGraph.SPECIAL_TYPE:
          }
          $this.show(), $this.div.focus();
        }),
        (this.hide = function () {
          _isHidden ||
            ((_isHidden = !0),
            (_targetLayout = null),
            (_targetNode = null),
            removeHandlers(),
            $this.mouseEnabled(!1),
            $this.hide());
        });
    },
    () => {
      (UILGraphContextMenu.ACTION = "uilgraph_action"),
        (UILGraphContextMenu.DELETE = "uilgraph_delete"),
        (UILGraphContextMenu.ADD_LAYER = "uilgraph_add_layer"),
        (UILGraphContextMenu.ADD_GROUP = "uilgraph_add_group");
    }
  ),
  Class(function UILGraphNode(_title, _type) {
    function initHTML() {}
    Inherit(this, Element);
    initHTML();
  }),
  Class(function UILGraphGroup(_layoutId, _opts) {
    function initHTML() {
      $this
        .size(300, "auto")
        .fontStyle("sans-serif", 11, "#B1B1B1")
        .css({
          position: "relative",
          width: "calc(100% - 18px)",
          marginLeft: 18,
        }),
        $this.div.classList.add("UILGraphNode");
    }
    function initGroup() {
      ($header = $this.create("header", "a")).attr("tabindex", "1"),
        $header.size("100%", "auto"),
        $header.css({
          outline: "none",
          display: "block",
          padding: "0 4px",
          boxSizing: "border-box",
          userSelect: "none",
        });
      let $toggleWrapper = $header
        .create("toggle-wrapper")
        .size(15, 21)
        .css({
          position: "relative",
          display: "inline-block",
          verticalAlign: "middle",
          marginLeft: 4,
        });
      ($tree = $toggleWrapper
        .create("tree")
        .size(10, 21)
        .css({ position: "absolute", left: 0, top: 0 })),
        ($toggle = $toggleWrapper
          .create("toggle")
          .bg("#1b1b1b")
          .css({
            fontSize: 9,
            textAlign: "center",
            display: "inline-block",
            verticalAlign: "top",
            position: "relative",
            borderRadius: "50%",
            border: "1px solid #b1b1b1",
            boxSizing: "border-box",
            marginLeft: -6,
            top: 4,
          })
          .size(13, 13)).text(_isOpen ? "-" : "+"),
        ($visibility = $header.create("visibility"))
          .html(UILGraph.EYE_ICON)
          .size(10, 10)
          .css({
            position: "absolute",
            right: 24,
            top: 6,
            cursor: "pointer",
            opacity: _visible ? 1 : 0.3,
          }),
        ($drag = $header.create("drag"))
          .text("")
          .css({
            position: "absolute",
            right: 7,
            top: 3,
            display: "inline-block",
            cursor: "move",
          }),
        ($title = $header.create("title")).text(_opts.name),
        $title.css({
          display: "inline-block",
          verticalAlign: "middle",
          fontWeight: "bold",
        }),
        ($titleField = $header
          .create("title-field", "input")
          .bg("#b1b1b1")
          .css({
            position: "absolute",
            display: "inline-block",
            verticalAlign: "middle",
            fontWeight: "bold",
            color: "#272727",
            width: 80,
            left: 36,
            border: 0,
            outline: "none",
            top: 2,
          })
          .setZ(1)
          .hide()).val(_this.name),
        ($children = $this.create("children").css({ overflow: "hidden" }));
    }
    function addHandlers() {
      $toggle.click(onToggle),
        $header.div.addEventListener("focus", onFocus, !1),
        _this.events.sub(UILGraphNode.FOCUSED, onAnyNodeFocus),
        $title.div.addEventListener("dblclick", showTitleEditor, !1),
        $titleField.div.addEventListener("keyup", onKey, !1),
        $titleField.div.addEventListener("blur", hideTitleEditor, !1),
        $visibility.click(toggleVisibility),
        $drag.div.addEventListener("mousedown", enableDrag, !1),
        window.addEventListener("mouseup", disableDrag, !1),
        $this.div.addEventListener("dragstart", onDragStart, !1),
        $this.div.addEventListener("dragend", onDragEnd, !1),
        $this.div.addEventListener("dragover", onDragOver, !1),
        $this.div.addEventListener("dragenter", onDragEnter, !1),
        $this.div.addEventListener("dragleave", onDragLeave, !1),
        $this.div.addEventListener("drop", onDrop, !1),
        $header.div.addEventListener("contextmenu", openMenu);
    }
    function openMenu(event) {
      event.preventDefault(),
        _this.events.fire(UILGraph.OPEN_CONTEXT_MENU, {
          layoutId: _layoutId,
          targetId: _this.id,
          type: UILGraph.GROUP_TYPE,
        });
    }
    function enableDrag() {
      (_isDragging = !0), $this.attr("draggable", "true");
    }
    function disableDrag() {
      _isDragging && ((_isDragging = !1), $this.attr("draggable", "false"));
    }
    function onDragStart(event) {
      event.stopPropagation(),
        event.dataTransfer.setData("text/plain", _this.id),
        (event.dataTransfer.effectAllowed = "move"),
        (event.dropEffect = "move"),
        $this.css({ opacity: 0.25 });
    }
    function onDragEnter() {
      $this.bg("#2b2b2b");
    }
    function onDragOver(event) {
      event.stopPropagation(),
        event.preventDefault(),
        (event.dataTransfer.dropEffect = "move");
    }
    function onDragLeave() {
      $this.bg("transparent");
    }
    function onDrop(event) {
      event.stopPropagation();
      var data = event.dataTransfer.getData("text");
      _this.events.fire(UILGraphLayout.MOVE_NODE, {
        id: data,
        anchor: _this.id,
        layoutId: _layoutId,
      });
    }
    function onDragEnd(event) {
      $this.css({ opacity: 1 });
    }
    function onKey(event) {
      return "enter" == event.key.toLowerCase()
        ? onTitleValidate(event)
        : "escape" == event.key.toLowerCase()
        ? hideTitleEditor()
        : void 0;
    }
    function showTitleEditor() {
      (_hasTitleInput = !0),
        $titleField.show(),
        $titleField.div.focus(),
        $titleField.div.select();
    }
    function onTitleValidate(event) {
      let previousName = _this.name;
      (_this.name = $titleField.val()),
        $title.text(_this.name),
        _this.events.fire(UILGraphNode.RENAMED, {
          layoutId: _layoutId,
          id: _this.id,
          name: previousName,
          value: _this.name,
        }),
        hideTitleEditor();
    }
    function hideTitleEditor() {
      (_hasTitleInput = !1), $titleField.hide();
    }
    function open() {
      (_isOpen = !0), $children.show(), $toggle.text("-");
    }
    function close() {
      $children.hide(),
        $toggle.text("+"),
        (_isOpen = !1),
        _hasTitleInput && hideTitleEditor();
    }
    function onToggle() {
      if (!_isFocused) return open();
      _isOpen ? close() : open();
    }
    function toggleVisibility(event) {
      event.preventDefault(),
        event.stopPropagation(),
        (_visible = !_visible),
        $visibility.css({ opacity: _visible ? 1 : 0.3 }),
        _this.events.fire(UILGraphNode.TOGGLE_VISIBILITY, {
          layoutId: _layoutId,
          id: _this.id,
          name: _this.name,
          visible: _visible,
        });
    }
    function onFocus() {
      $title.css({ color: "white" }),
        $header.bg("#2c2c2c"),
        _this.events.fire(UILGraphNode.FOCUSED, {
          layoutId: _layoutId,
          id: _this.id,
          name: _this.name,
        }),
        (_isFocused = !0);
    }
    function onAnyNodeFocus(event) {
      _isFocused && event.id != _this.id && onBlur();
    }
    function onBlur() {
      $title.css({ color: "" }),
        $header.bg("transparent"),
        _this.events.fire(UILGraphNode.BLURRED, {
          layoutId: _layoutId,
          id: _this.id,
          name: _this.name,
        }),
        (_isFocused = !1);
    }
    function updateSort(index, total) {
      _this.sortOrder = index;
      let isLast = index === total - 1;
      $tree.css({
        background: isLast ? UILGraph.TREE_LAST : UILGraph.TREE_GROUP,
      }),
        isLast
          ? $children.css({ background: "none" })
          : $children.css({
              background: UILGraph.TREE_LAYER,
              backgroundRepeat: "repeat-y",
              backgroundSize: "10px auto",
              backgroundPosition: "8px 0",
            });
      let children = Object.values(_children)
        .map(function (node, i, all) {
          let sortOrder = Array.from($children.div.children).indexOf(
            node.element.div
          );
          return node.updateSort(sortOrder, all.length);
        })
        .sort(function (idA, idB) {
          let nodeA = find(idA.id || idA),
            nodeB = find(idB.id || idB);
          return nodeA.sortOrder - nodeB.sortOrder;
        });
      return { id: _this.id, children: children };
    }
    function find(id) {
      for (let key in _children) {
        let node = _children[key];
        if (node.id == id || node.name == id) return node;
        if (node.isGraphGroup && (node = node.find(id))) return node;
      }
    }
    Inherit(this, Element);
    const _this = this;
    var $header,
      $tree,
      $title,
      $titleField,
      $children,
      $toggle,
      $visibility,
      $drag,
      $this = _this.element,
      _children = {},
      _isOpen = !0,
      _isFocused = !1,
      _hasTitleInput = !1,
      _isDragging = !1,
      _visible = !0;
    (_this.id = _opts.id),
      (_this.name = _opts.name),
      (_this.isGraphGroup = !0),
      (_this.sortOrder = _opts.order),
      initHTML(),
      initGroup(),
      addHandlers(),
      (this.add = function (child, append = !0) {
        (_children[child.id] = child),
          (child.parent = this),
          !0 === append && $children.add(child);
      }),
      (this.remove = function (child, remove = !0) {
        delete _children[child.id],
          (child.parent = null),
          !0 === remove &&
            (child.isGraphGroup && child.removeAllChildren(),
            $children.removeChild(child.element));
      }),
      (this.removeAllChildren = function () {
        for (let key in _children) {
          let child = _children[key];
          this.remove(child);
        }
      }),
      (this.restoreSort = function (order, isGL) {
        order.forEach(function (id, i) {
          let node = find(id.id || id);
          node
            ? ((node.sortOrder = isGL ? (i + 1) / (order.length + 1) : i),
              $children.div.appendChild(node.element.div),
              node.isGraphGroup && node.restoreSort(order[i].children, isGL))
            : console.warn(
                `[UILGraph] couldn't find ${id.id || id} in ${_this.id}`
              );
        }),
          updateSort();
      }),
      (this.syncVisibility = function (layers) {
        for (let key in layers) {
          let node = find(key);
          if (!node) continue;
          let mesh = layers[key];
          node.isGraphGroup && node.syncVisibility(layers),
            (node.visible = !!mesh.visible);
        }
      }),
      this.set("visible", (value) => {
        (_visible = value), $visibility.css({ opacity: _visible ? 1 : 0.3 });
      }),
      (this.focus = onFocus),
      (this.updateSort = updateSort),
      (this.find = find),
      this.get("length", () => Object.keys(_children).length);
  }),
  Class(function UILGraphLayer(_layoutId, _opts) {
    function initHTML() {
      $this
        .size(300, "auto")
        .fontStyle("sans-serif", 11, "#B1B1B1")
        .css({
          position: "relative",
          width: "calc(100% - 18px)",
          marginLeft: 18,
        }),
        $this.div.classList.add("UILGraphNode");
    }
    function initLayer() {
      ($header = $this.create("header", "a")).attr("tabindex", "1"),
        $header.size("100%", "auto"),
        $header.css({
          outline: "none",
          display: "block",
          padding: "0 4px",
          boxSizing: "border-box",
          userSelect: "none",
        });
      let $toggleWrapper = $header
        .create("toggle-wrapper")
        .size(10, 21)
        .css({
          position: "relative",
          display: "inline-block",
          verticalAlign: "middle",
          marginLeft: 4,
        });
      if (_isSpecial) {
        let isTimeline = _this.name.toLowerCase().indexOf("timeline") > -1;
        $toggleWrapper
          .create("icon")
          .html(isTimeline ? UILGraph.TIMELINE_ICON : UILGraph.CONFIG_ICON)
          .size(10, 10)
          .css({
            position: "relative",
            display: "inline-block",
            verticalAlign: "middle",
            fill: "white",
            marginLeft: isTimeline ? 13 : 14,
            top: 2,
          });
      }
      ($tree = $toggleWrapper
        .create("tree")
        .size(10, 21)
        .css({ position: "absolute", left: 0, top: 0 })),
        _isSpecial ||
          (($visibility = $header.create("visibility"))
            .html(UILGraph.EYE_ICON)
            .size(10, 10)
            .css({
              position: "absolute",
              right: 24,
              top: 6,
              cursor: "pointer",
              opacity: _visible ? 1 : 0.3,
            }),
          ($drag = $header.create("drag"))
            .text("")
            .css({
              position: "absolute",
              right: 7,
              top: 3,
              display: "inline-block",
              cursor: "move",
            })),
        ($title = $header.create("title")).text(_opts.name),
        $title.css({
          display: "inline-block",
          verticalAlign: "middle",
          marginLeft: _isSpecial ? 18 : 4,
        }),
        _isSpecial ||
          ($titleField = $header
            .create("title-field", "input")
            .bg("#b1b1b1")
            .css({
              position: "absolute",
              display: "inline-block",
              verticalAlign: "middle",
              fontWeight: "bold",
              color: "#272727",
              width: 80,
              left: 21,
              border: 0,
              outline: "none",
              top: 2,
            })
            .setZ(1)
            .hide()).val(_this.name);
    }
    function addHandlers() {
      $header.div.addEventListener("focus", onFocus, !1),
        _this.events.sub(UILGraphNode.FOCUSED, onAnyNodeFocus),
        _isSpecial ||
          ($title.div.addEventListener("dblclick", showTitleEditor, !1),
          $titleField.div.addEventListener("keyup", onKey, !1),
          $titleField.div.addEventListener("blur", hideTitleEditor, !1),
          $visibility.click(toggleVisibility),
          $drag.div.addEventListener("mousedown", enableDrag, !1),
          window.addEventListener("mouseup", disableDrag, !1),
          $this.div.addEventListener("dragstart", onDragStart, !1),
          $this.div.addEventListener("dragend", onDragEnd, !1),
          $this.div.addEventListener("dragover", onDragOver, !1),
          $this.div.addEventListener("dragenter", onDragEnter, !1),
          $this.div.addEventListener("dragleave", onDragLeave, !1),
          $this.div.addEventListener("drop", onDrop, !1),
          $header.div.addEventListener("contextmenu", openMenu));
    }
    function openMenu(event) {
      event.preventDefault(),
        _this.events.fire(UILGraph.OPEN_CONTEXT_MENU, {
          layoutId: _layoutId,
          targetId: _this.id,
          type: _isSpecial ? UILGraph.SPECIAL_TYPE : UILGraph.LAYER_TYPE,
        });
    }
    function enableDrag() {
      (_isDragging = !0), $this.attr("draggable", "true");
    }
    function disableDrag() {
      _isDragging && ((_isDragging = !1), $this.attr("draggable", "false"));
    }
    function onDragStart(event) {
      event.stopPropagation(),
        event.dataTransfer.setData("text/plain", _this.id),
        (event.dataTransfer.effectAllowed = "move"),
        (event.dropEffect = "move"),
        $this.css({ opacity: 0.25 });
    }
    function onDragEnter() {
      $visibility.mouseEnabled(!1), $drag.mouseEnabled(!1), $this.bg("#2b2b2b");
    }
    function onDragOver(event) {
      event.stopPropagation(),
        event.preventDefault(),
        (event.dataTransfer.dropEffect = "move");
    }
    function onDragLeave() {
      $visibility.mouseEnabled(!0),
        $drag.mouseEnabled(!0),
        $this.bg("transparent");
    }
    function onDrop(event) {
      event.stopPropagation(),
        $visibility.mouseEnabled(!0),
        $drag.mouseEnabled(!0),
        $this.bg("transparent");
      var data = event.dataTransfer.getData("text");
      _this.events.fire(UILGraphLayout.MOVE_NODE, {
        id: data,
        anchor: _this.id,
        layoutId: _layoutId,
      });
    }
    function onDragEnd(event) {
      $this.css({ opacity: 1 }), $this.bg("#2c2c2c");
    }
    function onKey(event) {
      return "enter" == event.key.toLowerCase()
        ? onTitleValidate(event)
        : "escape" == event.key.toLowerCase()
        ? hideTitleEditor()
        : void 0;
    }
    function showTitleEditor() {
      (_hasTitleInput = !0),
        $titleField.show(),
        $titleField.div.focus(),
        $titleField.div.select();
    }
    function onTitleValidate(event) {
      let previousName = _this.name;
      (_this.name = $titleField.val()),
        $title.text(_this.name),
        _this.events.fire(UILGraphNode.RENAMED, {
          layoutId: _layoutId,
          id: _this.id,
          name: previousName,
          value: _this.name,
        }),
        hideTitleEditor();
    }
    function hideTitleEditor() {
      (_hasTitleInput = !1), $titleField.hide();
    }
    function toggleVisibility(event) {
      event.preventDefault(),
        event.stopPropagation(),
        (_visible = !_visible),
        $visibility.css({ opacity: _visible ? 1 : 0.3 }),
        _this.events.fire(UILGraphNode.TOGGLE_VISIBILITY, {
          layoutId: _layoutId,
          id: _this.id,
          name: _this.name,
          visible: _visible,
        });
    }
    function onFocus() {
      $title.css({ color: "white" }),
        $this.bg("#2c2c2c"),
        _this.events.fire(UILGraphNode.FOCUSED, {
          layoutId: _layoutId,
          id: _this.id,
          name: _this.name,
        }),
        (_isFocused = !0);
    }
    function onAnyNodeFocus(event) {
      _isFocused && event.id != _this.id && onBlur();
    }
    function onBlur() {
      $title.css({ color: "" }),
        $this.bg("transparent"),
        _this.events.fire(UILGraphNode.BLURRED, {
          layoutId: _layoutId,
          id: _this.id,
          name: _this.name,
        }),
        (_isFocused = !1);
    }
    Inherit(this, Element);
    const _this = this;
    var $header,
      $tree,
      $title,
      $titleField,
      $visibility,
      $drag,
      $this = _this.element,
      _visible = !0,
      _hasTitleInput = !1,
      _isDragging = !1,
      _isFocused = !1,
      _isSpecial = !0 === _opts.isSpecial;
    (_this.id = _opts.id),
      (_this.name = _opts.name),
      (_this.isGraphLayer = !0),
      (_this.sortOrder = _opts.order),
      initHTML(),
      initLayer(),
      addHandlers(),
      (this.updateSort = function (index, total) {
        _this.sortOrder = index;
        let isLast = index === total - 1;
        return (
          $tree.css({
            background: _isSpecial
              ? UILGraph.TREE_LAYER
              : isLast
              ? UILGraph.TREE_LAST
              : UILGraph.TREE_GROUP,
          }),
          _this.id
        );
      }),
      this.set("visible", (value) => {
        (_visible = value), $visibility.css({ opacity: _visible ? 1 : 0.3 });
      }),
      this.get("isSpecial", () => _isSpecial),
      (this.focus = onFocus);
  }),
  Class(
    function UILGraphLayout(_opts) {
      function initHTML() {
        $this
          .size("100%", "auto")
          .mouseEnabled(!0)
          .fontStyle("sans-serif", 11, "#B1B1B1")
          .css({
            position: "relative",
            borderRadius: "4px",
            marginBottom: "3px",
            background:
              "repeating-linear-gradient(0deg, #1c1c1c, #1c1c1c 21px, #202020 21px, #202020 42px)",
          });
      }
      function initLayout() {
        ($header = $this.create("header", "a")).attr("tabindex", "1"),
          $header.size("100%", "auto"),
          $header.bg("#272727"),
          $header.css({
            outline: "none",
            display: "block",
            padding: "4px 4px",
            boxSizing: "border-box",
            userSelect: "none",
          }),
          ($toggle = $header
            .create("toggle")
            .size(2, 2)
            .css({
              fontSize: 9,
              textAlign: "center",
              display: "inline-block",
              verticalAlign: "middle",
              position: "relative",
              border: "1px solid #b1b1b1",
              borderRadius: "50%",
              marginLeft: 2,
            })),
          ($title = $header.create("title")).text(_opts.name),
          $title.css({
            display: "inline-block",
            verticalAlign: "middle",
            marginLeft: 6,
            fontWeight: "bold",
          }),
          ($children = $this
            .create("children")
            .css({
              overflow: "hidden",
              transition: "filter 0.1s linear",
              filter: "brightness(0.6)",
            })).mouseEnabled(!1),
          $children.hide();
      }
      function find(id) {
        if (id)
          for (let key in _children) {
            let node = _children[key];
            if (node.id == id || node.name == id) return node;
            if (node.isGraphGroup && (node = node.find(id))) return node;
          }
      }
      function addHandlers() {
        _this.events.sub(UILGraphLayout.MOVE_NODE, moveNode),
          _this.events.sub(UILGraphContextMenu.ACTION, onMenuAction),
          $header.div.addEventListener("contextmenu", openMenu),
          _this.events.sub(UILGraphNode.FOCUSED, onNodeFocused),
          _this.events.sub(UILGraphNode.BLURRED, onNodeBlurred),
          _this.events.sub(UILGraphNode.TOGGLE_VISIBILITY, onNodeVisibility),
          _this.events.sub(UILGraphNode.RENAMED, onNodeRenamed),
          $header.click(onToggle),
          $this.click(onFocus);
      }
      function onNodeFocused(event) {
        event.layoutId == _this.id &&
          (_layoutInstance._focus(event.id),
          (_focusedLayer = event.id),
          saveState());
      }
      function onNodeBlurred(event) {
        event.layoutId == _this.id && _layoutInstance._blur(event.id);
      }
      function onNodeVisibility(event) {
        event.layoutId == _this.id &&
          _layoutInstance._visible(event.name, event.visible);
      }
      function onNodeRenamed(event) {
        if (event.layoutId != _this.id) return;
        let target = find(event.id);
        _layoutInstance.isSceneLayout &&
          target.isGraphGroup &&
          ((target.id =
            target.id.slice(0, target.id.length - event.name.length) +
            event.value),
          (_children[target.id] = target),
          delete _children[event.id]),
          _layoutInstance._rename(event.id, event.name, event.value);
      }
      function openMenu(event) {
        event.preventDefault(),
          _this.events.fire(UILGraph.OPEN_CONTEXT_MENU, {
            layoutId: _this.id,
            targetId: _this.id,
            type: UILGraph.LAYOUT_TYPE,
          });
      }
      function onMenuAction(event) {
        if (event.layoutId != _this.id) return;
        let node = find(event.targetId) || _this;
        switch (event.type) {
          case UILGraphContextMenu.DELETE:
            _layoutInstance._deleteLayer(node.id, node.name) &&
              _this.remove(node, !0);
            break;
          case UILGraphContextMenu.ADD_LAYER:
            _layoutInstance._createLayer(
              node.id != _this.id ? node.name : null
            );
            break;
          case UILGraphContextMenu.ADD_GROUP:
            _layoutInstance._createGroup(
              node.id != _this.id ? node.name : null
            );
        }
        updateSort();
      }
      function onToggle() {
        _isOpen ? close() : (onFocus(event, !0), open());
      }
      function open() {
        (_isOpen = !0), $children.show(), saveState();
      }
      function close() {
        (_isOpen = !1), $children.hide(), saveState();
      }
      function onFocus(event, force) {
        (!0 !== force && event.path.indexOf($header.div) > -1) ||
          _this.events.fire(UILGraph.FOCUSED, { id: _this.id });
      }
      function updateSort() {
        let length = Object.keys(_children).length,
          order = [];
        for (let key in _children) {
          let node = _children[key],
            sortOrder = Array.from($children.div.children).indexOf(
              node.element.div
            );
          order[sortOrder] = node.updateSort(sortOrder, length);
        }
        (_order = order), _layoutInstance._sort(order), saveState();
      }
      function moveNode(event) {
        if (event.layoutId != _this.id) return;
        let toMove = find(event.id),
          beforeEl = find(event.anchor);
        toMove.parent.id != beforeEl.parent.id &&
          changeParent(toMove, beforeEl.parent),
          beforeEl.element.div.parentNode.insertBefore(
            toMove.element.div,
            beforeEl.element.div
          ),
          updateSort();
      }
      function changeParent(object, newParent) {
        object.parent.remove(object, !1),
          newParent.add(object, !1),
          _layoutInstance._changeParent(
            object.id,
            object.name,
            newParent.id,
            newParent.name
          );
      }
      function saveState() {
        if (!_saveEnabled) return;
        let state = {
          isOpen: _isOpen,
          isFocused: _isFocused,
          focusedLayer: _focusedLayer,
          order: _order,
        };
        UILStorage.set(`UIL_graph_${_this.id}`, JSON.stringify(state));
      }
      function restoreState() {
        let data = UILStorage.get(`UIL_graph_${_this.id}`);
        if (data) {
          let state = JSON.parse(data);
          if (
            (state.isFocused && _this.focus(!0),
            state.isOpen && open(),
            state.order && restoreSort(state.order),
            state.focusedLayer)
          ) {
            let node = find(state.focusedLayer);
            node && node.focus();
          }
        }
      }
      function restoreSort(order) {
        order.forEach(function (id, i) {
          let node = find(id && id.id ? id.id : id);
          node &&
            ((node.sortOrder = i),
            $children.div.appendChild(node.element.div),
            node.isGraphGroup && node.restoreSort(order[i].children, _isGL));
        }),
          updateSort();
      }
      Inherit(this, Element);
      const _this = this;
      var $header,
        $title,
        $children,
        $toggle,
        _focusedLayer,
        $this = _this.element,
        _isOpen = !1,
        _isFocused = !1,
        _saveEnabled = !1,
        _isGL = !0 === _opts.isGL,
        _children = {},
        _layoutInstance = _opts.layoutInstance,
        _order = [];
      (_this.id = _opts.id || `${_opts.name.toLowerCase()}-${_opts.uniq}`),
        (_this.name = _opts.name),
        (async function () {
          initHTML(),
            initLayout(),
            addHandlers(),
            defer(async () => {
              await _layoutInstance.ready(),
                restoreState(),
                (_saveEnabled = !0);
            });
        })(),
        (this.add = function (child, append = !0) {
          (_children[child.id] = child),
            (child.parent = this),
            !0 === append &&
              (child.isSpecial
                ? $children.div.insertBefore(
                    child.element.div,
                    $children.div.firstChild
                  )
                : $children.add(child));
        }),
        (this.open = function () {
          open(), this.focus();
        }),
        (this.remove = function (child, remove = !0) {
          if (child.parent)
            if (_children[child.id])
              delete _children[child.id],
                (child.parent = null),
                !0 === remove &&
                  (child.isGraphGroup && child.removeAllChildren(),
                  $children.removeChild(child.element));
            else {
              let parent = find(child.parent.id);
              if (!parent) return;
              parent.remove(child, remove);
            }
        }),
        (this.focus = function (restore = !1) {
          (_isFocused = !0),
            $children.css({ filter: "" }),
            $title.css({ color: "white" }),
            $children.mouseEnabled(!0),
            restore || open(),
            saveState();
        }),
        (this.unfocus = function () {
          (_isFocused = !1),
            $children.css({ filter: "brightness(0.6)" }),
            $title.css({ color: "" }),
            $children.mouseEnabled(!1),
            saveState();
        }),
        (this.updateSort = updateSort),
        (this.addGroup = function (id, name, parentId) {
          let parent = find(parentId) || _this,
            group = new UILGraphGroup(_this.id, { id: id, name: name });
          parent.add(group), _saveEnabled && group.focus(), updateSort();
        }),
        (this.addLayer = function (id, name, parentId) {
          let parent = find(parentId) || _this,
            layer = new UILGraphLayer(_this.id, { id: id, name: name });
          parent.add(layer), _saveEnabled && layer.focus(), updateSort();
        }),
        (this.addSpecial = function (id, name, label) {
          _this.add(
            new UILGraphLayer(_this.id, {
              id: id,
              name: label || name,
              isSpecial: !0,
            })
          ),
            updateSort();
        }),
        (this.syncVisibility = function (layers) {
          for (let key in layers) {
            let node = find(key);
            if (!node) continue;
            let mesh = layers[key];
            (mesh = mesh.group || mesh),
              node.isGraphGroup && node.syncVisibility(layers),
              (node.visible = !!mesh.visible);
          }
        });
    },
    () => {
      UILGraphLayout.MOVE_NODE = "uilgraph_move_node";
    }
  ),
  Class(
    function UILGraphNode() {
      Inherit(this, Component);
    },
    () => {
      (UILGraphNode.FOCUSED = "uilgraphnode_focused"),
        (UILGraphNode.BLURRED = "uilgraphnode_blurred"),
        (UILGraphNode.RENAMED = "uilgraphnode_renamed"),
        (UILGraphNode.TOGGLE_VISIBILITY = "uilgraphnode_toggle_visibility");
    }
  ),
  Namespace("FX"),
  FX.Class(function UnrealBloom(_nuke = World.NUKE, options = {}) {
    function initRTs() {
      let pars = {
          minFilter: Texture.LINEAR,
          magFilter: Texture.LINEAR,
          format: Texture.RGBAFormat,
        },
        resx = Math.round(_this.resolution.x / 2),
        resy = Math.round(_this.resolution.y / 2);
      (_this.renderTargetBright = new RenderTarget(resx, resy, pars)),
        (_this.renderTargetBright.texture.generateMipmaps = !1);
      for (let i = 0; i < _nMips; i++) {
        let renderTargetHorizonal = new RenderTarget(resx, resy, pars);
        (renderTargetHorizonal.texture.generateMipmaps = !1),
          _renderTargetsHorizontal.push(renderTargetHorizonal);
        let renderTargetVertical = new RenderTarget(resx, resy, pars);
        (renderTargetVertical.texture.generateMipmaps = !1),
          _renderTargetsVertical.push(renderTargetVertical),
          (resx = Math.round(resx / 2)),
          (resy = Math.round(resy / 2));
      }
      (_this.outputTexture = _renderTargetsHorizontal[0].texture),
        (_this.uniforms.tUnrealBloom.value =
          _renderTargetsHorizontal[0].texture);
    }
    function initScene() {
      (_triangleGeometry = World.QUAD),
        (_luminosityShader = _this.initClass(Shader, "UnrealBloomLuminosity", {
          tDiffuse: { value: null, ignoreUIL: !0 },
          luminosityThreshold: { value: 1 },
          smoothWidth: { value: 0.01, ignoreUIL: !0 },
          defaultColor: { value: new Color(0), ignoreUIL: !0 },
          defaultOpacity: { value: 0, ignoreUIL: !0 },
        })),
        ((_mesh = new Mesh(
          _triangleGeometry,
          _luminosityShader
        )).frustumCulled = !1);
    }
    function initBlurShaders() {
      let resx = Math.round(_this.resolution.x / 2),
        resy = Math.round(_this.resolution.y / 2);
      for (let i = 0; i < _nMips; i++) {
        let shader = _this.initClass(
          Shader,
          "UnrealBloomGaussian",
          {
            colorTexture: { value: null },
            texSize: { value: new Vector2(resx, resy) },
            direction: { value: new Vector2(0.5, 0.5) },
          },
          null,
          (glsl) =>
            `\n#define KERNEL_RADIUS ${_kernelSizeArray[i]}\n#define SIGMA ${_kernelSizeArray[i]}\n${glsl}`,
          `gaussian${i}`
        );
        _separableBlurShaders.push(shader),
          (resx = Math.round(resx / 2)),
          (resy = Math.round(resy / 2));
      }
    }
    function initCompositeShader() {
      let uniforms = {
        bloomStrength: { value: 1 },
        bloomTintColor: { value: new Color("#ffffff") },
        bloomRadius: { value: 0 },
      };
      for (let i = 0; i < _nMips; i++)
        uniforms[`blurTexture${i + 1}`] = {
          value: _renderTargetsVertical[i].texture,
          ignoreUIL: !0,
        };
      (_compositeShader = _this.initClass(
        Shader,
        "UnrealBloomComposite",
        uniforms,
        null,
        (glsl, type) => {
          if ("vs" === type) return glsl;
          let compositeUniforms = "",
            compositeMain = "";
          for (let i = 0; i < _nMips; i++)
            (compositeUniforms += `uniform sampler2D blurTexture${i + 1};\n`),
              (compositeMain += `lerpBloomFactor(${_bloomFactors[i].toFixed(
                4
              )}) * vec4(bloomTintColor, 1.0) * texture2D(blurTexture${
                i + 1
              }, vUv) ${i < _nMips - 1 ? "+ " : ""}`);
          return (glsl = glsl.replace(
            "uniform sampler2D blurTexture1;",
            compositeUniforms
          )).replace(
            "lerpBloomFactor(1.0) * vec4(bloomTintColor, 1.0) * texture2D(blurTexture1, vUv)",
            compositeMain
          );
        }
      )).needsUpdate = !0;
    }
    function initPass() {
      _this.pass = _this.initClass(NukePass, "UnrealBloomPass", _this.uniforms);
    }
    function render() {
      if (!_this.enabled) return;
      let renderer = _nuke.renderer;
      _oldClearColor.copy(renderer.getClearColor()),
        (_oldClearAlpha = renderer.getClearAlpha());
      let oldAutoClear = renderer.autoClear;
      (renderer.autoClear = !0),
        renderer.setClearColor(_this.clearColor, 0),
        (_luminosityShader.uniforms.tDiffuse.value =
          _inputTexture || _nuke.rttBuffer.texture),
        (_mesh.shader = _luminosityShader),
        renderer.renderSingle(_mesh, _nuke.camera, _this.renderTargetBright);
      let inputRenderTarget = _this.renderTargetBright;
      for (let i = 0; i < _nMips; i++)
        (_mesh.shader = _separableBlurShaders[i]),
          (_separableBlurShaders[i].uniforms.colorTexture.value =
            inputRenderTarget.texture),
          (_separableBlurShaders[i].uniforms.direction.value = _blurDirectionX),
          renderer.renderSingle(
            _mesh,
            _nuke.camera,
            _renderTargetsHorizontal[i]
          ),
          (_separableBlurShaders[i].uniforms.colorTexture.value =
            _renderTargetsHorizontal[i].texture),
          (_separableBlurShaders[i].uniforms.direction.value = _blurDirectionY),
          renderer.renderSingle(_mesh, _nuke.camera, _renderTargetsVertical[i]),
          (inputRenderTarget = _renderTargetsVertical[i]);
      (_mesh.shader = _compositeShader),
        renderer.renderSingle(_mesh, _nuke.camera, _renderTargetsHorizontal[0]),
        renderer.setClearColor(_oldClearColor, _oldClearAlpha),
        (renderer.autoClear = oldAutoClear);
    }
    function resizeHandler() {
      _this.resolution
        .set(_nuke.stage.width, _nuke.stage.height)
        .multiplyScalar(_DPR),
        (_blurDirectionX.x = _DPR),
        (_blurDirectionY.y = _DPR);
      let resx = Math.round(_this.resolution.x / 2),
        resy = Math.round(_this.resolution.y / 2);
      _this.renderTargetBright.setSize(resx, resy);
      for (var i = 0; i < _nMips; i++)
        _renderTargetsHorizontal[i].setSize(resx, resy),
          _renderTargetsVertical[i].setSize(resx, resy),
          (_separableBlurShaders[i].uniforms.texSize.value = new Vector2(
            resx,
            resy
          )),
          (resx = Math.round(resx / 2)),
          (resy = Math.round(resy / 2));
    }
    function addListeners() {
      _this.events.sub(Events.RESIZE, resizeHandler),
        _this.events.sub(RenderManager.RENDER, render);
    }
    Inherit(this, Component);
    var _triangleGeometry,
      _luminosityShader,
      _compositeShader,
      _mesh,
      _inputTexture,
      _this = this,
      _oldClearColor = new Color(),
      _oldClearAlpha = 1,
      _renderTargetsHorizontal = [],
      _renderTargetsVertical = [],
      _separableBlurShaders = [],
      _nMips = options.nMips || 5,
      _DPR = _nuke.dpr,
      _blurDirectionX = new Vector2(_DPR, 0),
      _blurDirectionY = new Vector2(0, _DPR),
      _kernelSizeArray = options.kernelSizeArray || [3, 5, 7, 9, 11],
      _bloomFactors = options.bloomFactors || [1, 0.8, 0.6, 0.4, 0.2];
    (this.uniforms = { tUnrealBloom: { value: null } }),
      (this.resolution = new Vector2(
        _nuke.stage.width * _DPR,
        _nuke.stage.height * _DPR
      )),
      (this.clearColor = new Color(0, 0, 0)),
      (this.enabled = !0),
      (this.outputTexture = null),
      initRTs(),
      initScene(),
      initBlurShaders(),
      initCompositeShader(),
      initPass(),
      addListeners(),
      ShaderUIL.add(_luminosityShader).setLabel("UnrealBloom Luminosity"),
      ShaderUIL.add(_compositeShader).setLabel("UnrealBloom Composite"),
      this.set("texture", (texture) => {
        _inputTexture = texture;
      }),
      this.set("dpr", (dpr) => {
        (_DPR = dpr), resizeHandler();
      }),
      (this.renderBloom = render),
      (this.renderMesh = _mesh);
  }),
  Class(
    function SocketConnection(_server, _channel) {
      function open(e) {
        (_this.connected = !0),
          _this.events.fire(SocketConnection.OPEN, { socket: _this }, !0),
          _channel && _this.send("register", { channel: _channel });
      }
      function message(e) {
        if (e.data == PING) return _socket.send(PONG);
        let data = JSON.parse(e.data),
          evt = data._evt;
        delete data._evt, _this.events.fire(evt, data, !0);
      }
      function close(e) {
        (_this.connected = !1),
          _this.events.fire(SocketConnection.CLOSE, { socket: _this }, !0);
      }
      Inherit(this, Component);
      var _socket,
        _this = this;
      const PING = "ping",
        PONG = "pong";
      (this.connected = !1),
        (async function () {
          try {
            ((_socket = new WebSocket(_server)).onopen = open),
              (_socket.onmessage = message),
              (_socket.onclose = close);
          } catch (e) {
            await defer(),
              _this.events.fire(SocketConnection.ERROR, { socket: _this });
          }
        })(),
        (this.send = function (evt, data = {}) {
          if (!_this.connected)
            return _this.delayedCall((_) => _this.send(evt, data), 100);
          (data._evt = evt), _socket && _socket.send(JSON.stringify(data));
        });
    },
    (_) => {
      (SocketConnection.OPEN = "socket_connection_open"),
        (SocketConnection.CLOSE = "socket_connection_close"),
        (SocketConnection.ERROR = "socket_connection_error");
    }
  ),
  Class(function Tests() {
    (this.getDPR = function () {
      return GPU.OVERSIZED
        ? 0.8
        : GPU.lt(0)
        ? "safari" == Device.system.browser
          ? 0.85
          : 1
        : GPU.lt(1)
        ? "safari" == Device.system.browser
          ? 0.85
          : 1
        : GPU.lt(2)
        ? "safari" == Device.system.browser
          ? 1
          : Math.min(Device.pixelRatio, 1.1)
        : GPU.lt(3)
        ? "safari" == Device.system.browser
          ? 1.1
          : Math.min(Device.pixelRatio, 1.2)
        : GPU.lt(4)
        ? 1.5
        : GPU.mobileLT(0)
        ? 1
        : GPU.mobileLT(1)
        ? Math.min(Device.pixelRatio, 1)
        : GPU.mobileLT(2)
        ? Math.min(Device.pixelRatio, 1.05)
        : GPU.mobileLT(3)
        ? Math.min(Device.pixelRatio, 1.1)
        : GPU.mobileLT(4)
        ? Math.min(Device.pixelRatio, 1.5)
        : 1;
    }),
      (this.svgMask = function () {
        return "ie" != Device.system.browser;
      }),
      (this.cssGlow = function () {
        return !GPU.OVERSIZED;
      }),
      (this.useBloom = function () {
        return GPU.gt(3) || GPU.mobileGT(2);
      }),
      (this.useSurroundingLines = function () {
        return GPU.gt(2) || GPU.mobileGT(2);
      }),
      (this.useFluid = function () {
        return (
          ("chrome" === Device.system.browser ||
            "firefox" === Device.system.browser) &&
          (GPU.gt(3) || GPU.mobileGT(2))
        );
      }),
      (this.isSplitText = function () {
        return !GPU.OVERSIZED && !GPU.lt(1) && !GPU.mobileLT(0);
      }),
      (this.isPhone = function () {
        return Device.mobile && Device.mobile.phone;
      }),
      (this.bigTablet = function () {
        return (
          Device.mobile &&
          Device.mobile.tablet &&
          (Stage.width > 1100 || Stage.height > 1100)
        );
      }),
      (this.smallTablet = function () {
        return (
          Device.mobile &&
          Device.mobile.tablet &&
          (Stage.width < 850 || Stage.height < 850)
        );
      });
  }, "static"),
  Class(function API() {
    function encodeProduct(productCode, load, configurationData) {
      if (
        (configurationData || (configurationData = Configuration), !productCode)
      )
        return console.error("No product code specified");
      "C" !== productCode &&
        "D" !== productCode &&
        console.error("Only carpet system and inner dash have product data");
      let productData = configurationData.getProduct(productCode),
        code = `${configurationData.bodyStyle}_${
          configurationData.powertrain
        }_${load ? load + "_" : ""}${productCode}`;
      code += `${
        (productData.variables && productData.variables.TF) ||
        productData.variables.PT ||
        ""
      }${(productData.variables && productData.variables.PS) || ""}${
        (productData.variables && productData.variables.C) || ""
      }`;
      let t = productData.technology,
        technology = Object.keys(t)[0];
      Object.keys(t[technology]);
      return (code += `.${technology}${t[technology].C || ""}${
        t[technology].D || ""
      }${t[technology].I || ""}`);
    }
    function encodeOtherProducts(configurationData) {
      let products = (configurationData || Configuration).products,
        code = "";
      for (let p in products)
        products[p] &&
          products[p].technologyOption &&
          (code += p + products[p].technologyOption + "|");
      return code.substring(0, code.length - 1);
    }
    async function request(url) {
      if (_cache[url]) return _cache[url];
      let response = await post(url);
      return (_cache[url] = response), response;
    }
    Inherit(this, Model);
    const _this = this;
    var _cache = {};
    !(async function () {
      await Hydra.ready(),
        await Data.ready(),
        await Configuration.ready(),
        (_this.dataReady = !0);
    })(),
      (this.getProductData = async function (p, configurationData) {
        let code = encodeProduct(p, null, configurationData),
          response = await request(
            `${Config.API}?type=product&code=${code}&id=${Config.SESSION_ID}`
          );
        if (response.success) {
          let data = {
            tl: response.data.TL,
            abs: response.data.ABS,
            weight: response.data.Weight,
          };
          return (_cache[code] = data), data;
        }
        return (
          alert("Simulation data error. Please try again later..."),
          console.log("API ERROR. Returning FAKE data"),
          {
            tl: [
              50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
              50, 50, 50, 50, 50,
            ],
            abs: [
              0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5,
              0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5,
            ],
            weight: 0.01,
          }
        );
      }),
      (this.getSummaryData = async function (configurationData) {
        let ce = encodeProduct("C", "E", configurationData),
          de = encodeProduct("D", "E", configurationData),
          ct = encodeProduct("C", "T", configurationData),
          dt = encodeProduct("D", "T", configurationData),
          o = encodeOtherProducts(configurationData),
          engine = await request(
            `${Config.API}?type=summary&code1=${ce}&code2=${de}&code3=${o}&id=${Config.SESSION_ID}`
          ),
          tires = await request(
            `${Config.API}?type=summary&code1=${ct}&code2=${dt}&code3=${o}&id=${Config.SESSION_ID}`
          );
        return engine.success && tires.success
          ? { engine: engine.data, tires: tires.data }
          : (alert("Simulation data error. Please try again later..."),
            console.log("API ERROR. Returning FAKE data"),
            {
              engine: {
                Front_Upper_Cavity_DS: [
                  50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
                ],
                Rear_Upper_Cavity_PS: [
                  50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
                ],
                TotalWeight: 9.1,
                Weight_Dash: 3.1,
                Weight_Floor: 6.1,
              },
              tires: {
                Front_Upper_Cavity_DS: [
                  60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                ],
                Rear_Upper_Cavity_PS: [
                  60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
                ],
                TotalWeight: 10.1,
                Weight_Dash: 4.1,
                Weight_Floor: 7.1,
              },
            });
      });
  }, "static"),
  Class(function Configuration() {
    function init() {
      try {
        (_data = _this.initClass(ConfigurationData, {
          bodyStyle: Data.BODY_STYLES.find((bodyStyle) => bodyStyle.default)
            .code,
          powertrain: Data.POWERTRAINS.find((powertrain) => powertrain.default)
            .code,
        })).preset = _this.DEFAULT_PRESET;
      } catch (error) {
        console.error(
          "Error initializing configuration data, default required for each property."
        );
      }
    }
    function b64EncodeUnicode(str) {
      return btoa(
        encodeURIComponent(str).replace(
          /%([0-9A-F]{2})/g,
          function toSolidBytes(match, p1) {
            return String.fromCharCode("0x" + p1);
          }
        )
      );
    }
    function b64DecodeUnicode(str) {
      return decodeURIComponent(
        atob(str)
          .split("")
          .map(function (c) {
            return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
          })
          .join("")
      );
    }
    Inherit(this, Model);
    const _this = this;
    var _data;
    (_this.DEFAULT_PRESET = Utils.query("preset") || "B"),
      (async function () {
        await Hydra.ready(),
          await Data.ready(),
          await Reports.ready(),
          init(),
          (_this.dataReady = !0);
      })(),
      this.get("bodyStyle", () => _data.bodyStyle),
      this.set("bodyStyle", (newValue) => (_data.bodyStyle = newValue)),
      this.get("powertrain", () => _data.powertrain),
      this.set("powertrain", (newValue) => (_data.powertrain = newValue)),
      this.get("preset", () => _data.preset),
      this.set("preset", (newValue) => (_data.preset = newValue)),
      this.get("data", () => _data),
      this.get("products", () => _data.products),
      (this.getProduct = (p) => _data.getProduct(p)),
      (this.setProductVariable = (p, v, o) =>
        _data.setProductVariable(p, v, o)),
      (this.getProductVariables = (p) => _data.getProductVariables(p)),
      (this.setProductTechnology = (p, t, v, o) =>
        _data.setProductTechnology(p, t, v, o)),
      (this.getProductTechnology = (p) => _data.getProductTechnology(p)),
      (this.getProductTechnologyVariables = (p, t) =>
        _data.getProductTechnologyVariables(p, t)),
      (this.setProductTechnologyOption = (p, o) =>
        _data.setProductTechnologyOption(p, o)),
      (this.getProductTechnologyOption = (p) =>
        _data.getProductTechnologyOption(p)),
      (this.encode = function (model) {
        if (!model.getData) return;
        let data = model.getData(),
          s = "";
        (s += data.bodyStyle), (s += data.powertrain), (s += data.preset);
        let obj = {};
        for (let p in data.products)
          (obj[p] = {}),
            data.products[p].technologyOption &&
              (obj[p].to = data.products[p].technologyOption),
            data.products[p].variables &&
              (obj[p].v = data.products[p].variables),
            data.products[p].technology &&
              (obj[p].t = data.products[p].technology);
        let d = { title: data.title, date: data.date, products: obj };
        return s + b64EncodeUnicode(JSON.stringify(d));
      }),
      (this.trackSummary = function () {
        Track.event("summary", "body-style", _this.bodyStyle),
          Track.event("summary", "powertrain", _this.powertrain),
          Track.event("summary", "preset", _data.preset);
        let products = _this.products;
        for (let p in products) {
          let val = products[p],
            product = Meta.PRODUCT(p);
          if (
            (val.technologyOption &&
              Track.event(
                "summary",
                "product/" + product.perma + "/" + val.technologyOption
              ),
            val.variables)
          )
            for (let v in val.variables)
              Track.event(
                "summary",
                "product/" +
                  product.perma +
                  "/variables/" +
                  v +
                  "/" +
                  val.variables[v]
              );
          if (val.technology) {
            let currentTechnology = Object.keys(val.technology)[0];
            Track.event(
              "summary",
              "product/" + product.perma + "/technology/" + currentTechnology
            );
            for (let t in val.technology)
              for (let tt in val.technology[t])
                Track.event(
                  "summary",
                  "product/" +
                    product.perma +
                    "/technology/" +
                    t +
                    "/" +
                    tt +
                    "/" +
                    val.technology[t][tt]
                );
          }
        }
      }),
      (this.decode = function (code) {
        let data = JSON.parse(b64DecodeUnicode(code.slice(3))),
          products = {};
        for (let p in data.products)
          (products[p] = {}),
            data.products[p].to &&
              (products[p].technologyOption = data.products[p].to),
            data.products[p].v && (products[p].variables = data.products[p].v),
            data.products[p].t && (products[p].technology = data.products[p].t);
        return {
          bodyStyle: code.charAt(0),
          powertrain: code.charAt(1),
          preset: code.charAt(2),
          products: products,
          title: data.title,
          date: data.date,
        };
      }),
      (this.validCode = function (code) {
        try {
          return _this.decode(code), !0;
        } catch (error) {
          return !1;
        }
      });
  }, "static"),
  Class(function KeyValues() {
    function average(array) {
      return array.reduce((a, b) => a + b) / array.length;
    }
    Inherit(this, Model);
    const _this = this;
    !(async function () {
      await Hydra.ready(), await Data.ready(), (_this.dataReady = !0);
    })(),
      (this.getProductKeyValues = function (p, configurationModel) {
        let PRODUCT = Meta.PRODUCT(p),
          configuration = configurationModel || Configuration,
          data = configuration.getProduct(p),
          keyValues = [];
        if (data.technologyOption)
          keyValues.push(
            PRODUCT.technologyOptions.find(
              (t) => data.technologyOption === t.code
            ).keys
          );
        else if (data.technology)
          for (let _t in data.technology) {
            let multikeys = PRODUCT.technologies.find(
              (t) => _t === t.code
            ).multiKeys;
            if (multikeys) {
              let variables = [];
              for (let _v in data.technology[_t])
                variables.push(_v + data.technology[_t][_v]);
              variables.sort(),
                keyValues.push(multikeys[variables[0]][variables[1]]);
            } else
              for (let _v in data.technology[_t])
                keyValues.push(
                  PRODUCT.technologies
                    .find((t) => _t === t.code)
                    .variables.find((v) => _v === v.code)
                    .options.find((o) => o.code === data.technology[_t][_v])
                    .keys
                );
          }
        let keys = {};
        keyValues.forEach((kv) => {
          for (var k in kv) keys[k] ? keys[k].push(kv[k]) : (keys[k] = [kv[k]]);
        });
        let output = {};
        for (var k in keys)
          Data.KEYS.find((key) => key.code === k).powertrains.includes(
            configuration.powertrain
          ) &&
            (output[k] = {
              name: Data.KEYS.find((key) => key.code === k).name,
              value: average(keys[k]),
              description: Data.KEYS.find((key) => key.code === k).description,
            });
        if (data.variables) {
          let aa = 0,
            ai = 0;
          for (let _v in data.variables)
            for (let _o in data.variables[_v]) {
              let option = PRODUCT.productVariables
                .find((v) => _v === v.code)
                .options.find((o) => data.variables[_v][_o] === o.code);
              option &&
                ((option.aa > 0 || option.aa < 0) && (aa += option.aa),
                (option.ai > 0 || option.ai < 0) && (ai += option.ai));
            }
          output.AA &&
            (output.AA.value = Math.clamp(output.AA.value + aa, 0, 10)),
            output.AI &&
              (output.AI.value = Math.clamp(output.AI.value + ai, 0, 10));
        }
        return (
          (output = Object.values(
            output || {
              aa: { value: 1, name: "Acoustic Absorption", description: "" },
              ai: { value: 1, name: "Acoustic Insulation", description: "" },
              df: { value: 1, name: "Design Freedom", description: "" },
              l: { value: 1, name: "Lightweight", description: "" },
              s: { value: 1, name: "Sustainability", description: "" },
            }
          )).sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0)),
          output
        );
      });
  }, "static"),
  Class(function Meta() {
    Inherit(this, Model);
    const _this = this;
    !(async function () {
      await Hydra.ready(),
        await Data.ready(),
        await Configuration.ready(),
        (_this.dataReady = !0);
    })(),
      this.get("BODY_STYLES", () => Data.BODY_STYLES),
      this.get("POWERTRAINS", () =>
        Data.POWERTRAINS.filter((powertrain) =>
          powertrain.bodyStyles.includes(Configuration.bodyStyle)
        )
      ),
      this.get("PRODUCTS", () =>
        Data.PRODUCTS.filter(
          (product) =>
            product.powertrains.includes(Configuration.powertrain) &&
            product.bodyStyles.includes(Configuration.bodyStyle)
        )
      ),
      (this.PRODUCT = (code) =>
        Data.PRODUCTS.find((product) => product.code === code)),
      this.get("PRESETS", () => Data.PRESETS.filter((preset) => !0)),
      (this.getProductTechnologyOption = function (p, o) {
        return _this
          .PRODUCT(p)
          .technologyOptions.find(
            (technologyOption) => technologyOption.code === o
          );
      }),
      (this.getPresetName = function (p) {
        return Data.PRESETS.find((preset) => preset.code === p).name;
      });
  }, "static"),
  Class(function Reports() {
    function init() {
      let snapshots = Storage.get(Config.STORAGE_PREFIX + "snapshots");
      snapshots || (snapshots = []),
        (_snapshots = snapshots.map((s) =>
          _this.initClass(ConfigurationData, Configuration.decode(s))
        ));
    }
    function saveStorage() {
      let snapshotsEncoded = _snapshots.map((s) => Configuration.encode(s));
      Storage.set(Config.STORAGE_PREFIX + "snapshots", snapshotsEncoded);
    }
    function getTitle(shared) {
      let presetCount = _snapshots.filter(
          (s) => s.preset === Configuration.preset
        ).length,
        title = Data.copy("REPORT_TITLE")
          .replace("{preset}", Meta.getPresetName(Configuration.preset))
          .replace("{count}", presetCount + 1);
      return (
        shared && (title += Data.copy("REPORT_TITLE_SHARED_SUFFIX")), title
      );
    }
    Inherit(this, Model);
    const _this = this;
    var _snapshots = [];
    !(async function () {
      await Hydra.ready(), await Data.ready(), init(), (_this.dataReady = !0);
    })(),
      (this.list = function () {
        return _snapshots;
      }),
      (this.create = function () {
        let config = _this.initClass(ConfigurationData, {
          bodyStyle: Configuration.bodyStyle,
          powertrain: Configuration.powertrain,
          products: JSON.parse(JSON.stringify(Configuration.products)) || null,
          preset: Configuration.preset,
          title: getTitle(),
          date: new Date(),
        });
        return (
          Configuration.trackSummary(),
          _snapshots.push(config),
          saveStorage(),
          config
        );
      }),
      (this.load = function (code) {
        let data = Configuration.decode(code),
          config = _this.initClass(ConfigurationData, data);
        return (
          (config.title += Data.copy("REPORT_TITLE_SHARED_SUFFIX")),
          _snapshots.push(config),
          config
        );
      }),
      (this.rename = function (index, title) {
        (_snapshots[index].title = title), saveStorage();
      }),
      (this.delete = function (index) {
        return (
          (_snapshots = _snapshots.filter((c, i) => index !== i)),
          saveStorage(),
          _snapshots
        );
      }),
      (this.deleteAll = function () {
        return (_snapshots = []), saveStorage(), _snapshots;
      }),
      (this.clear = function () {
        return (_snapshots = []), saveStorage(), _snapshots;
      });
  }, "static"),
  Class(function Session() {
    function clear() {
      Storage.set(Config.STORAGE_PREFIX + "visits", 0),
        Storage.set(Config.STORAGE_PREFIX + "timeSpent", 0),
        Storage.set(Config.STORAGE_PREFIX + "seen", !1),
        _this.delayedCall(() => {
          window.location.href =
            window.location.protocol +
            "//" +
            window.location.hostname +
            window.location.pathname;
        }, 1e3);
    }
    function initVisits() {
      (_visits = Storage.get(Config.STORAGE_PREFIX + "visits")) ||
        (_visits = 0),
        _visits++,
        Storage.set(Config.STORAGE_PREFIX + "visits", _visits);
    }
    function initTimeSpent() {
      (_timeSpent = Number(Storage.get(Config.STORAGE_PREFIX + "timeSpent"))) ||
        (_timeSpent = 0),
        _this.delayedCall(updateTimeSpent, 5e3);
    }
    function updateTimeSpent() {
      (_timeSpent += Date.now() - _start),
        Storage.set(Config.STORAGE_PREFIX + "timeSpent", _timeSpent),
        (_start = Date.now()),
        _timeSpent > MIN_TIME_SPENT || _this.delayedCall(updateTimeSpent, 5e3);
    }
    function addListeners() {
      _this.events.sub(UI.CLOSE_MODAL, closeModal),
        _this.events.sub(Mouse.input, Interaction.MOVE, move);
    }
    function move() {
      _visits < MIN_VISITS ||
        (clearTimeout(_move),
        (_lastMoved = Date.now()),
        (_move = _this.delayedCall(openModal, IDLE_LENGTH)));
    }
    function closeModal() {
      (_isModalOpen = !1), Storage.set(Config.STORAGE_PREFIX + "seen", !0);
    }
    function openModal(force) {
      (!force && _isModalOpen) ||
        (!force && Storage.get(Config.STORAGE_PREFIX + "seen")) ||
        (!force && _timeSpent < MIN_TIME_SPENT) ||
        _this.delayedCall(() => {
          _this.events.fire(UI.OPEN_MODAL), (_isModalOpen = !0);
        }, 1e3);
    }
    Inherit(this, Model);
    const _this = this,
      IDLE_LENGTH = 3e4,
      MIN_VISITS = 2,
      MIN_TIME_SPENT = 6e5;
    let _visits,
      _timeSpent,
      _move,
      _lastMoved,
      _isModalOpen = !1,
      _start = Date.now();
    !(async function () {
      await Hydra.ready(),
        Utils.query("clear")
          ? clear()
          : Utils.query("modal")
          ? openModal(!0)
          : (initVisits(),
            initTimeSpent(),
            addListeners(),
            (_this.dataReady = !0));
    })();
  }, "static"),
  Class(
    function Container() {
      function initHTML() {
        Stage.add($this), $this.css({ position: "static" });
      }
      async function loadView() {
        await Data.ready();
        const deeplink = Utils.query("code") ? "report" : null;
        let loaderView = _this.initClass(LoaderView),
          loader = _this.initClass(
            AssetLoader,
            Assets.list().filter(["shaders", "data", "/images/car/"])
          );
        Storage.get("autoneum_cookies_accepted") ||
          Tests.isPhone() ||
          _this.initClass(CookiesView),
          _this.events.sub(loader, Events.PROGRESS, loaderView.progress),
          _this.events.sub(loader, Events.COMPLETE, async function () {
            _this.initClass(
              AssetLoader,
              Assets.list().filter(["woff", "images"])
            ),
              await Initializer3D.createWorld(),
              await Car.instance().ready,
              _this.events.fire(Container.LOADED, { deeplink: deeplink }),
              loaderView.animateOut(() => {
                Device.mobile &&
                  Device.mobile.tablet &&
                  _this.initClass(UIUnsupportedRotateView),
                  loaderView.destroy();
              });
          }),
          await Initializer3D.createWorld(),
          initView(),
          await Initializer3D.uploadAllDistributed(World.SCENE);
      }
      async function initView() {
        World.instance(),
          $this.add(World.ELEMENT),
          Viewport.instance(),
          Customise.instance(),
          $this.add(UI.instance().element);
      }
      Inherit(this, Element);
      const _this = this,
        $this = this.element;
      initHTML(), loadView();
    },
    "singleton",
    () => {
      Container.LOADED = "event_container_loaded";
    }
  ),
  Class(function Playground() {
    function initThree() {
      World.instance(), Stage.add(World.ELEMENT);
    }
    function initView() {
      let request = Global.PLAYGROUND.split("/")[0],
        view = window["Playground" + request] || window[request] || null;
      if (!view) throw `No Playground class ${request} found.`;
      if (
        ((_view = view.instance ? view.instance() : _this.initClass(view))
          .element && Stage.add(_view.element),
        _view.rt && _view.scene && _view.nuke)
      ) {
        let shader = _this.initClass(Shader, "ScreenQuad", {
            tMap: { value: _view },
          }),
          mesh = new Mesh(World.QUAD, shader);
        World.SCENE.add(mesh);
      } else World.SCENE.add(_view.group || _view.mesh || _view.object3D || new Group());
      Dev.expose("view", _view);
    }
    Inherit(this, Component);
    const _this = this;
    let _view;
    !(async function () {
      await UILStorage.ready(),
        (Global.PLAYGROUND = Utils.query("p")),
        initThree(),
        initView(),
        defer(window.onresize);
    })();
  }, "singleton"),
  Class(
    function Colors() {
      function setUIColors(color) {
        (_this.UI.main = color), (_this.UI.dark = _this.calculateDark(color));
      }
      Inherit(this, Component);
      const _this = this;
      (_this.disabledColor = "#cd6f68"),
        (_this.disabledCarColor = new Color("#442825"));
      var _color0Target = new Color(Config.BASE_COLORS[0]),
        _color1Target = new Color(Config.BASE_COLORS[1]),
        _color2Target = new Color(Config.BASE_COLORS[2]),
        _colorHelper = new Color();
      (_this.SHADER = [
        { value: new Color(Config.BASE_COLORS[0]), ignoreUIL: !0 },
        { value: new Color(Config.BASE_COLORS[1]), ignoreUIL: !0 },
        { value: new Color(Config.BASE_COLORS[2]), ignoreUIL: !0 },
      ]),
        (_this.UI = { main: "", dark: "" }),
        (this.calculateDark = function (color) {
          _colorHelper.set(color);
          let hsl = _colorHelper.getHSL();
          return (
            _colorHelper.setHSL(
              hsl.h,
              Math.min(hsl.s, 0.55),
              Math.min(hsl.l, 0.65)
            ),
            _colorHelper.getHexString()
          );
        }),
        (this.update = function () {
          _this.SHADER[0].value.lerp(_color0Target, 0.04),
            _this.SHADER[1].value.lerp(_color1Target, 0.04),
            _this.SHADER[2].value.lerp(_color2Target, 0.04);
        }),
        (this.setShaderColors = function (ui = !1) {
          let data = Config.PRESET_COLORS[Config.CURRENT_PRESET];
          _color0Target.set(data[0][0]),
            _color1Target.set(data[1][0]),
            _color2Target.set(data[2][0]),
            ui && _this.setUIColor(data[0][0]);
        }),
        (this.setShaderColor1 = function (color) {
          _color0Target.set(color);
        }),
        (this.setUIColor = function (color) {
          setUIColors(color), UI.instance().updateColors();
        }),
        (this.reset = function () {
          _color0Target.set(Config.BASE_COLORS[0]),
            _color1Target.set(Config.BASE_COLORS[1]),
            _color2Target.set(Config.BASE_COLORS[2]),
            setUIColors(Config.BASE_COLORS[0]),
            UI.instance().updateColors(),
            _this.events.fire(Car.COLOR_CHANGE, "enable");
        }),
        (this.disable = function () {
          _color0Target.set("#cd6f68"),
            _color1Target.set("#cd6f68"),
            _color2Target.set("#cd6f68"),
            setUIColors("#cd6f68"),
            UI.instance().updateColors(),
            _this.events.fire(Car.COLOR_CHANGE, "disable");
        }),
        (this.setUIColors = setUIColors);
    },
    "singleton",
    () => {
      Colors.instance().setUIColors(Config.BASE_COLORS[0]);
    }
  ),
  Class(function VFX() {
    function init() {
      (_composite = new NukePass("Composite", {
        tViewport: { value: Viewport.instance().rt.texture },
        tCustomise: { value: Customise.instance().rt.texture },
        uDPR: { value: World.DPR },
        uCustomiseTransition: { value: 0 },
        uFocus: { value: 0 },
        uDelta: { value: _delta },
        uAngle: { value: _angle },
        amplitude: { value: 3 },
        divider: { value: 40 },
        sp: { value: 4 },
      })),
        World.NUKE.add(_composite);
    }
    function loop() {
      let delta = Mouse.delta.length();
      (delta = Math.clamp(delta, 0, 7)),
        (_delta += 0.1 * (delta - _delta)),
        _composite.set("uDelta", _delta);
      var diffX = Mouse.x - Stage.width / 2,
        diffY = Mouse.y - Stage.height / 2,
        angle = Math.atan2(diffY, diffX);
      _composite.set("uAngle", angle);
    }
    function addHandlers() {
      _this.events.sub(UISection.OPEN_CUSTOMISE, openCustomise),
        _this.events.sub(UISection.CLOSE_CUSTOMISE, closeCustomise),
        _this.events.sub(UI.FADE, uiFade);
    }
    function openCustomise() {
      _bloom && (_bloom.enabled = !1),
        _composite.tween("uCustomiseTransition", 1, 1600, "easeInOutCubic");
    }
    function closeCustomise() {
      _bloom && (_bloom.enabled = !0),
        _composite.tween("uCustomiseTransition", 0, 1600, "easeInOutCubic");
    }
    function uiFade(e) {
      e.hide
        ? _composite.tween("uFocus", 1, 1200, "easeInOutCubic")
        : _composite.tween("uFocus", 0, 600, "easeOutQuint");
    }
    Inherit(this, Component);
    const _this = this;
    var _composite,
      _bloom,
      _delta = 0,
      _angle = 0;
    Global.PLAYGROUND
      ? World.NUKE.add(new FXAA())
      : (init(), addHandlers(), _this.startRender(loop));
  }, "singleton"),
  Class(
    function World() {
      function initWorld() {
        (World.PLANE = new PlaneGeometry(1, 1)),
          (World.QUAD = Nuke.getTri()),
          RenderManager.initialize(RenderManager.NORMAL, {
            powerPreference: "high-performance",
          }),
          (_renderer = RenderManager.gl),
          (_scene = RenderManager.scene),
          (_camera = RenderManager.camera.worldCamera),
          (_nuke = RenderManager.nuke),
          (World.SCENE = _scene),
          (World.RENDERER = _renderer),
          (World.ELEMENT = $(_renderer.domElement)),
          (World.CAMERA = _camera),
          (World.NUKE = _nuke),
          Colors.instance(),
          VFX.instance();
      }
      function initControls() {
        window.DebugControls &&
          ((_controls = new DebugControls(_camera, World.ELEMENT.div)),
          RenderManager.type == RenderManager.NORMAL
            ? (_camera.position.set(0, 0, 6),
              (_camera.target = new Vector3(0, 0, 0)),
              _camera.lookAt(_camera.target),
              (_controls.target = _camera.target))
            : (_controls.enabled = !1),
          (World.CONTROLS = _controls));
      }
      function addHandlers() {
        _this.events.sub(Events.RESIZE, resize);
      }
      function resize() {
        _renderer.setSize(Stage.width, Stage.height),
          (_camera.aspect = Stage.width / Stage.height),
          _camera.updateProjectionMatrix();
      }
      function loop(t, delta) {
        _controls && _controls.enabled && _controls.update(),
          RenderManager.render(),
          Colors.instance().update();
      }
      Inherit(this, Component);
      const _this = this;
      let _renderer, _scene, _camera, _nuke, _controls;
      (World.DPR = Tests.getDPR()),
        initWorld(),
        initControls(),
        addHandlers(),
        (Render.drawFrame = loop),
        RenderManager.type == RenderManager.NORMAL && Camera.instance(_camera);
    },
    function () {
      var _instance;
      World.instance = function () {
        return _instance || (_instance = new World()), _instance;
      };
    }
  ),
  Class(function Customise() {
    function loop() {
      _this.isPaused || _this.render();
    }
    function addHandlers() {
      _this.events.sub(UISection.OPEN_CUSTOMISE, resume),
        _this.events.sub(UISection.CLOSE_CUSTOMISE, pause);
    }
    function pause() {
      _this.isPaused = !0;
    }
    function resume() {
      _this.isPaused = !1;
    }
    Inherit(this, FXScene);
    const _this = this;
    _this.create(),
      (_this.layout = _this.initClass(SceneLayout, "CustomiseLayout")),
      _this.scene.add(_this.layout.group),
      addHandlers(),
      (_this.isPaused = !0),
      _this.startRender(loop);
  }, "singleton"),
  Class(function CustomiseCamera(_element) {
    function loop() {
      _controls.update();
    }
    function resetCamera() {
      _this.group.position.set(5, 3, 1.3).multiplyScalar(10),
        (_this.camera.rotation.y = Math.PI);
    }
    Inherit(this, Object3D);
    const _this = this;
    let _controls;
    (this.camera = new PerspectiveCamera(10, 2, 0.1, 1e3)),
      this.group.add(this.camera),
      this.startRender((_) => {
        _this.group.updateMatrixWorld(!0);
      }),
      _this.camera.rotation.reorder("YZX"),
      ((_controls = new Orbit(_this.group, _element.div)).autoRotate = !0),
      (_controls.autoRotateSpeed = -0.1),
      (_controls.enablePan = !1),
      (_controls.enableZoom = !1),
      (_controls.minDistance = 12),
      (_controls.maxDistance = 25),
      (_this.group.target = new Vector3(0, 0, 0)),
      _this.group.lookAt(_this.group.target),
      (_controls.target = _this.group.target),
      resetCamera(),
      (_controls.onUpdate = function () {}),
      (_this.controls = _controls),
      _this.startRender(loop),
      (this.pause = function () {
        _this.stopRender(loop);
      }),
      (this.resume = function () {
        _this.startRender(loop);
      }),
      (this.unattach = function () {
        _controls.dispose();
      }),
      (this.reattach = function (element) {
        _controls.reattach(element.div);
      }),
      (this.dolly = function (amount) {
        _controls.dollyIn(amount);
      }),
      (this.reset = function () {
        resetCamera();
      });
  }, "singleton"),
  Class(function CustomiseComposite(_mesh, _shader, _input, _group) {
    function addHandlers() {
      _this.events.sub(UISection.OPEN_CUSTOMISE, openCustomise);
    }
    function openCustomise() {
      _shader.set("uTransition", 0),
        _shader.tween("uTransition", 1, 1600, "easeOutQuart", 500);
    }
    Inherit(this, Component);
    const _this = this;
    !(async function () {
      (_shader.uniforms.tProduct = {
        value: ProductSolo.instance().rt.texture,
      }),
        (_shader.uniforms.tCrossSection = {
          value: CrossSection.instance().rt.texture,
        }),
        (_shader.uniforms.uDPR = { value: World.DPR }),
        (_shader.uniforms.uTransition = { value: 0 }),
        addHandlers();
    })();
  }),
  Class(function CrossSection() {
    function initCamera() {
      ((_camera = _this.initClass(
        CustomiseCamera,
        World.ELEMENT
      )).group.target.y = 0.75),
        _this.useCamera(_camera.camera),
        _camera.pause(),
        _camera.unattach(),
        (_this.camera = _camera);
    }
    function loop() {
      _this.isPaused || _this.render();
    }
    function addHandlers() {
      _this.events.sub(UISection.OPEN_CUSTOMISE, resume),
        _this.events.sub(UISection.CLOSE_CUSTOMISE, pause);
    }
    function pause() {
      _layers && _layers.close(),
        (_this.isPaused = !0),
        _camera.pause(),
        _camera.unattach();
    }
    function resume({ data: data }) {
      _productData = data;
      let techPerma,
        tech = Configuration.getProductTechnologyOption(_productData.code);
      tech
        ? _productData.technologyOptions.forEach((t) => {
            t.code === String(tech) && (techPerma = t.perma);
          })
        : ((tech = Configuration.getProductTechnology(_productData.code)),
          _productData.technologies.forEach((t) => {
            tech[t.code] && (techPerma = t.perma);
          })),
        _layers && _layers.open(techPerma),
        (_this.isPaused = !1);
    }
    Inherit(this, FXScene);
    const _this = this;
    let _camera, _layers, _productData;
    !(async function () {
      _this.create(World.NUKE, { format: Texture.RGBAFormat }),
        (_this.clearAlpha = 0),
        _this.setSize(800, 440),
        initCamera(),
        (_this.layout = _this.initClass(SceneLayout, "CrossSectionLayout")),
        _this.scene.add(_this.layout.group),
        ([_layers] = await _this.layout.getLayers("Layers")),
        _layers.group.scale.setScalar(1.5),
        (_this.isPaused = !0),
        addHandlers(),
        _this.startRender(loop);
    })(),
      (this.addCameraCatch = function (element) {
        _camera.reattach(element), _camera.reset(), _camera.resume();
      }),
      (this.updateTechnology = function (techPerma) {
        _layers.updateTechnology(techPerma);
      });
  }, "singleton"),
  Class(function CrossSectionLayers(_input, _group) {
    async function initGeometry() {
      _geometry = await GeomThread.loadGeometry("layer");
    }
    function initShader() {
      _shader = _this.initClass(Shader, "Layer", {
        tDiffuse: { value: null },
        tAlpha: { value: null },
        uThickness: { value: 0.1 },
        uTransition: { value: 0 },
        uOffset: { value: 0 },
        uDir: { value: 0 },
      });
    }
    function initShadow() {
      const geometry = new PlaneGeometry(1, 1);
      _shadowShader = _this.initClass(Shader, "LayerShadow", {
        tAlpha: {
          value: Utils3D.getTexture("assets/images/crosssection/shadow.jpg"),
        },
        uAlpha: { value: 0 },
        transparent: !0,
      });
      const mesh = new Mesh(geometry, _shadowShader);
      mesh.scale.setScalar(3),
        (mesh.rotation.x = -Math.PI / 2),
        _this.add(mesh);
    }
    function initLayers() {
      for (let i = 0; i < 5; i++) {
        const mesh = new Mesh(_geometry, _shader);
        _this.add(mesh),
          (mesh.position.y = 0.3 * i + 0.5),
          (mesh.isActive = !0),
          (mesh.transition = 0),
          (mesh.direction = i % 2),
          (mesh.thickness = 0.1),
          (mesh.offset = 0.75 * i),
          (mesh.texDiffuse = null),
          (mesh.texAlpha = null),
          (mesh.onBeforeRender = () => {
            (_shader.uniforms.tDiffuse.value = mesh.texDiffuse),
              (_shader.uniforms.tAlpha.value = mesh.texAlpha),
              (_shader.uniforms.uTransition.value = mesh.transition),
              (_shader.uniforms.uThickness.value = mesh.thickness),
              (_shader.uniforms.uOffset.value = mesh.offset),
              (_shader.uniforms.uDir.value = mesh.direction);
          }),
          _layers.push(mesh);
      }
    }
    async function animateOut() {
      const tweens = [];
      let j = -1;
      for (let i = _layers.length - 1; i >= 0; i--)
        _layers[i].isActive &&
          (j++,
          tweens.push(
            tween(
              _layers[i],
              { transition: 0 },
              500,
              "easeInOutCubic",
              150 * j
            ).promise()
          ));
      tween(
        _shadowShader.uniforms.uAlpha,
        { value: 0 },
        750,
        "easeInOutCubic",
        150 * j
      ),
        await Promise.all(tweens);
    }
    function updateLayers(techPerma) {
      _layers.forEach((layer) => (layer.isActive = !1));
      let y = 0.4;
      const layerList = _layerData.technologies[techPerma];
      layerList &&
        layerList.forEach((type, i) => {
          const layer = _layers[i];
          (layer.isActive = !0),
            (layer.thickness = _layerData.layers[type].thickness),
            (y += layer.thickness),
            (layer.position.y = y),
            (y += 0.1),
            (layer.texDiffuse = Utils3D.getTexture(
              `assets/images/crosssection/layers/${type}/diffuse.jpg`
            )),
            (layer.texDiffuse.generateMipmaps = !1),
            (layer.texDiffuse.minFilter = Texture.LINEAR),
            (layer.texAlpha = Utils3D.getTexture(
              `assets/images/crosssection/layers/${type}/alpha.jpg`
            )),
            (layer.texAlpha.generateMipmaps = !1),
            (layer.texAlpha.minFilter = Texture.LINEAR);
        });
    }
    function animateIn() {
      tween(
        _shadowShader.uniforms.uAlpha,
        { value: 0.3 },
        750,
        "easeInOutCubic",
        600
      );
      for (let i = 0; i < _layers.length; i++)
        _layers[i].isActive &&
          tween(
            _layers[i],
            { transition: 1 },
            1500,
            "easeInOutCubic",
            400 + 300 * i
          );
    }
    Inherit(this, Object3D);
    const _this = this;
    let _geometry, _shader, _shadowShader;
    const _layers = [],
      _layerData = _this.initClass(LayerData);
    !(async function () {
      initShader(), await initGeometry(), initShadow(), initLayers();
    })(),
      (this.updateTechnology = async function (perma) {
        await animateOut(), updateLayers(perma), animateIn();
      }),
      (this.open = function (perma) {
        updateLayers(perma), animateIn();
      }),
      (this.close = function () {
        animateOut();
      });
  }),
  Class(function LayerData() {
    Inherit(this, Component);
    (this.layers = {
      nothing: { thickness: 0.4 },
      decor: { thickness: 0.04 },
      "heavy-rubber": { thickness: 0.05 },
      "decoupler-felt": { thickness: 0.3 },
      "decoupler-felt-thin": { thickness: 0.1 },
      "decoupler-foam": { thickness: 0.3 },
      "decoupler-foam-white": { thickness: 0.3 },
      "flexi-loft-compressed": { thickness: 0.04 },
      "flexi-loft": { thickness: 0.1 },
      film: { thickness: 0.02 },
      "flexi-loft-uncompressed": { thickness: 0.2 },
      cover: { thickness: 0.02 },
      "theta-cell-foam": { thickness: 0.3 },
      "standard-glassfiber-felt": { thickness: 0.3 },
      "ts-felt": { thickness: 0.3 },
      "theta-fiber-foam": { thickness: 0.2 },
      "theta-fiber-felt": { thickness: 0.2 },
      "theta-cell-felt": { thickness: 0.3 },
      aluminium: { thickness: 0.05 },
      "rimic-single-layer": { thickness: 0.05 },
      "rimic-multilayer": { thickness: 0.1 },
      "thermo-composite-felt": { thickness: 0.2 },
      dlft: { thickness: 0.05 },
      "ultra-silent": { thickness: 0.2 },
      "injected-plastic": { thickness: 0.05 },
      textile: { thickness: 0.2 },
      "alpha-liner": { thickness: 0.2 },
      "era-film": { thickness: 0.02 },
      "era-foam": { thickness: 0.2 },
    }),
      (this.technologies = {
        nothing: ["nothing"],
        "dash-spring-mass-eco": ["decoupler-felt", "heavy-rubber"],
        "dash-spring-mass-flex": ["decoupler-foam-white", "heavy-rubber"],
        "dash-primelight": ["decoupler-felt", "film", "decoupler-felt-thin"],
        "dash-hybrid-acoustic-eco": ["decoupler-felt", "film", "flexi-loft"],
        "dash-hybrid-acoustic-flex": [
          "decoupler-foam-white",
          "film",
          "flexi-loft",
        ],
        "carpet-spring-mass-eco": ["decoupler-felt", "heavy-rubber", "decor"],
        "carpet-spring-mass-flex": [
          "decoupler-foam-white",
          "heavy-rubber",
          "decor",
        ],
        "carpet-primelight": [
          "decoupler-felt",
          "film",
          "decoupler-felt-thin",
          "decor",
        ],
        "carpet-ifpr3": [
          "flexi-loft-uncompressed",
          "film",
          "flexi-loft-compressed",
          "decor",
        ],
        "carpet-hybrid-acoustic-eco": [
          "decoupler-felt",
          "film",
          "flexi-loft",
          "decor",
        ],
        "carpet-hybrid-acoustic-flex": [
          "decoupler-foam-white",
          "film",
          "flexi-loft",
          "decor",
        ],
        "spring-mass-eco-inner-dash": ["decoupler-felt", "heavy-rubber"],
        "spring-mass-flex-inner-dash": ["decoupler-foam", "heavy-rubber"],
        "prime-light-inner-dash": [
          "flexi-loft-uncompressed",
          "film",
          "flexi-loft-compressed",
        ],
        "theta-cell": ["cover", "theta-cell-foam", "cover"],
        "standard-glassfiber-felt": ["standard-glassfiber-felt"],
        "ts-felt": ["ts-felt"],
        "theta-fibercell": [
          "cover",
          "theta-cell-foam",
          "theta-fiber-foam",
          "cover",
        ],
        "theta-felt": [
          "cover",
          "theta-fiber-felt",
          "era-film",
          "theta-fiber-felt",
          "cover",
        ],
        aluminium: ["aluminium"],
        "rimic-single": ["rimic-single-layer"],
        "rimic-multi": [
          "rimic-single-layer",
          "rimic-multilayer",
          "rimic-single-layer",
        ],
        "thermo-composite-felt": ["aluminium", "ts-felt", "cover"],
        dlft: ["dlft"],
        "dlft-patch": ["dlft", "era-film", "era-foam", "era-film"],
        "ultra-silent": ["ultra-silent"],
        "injected-plastic": ["injected-plastic"],
        textile: ["textile"],
        "textile-patch": ["textile", "era-film", "era-foam", "era-film"],
        "alpha-liner": ["alpha-liner"],
      });
  }),
  Class(function ProductSolo() {
    function initCamera() {
      (_camera = _this.initClass(CustomiseCamera, World.ELEMENT)),
        _this.useCamera(_camera.camera),
        _camera.pause(),
        _camera.unattach(),
        (_this.camera = _camera);
    }
    function loop() {
      _this.isPaused || _this.render();
    }
    function addHandlers() {
      _this.events.sub(UISection.OPEN_CUSTOMISE, resume),
        _this.events.sub(UISection.CLOSE_CUSTOMISE, pause);
    }
    function pause() {
      (_this.isPaused = !0), _camera.pause(), _camera.unattach();
    }
    function resume({ perma: perma }) {
      _products && _products.isolate(perma), (_this.isPaused = !1);
    }
    Inherit(this, FXScene);
    const _this = this;
    let _camera, _products;
    !(async function () {
      _this.create(World.NUKE, { format: Texture.RGBAFormat }),
        (_this.clearAlpha = 0),
        _this.setSize(800, 440),
        initCamera(),
        (_this.layout = _this.initClass(SceneLayout, "ProductSoloLayout")),
        _this.scene.add(_this.layout.group),
        ([_products] = await _this.layout.getLayers("Products")),
        (_this.isPaused = !0),
        _this.startRender(loop),
        addHandlers();
    })(),
      (this.addCameraCatch = function (element) {
        _camera.reattach(element), _camera.reset(), _camera.resume();
      });
  }, "singleton"),
  Class(function ProductSoloProducts(_input, _group) {
    function initShader() {
      (_shader = _this.initClass(Shader, "ProductSoloProductShader", {
        tAO: { value: null, ignoreUIL: !0 },
        tMatCap: { value: null },
        tEnv: { value: null },
        uColor1: { value: new Color(), ignoreUIL: !0 },
        tVariables: { value: null, ignoreUIL: !0 },
        uVariablesFade: { value: 0, ignoreUIL: !0 },
        uVariablesIndex: { value: 0, ignoreUIL: !0 },
        transparent: !0,
        side: Shader.DOUBLE_SIDE,
      })),
        ShaderUIL.add(_shader, _group);
    }
    async function initProducts() {
      await Promise.all(Data.PRODUCTS.map(addMesh));
      let p = [];
      for (let powertrain of Object.keys(Config.ALTERNATIVE_MODELS))
        for (let perma of Object.keys(Config.ALTERNATIVE_MODELS[powertrain]))
          Data.PRODUCTS.forEach((item, index) => {
            item.perma === perma &&
              p.push(
                addalternativeMesh(
                  item.perma,
                  Config.ALTERNATIVE_MODELS[powertrain][perma],
                  powertrain
                )
              );
          });
      await Promise.all(p);
    }
    async function addalternativeMesh(perma, alternativePerma, powertrain) {
      const group = new Group();
      _this.add(group),
        (group.perma = alternativePerma),
        (_products[alternativePerma] = group),
        (_products[perma].alternative = {
          powertrain: powertrain,
          alternativePerma: alternativePerma,
        }),
        (group.visible = !1);
      const geometry = await GeomThread.loadGeometry(
          `products/${alternativePerma}`
        ),
        mesh = new Mesh(geometry, _shader);
      group.add(mesh);
      const aoTexture = Utils3D.getTexture(
        `assets/images/products/ao/${alternativePerma}.jpg`
      );
      mesh.onBeforeRender = () => {
        _shader.uniforms.tAO.value = aoTexture;
        const color1 =
          Config.PRESET_COLORS[Config.CURRENT_PRESET][
            Config.PRODUCT_DATA[perma].colorIndex || 0
          ][0];
        _shader.uniforms.uColor1.value.set(color1);
      };
    }
    async function addMesh({ perma: perma }, i) {
      const group = new Group();
      _this.add(group),
        (group.perma = perma),
        (_products[perma] = group),
        (group.visible = !1);
      const geometry = await GeomThread.loadGeometry(`products/${perma}`),
        mesh = new Mesh(geometry, _shader);
      group.add(mesh);
      const aoTexture = Utils3D.getTexture(
        `assets/images/products/ao/${perma}.jpg`
      );
      mesh.onBeforeRender = () => {
        _shader.uniforms.tAO.value = aoTexture;
        const color1 =
          Config.PRESET_COLORS[Config.CURRENT_PRESET][
            Config.PRODUCT_DATA[perma].colorIndex || 0
          ][0];
        _shader.uniforms.uColor1.value.set(color1);
      };
    }
    function initShadow() {
      const geometry = new PlaneGeometry();
      _shadowShader = _this.initClass(Shader, "RoomShadow", {
        tMap: { value: null },
        depthWrite: !1,
        transparent: !0,
      });
      const mesh = new Mesh(geometry, _shadowShader);
      mesh.scale.setScalar(5),
        (mesh.position.y = 0.01),
        (mesh.rotation.x = -Math.PI / 2),
        _this.add(mesh);
    }
    function addHandlers() {
      _this.events.sub(UICustomiseVariables.CHANGE, updateVariable);
    }
    async function updateVariable({ variable: variable, option: option }) {
      let src = "assets/images/products/settings/";
      switch (variable.perma) {
        case "coverage":
          (src += `coverage/${_current.perma}.jpg`),
            (_shader.uniforms.uVariablesIndex.value =
              "low" === option.perma ? 0 : "average" === option.perma ? 1 : 2);
          break;
        case "packaging-space":
          (src += `thickness/${_current.perma}.jpg`),
            (_shader.uniforms.uVariablesIndex.value =
              "low" === option.perma ? 3 : "average" === option.perma ? 4 : 5);
          break;
        case "top-face":
          (src += `top-face/${option.perma}.jpg`),
            (_shader.uniforms.uVariablesIndex.value = 6);
          break;
        case "pass-through":
          (src += `pass-through/${_current.perma}.jpg`),
            (_shader.uniforms.uVariablesIndex.value =
              "low" === option.perma ? 7 : "average" === option.perma ? 8 : 9);
      }
      (_shader.uniforms.tVariables.value = Utils3D.getRepeatTexture(src)),
        await tween(
          _shader.uniforms.uVariablesFade,
          { value: 1 },
          500,
          "easeOutCubic"
        ).promise(),
        tween(
          _shader.uniforms.uVariablesFade,
          { value: 0 },
          1e3,
          "easeInOutCubic",
          1e3
        );
    }
    Inherit(this, Object3D);
    const _this = this;
    let _shader, _shadowShader;
    const _products = {};
    let _current;
    initShader(),
      initProducts(),
      initShadow(),
      addHandlers(),
      (this.isolate = function (perma) {
        if (
          (_current && (_current.visible = !1),
          _products[perma].alternative &&
          Configuration.powertrain === _products[perma].alternative.powertrain
            ? ((_current =
                _products[_products[perma].alternative.alternativePerma]),
              (_shadowShader.uniforms.tMap.value = Utils3D.getTexture(
                `assets/images/products/shadow/${_products[perma].alternative.alternativePerma}.jpg`
              )))
            : ((_current = _products[perma]),
              (_shadowShader.uniforms.tMap.value = Utils3D.getTexture(
                `assets/images/products/shadow/${perma}.jpg`
              ))),
          (_current.visible = !0),
          !_current.children.length)
        )
          return;
        const sphere = _current.children[0].geometry.boundingSphere,
          scale = Math.range(sphere.radius, 0.3, 1.8, 3, 1, !0);
        _this.group.scale.setScalar(scale),
          _this.group.position
            .set(0, 0, 0)
            .sub(sphere.center)
            .multiplyScalar(scale);
      });
  }),
  Class(
    function UI() {
      function initHTML() {
        $this.css({ position: "static" });
      }
      function initViews() {
        (_joystick = _this.initClass(UIJoystick)),
          Tests.isPhone() ||
            ((_logo = _this.initClass(UILogo)),
            (_menu = _this.initClass(UIMenu)),
            (_contact = _this.initClass(UIContactLink)),
            (_introText = _this.initClass(UIIntroText)),
            (_section = _this.initClass(UISection)).element.tween(
              { opacity: 1 },
              0,
              "easeOutCubic"
            ),
            $this.add(UIReport.instance().element),
            $this.add(UICompare.instance().element));
      }
      function addHandlers() {
        _this.events.sub(Container.LOADED, animateIn),
          Tests.isPhone() ||
            (_this.events.sub(UISection.OPEN_CUSTOMISE, openCustomise),
            _this.events.sub(UISection.CLOSE_CUSTOMISE, closeCustomise),
            _this.events.sub(UISection.OPEN_REPORT, openReport),
            _this.events.sub(UISection.CLOSE_REPORT, closeReport),
            _this.events.sub(UI.OPEN_MODAL, openModal),
            _this.events.sub(Car.DRIVING, toggleDriving),
            _this.events.sub(UI.FADE, fade));
      }
      function toggleDriving({ driving: driving }) {
        if (driving) Track.event("drive", "start"), (_start = Date.now());
        else {
          let duration = Date.now() - _start;
          (duration /= 1e3), Track.event("drive", "stop", null, duration);
        }
        CarCamera.instance().fading ||
          (_drivingAnimation && _drivingAnimation.stop(),
          (_drivingAnimation = _section.element.tween(
            { opacity: driving ? 0 : 1 },
            driving ? 500 : 1500,
            "easeOutCubic"
          )));
      }
      async function animateIn({ deeplink: deeplink }) {
        "report" !== deeplink || Tests.isPhone()
          ? Tests.isPhone()
            ? (await _this.wait(4500),
              _this.initClass(UIUnsupportedView),
              _joystick.animateIn())
            : (await _this.wait(6650),
              _introText.animateIn(),
              _joystick.animateIn(),
              await _this.wait(2e3),
              _menu.animateIn(),
              _logo.animateIn(),
              _section.animateIn(),
              _contact.animateIn(),
              await _this.wait(3e3),
              _this.events.fire(UIIntroText.ANIMATE_OUT),
              await _this.wait(500),
              _this.introTextHidden || _section.animeteTextIn())
          : (_introText.destroy(),
            _joystick.animateIn(),
            _menu.animateIn(),
            _logo.animateIn(),
            await _this.wait(6e3),
            _section.animateIn(),
            await _this.wait(500),
            _this.events.fire(UI.INITIAL_REPORT_RIPPLE),
            _this.events.fire(UISection.OPEN_REPORT));
      }
      function openCustomise({ productCode: productCode }) {
        (_customise = _this.initClass(UICustomise, productCode)),
          _joystick.animateOut(),
          _logo.customize(!0),
          _section.element
            .tween({ opacity: 0 }, 700, "easeOutCubic")
            .onComplete(() => {
              _section.element.invisible();
            });
      }
      async function closeCustomise() {
        _logo.customize(!1),
          _customise.animateOut(),
          (_customise = null),
          _joystick.animateIn(),
          _section.element
            .visible()
            .tween({ opacity: 1 }, 1e3, "easeInOutCubic", 700),
          await _this.wait(800),
          (_section.isCustomise = !1);
      }
      async function openReport() {
        (_previousPreset = Config.CURRENT_PRESET),
          await _this.wait(500),
          UIReport.instance().show(),
          UIReport.instance().generateReport(),
          _joystick.animateOut();
      }
      function closeReport() {
        (Config.CURRENT_PRESET = _previousPreset),
          Colors.instance().setShaderColors(!0),
          UIReport.instance().hide(),
          UIReport.instance().stopMovingCamera(),
          _joystick.animateIn();
      }
      function openModal({ textField: textField = !1 }) {
        _this.initClass(UIModal, textField);
      }
      function fade({ hide: hide }) {
        Car.instance().isDriving ||
          (_drivingAnimation && _drivingAnimation.stop(),
          _fadeAnimation && _fadeAnimation.stop(),
          (_fadeAnimation = _section.element.tween(
            { opacity: hide ? 0 : 1 },
            400,
            hide ? "easeOutQuint" : "easeInOutCubic",
            hide ? 0 : 150
          )));
      }
      Inherit(this, Element);
      const _this = this,
        $this = this.element;
      let _logo,
        _menu,
        _contact,
        _joystick,
        _section,
        _introText,
        _customise,
        _drivingAnimation,
        _fadeAnimation;
      var _previousPreset;
      initHTML(), initViews(), addHandlers();
      let _start;
      (this.updateColors = async function () {
        await defer(),
          _section && _section.changeColor(Colors.instance().UI.main);
      }),
        (this.UISectionActive = function () {
          return _section.activeIndex;
        });
    },
    "singleton",
    () => {
      (UI.OPEN_MODAL = "event_open_modal"),
        (UI.CLOSE_MODAL = "event_close_modal"),
        (UI.INITIAL_REPORT_RIPPLE = "event_initial_report_ripple"),
        (UI.FADE = "event_ui_fade");
    }
  ),
  Class(function UIButton(_text) {
    function init() {
      ($cont = $this.create("Container")),
        ($bg = $cont.create("Background")),
        ($text = $cont.create("Text")),
        $this.css({}),
        $cont.css({ position: "relative", opacity: 0 }),
        $bg.css({
          width: "100%",
          height: "100%",
          opacity: 1,
          borderRadius: 20,
          boxShadow: `0px 0px 0px 2px ${
            Colors.instance().UI.main
          }, 0px 0px 40px 0px ${Colors.instance().UI.main}`,
        }),
        $text
          .html(_text)
          .css({
            opacity: 1,
            position: "relative",
            padding: "14px 50px",
            textTransform: "uppercase",
            fontSize: 13,
            lineHeight: 13,
            letterSpacing: "0.15em",
            color: Colors.instance().UI.main,
          });
    }
    function addHandlers() {
      $text.interact(hover, click);
    }
    function hover(e) {
      switch (e.action) {
        case "over":
          $bg.tween({ opacity: 0.5 }, 300, "easeOutSine"),
            $text.tween({ opacity: 0.8 }, 200, "easeOutSine");
          break;
        case "out":
          $bg.tween({ opacity: 1 }, 500, "easeOutSine"),
            $text.tween({ opacity: 1 }, 200, "easeOutSine");
      }
    }
    function click() {
      _this.onClick && _this.onClick();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $cont, $bg, $text;
    init(),
      addHandlers(),
      (this.changeColor = function (color) {
        _this.clearTimers(),
          _this.delayedCall(() => {
            $bg.css({
              boxShadow: `0px 0px 0px 2px ${color}, 0px 0px 40px 0px ${color}`,
            }),
              $text.css({ color: color });
          }, 300);
      }),
      (_this.animateIn = function () {
        $cont.transform({ y: -5 }),
          $cont.tween({ opacity: 1, y: 0 }, 2e3, "easeOutCubic", 1e3);
      }),
      (this.bounce = function () {
        $cont.tween(
          { scale: 0.92, y: 0, opacity: 0 },
          300,
          "easeOutSine",
          (_) => {
            $cont.tween({ scale: 1, opacity: 1 }, 2e3, "easeOutQuart", 500);
          }
        );
      }),
      (_this.animateOut = async function (callback) {
        await $cont.tween({ opacity: 0, y: 10 }, 1e3, "easeOutCubic").promise(),
          callback && callback();
      });
  }),
  Class(function UIConfirmationPopup(type, preset) {
    function init() {
      ($cnt = $this.create("Cnt")),
        ($inner = $cnt.create("Inner")),
        ($title = $inner.create("Title")).text(TITLE_TEXT),
        ($button = $inner.create("Button")).text(BUTTON_TEXT),
        ($border = $button.create("border")),
        ($glow = $button.create("glow")),
        "delete" === type &&
          (($button2 = $inner.create("Button")).text(BUTTON2_TEXT),
          ($border2 = $button2.create("border")),
          ($glow2 = $button2.create("glow")));
    }
    function style() {
      $this.css({
        display: "table",
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 999,
        opacity: 0,
        willChange: "opacity",
        backgroundColor: "rgba(16, 21, 26, 0.85)",
      }),
        $cnt.css({
          display: "table-cell",
          position: "relative",
          verticalAlign: "middle",
          height: "auto",
          textAlign: "center",
        }),
        $inner.css({ position: "relative", width: 600, margin: "auto" }),
        $title.css({
          position: "relative",
          fontFamily: "bebas",
          textTransform: "uppercase",
          fontSize: 18,
          color: "#fff",
          letterSpacing: "0.18em",
          marginBottom: 20,
        }),
        $button.css({
          position: "relative",
          display: "inline-block",
          fontSize: 14,
          margin: "0 10px",
          minWidth: 60,
          lineHeight: "1.8em",
          letterSpacing: "0.18em",
          color: "#fff",
          padding: "7px 12px",
          border: "1px solid rgba(255, 255, 255, 0.5)",
          borderRadius: 25,
        }),
        $border
          .size("100%", "100%")
          .css({
            top: 0,
            left: 0,
            opacity: 0.3,
            borderRadius: 1e3,
            boxShadow: "rgb(255, 255, 255) 0px 0px 0px 2px",
          }),
        $glow
          .size("100%")
          .css({
            top: 0,
            left: 0,
            boxShadow: "0 0 10px rgb(255, 255, 255)",
            opacity: 0,
            top: 0,
            borderRadius: 1e3,
          }),
        "delete" === type &&
          ($button2.css({
            position: "relative",
            display: "inline-block",
            fontSize: 14,
            margin: "0 10px",
            minWidth: 60,
            lineHeight: "1.8em",
            letterSpacing: "0.18em",
            color: "#fff",
            padding: "7px 12px",
            border: "1px solid rgba(255, 255, 255, 0.5)",
            borderRadius: 25,
          }),
          $border2
            .size("100%", "100%")
            .css({
              top: 0,
              left: 0,
              opacity: 0.3,
              borderRadius: 1e3,
              boxShadow: "rgb(255, 255, 255) 0px 0px 0px 2px",
            }),
          $glow2
            .size("100%")
            .css({
              top: 0,
              left: 0,
              boxShadow: "0 0 10px rgb(255, 255, 255)",
              opacity: 0,
              top: 0,
              borderRadius: 1e3,
            }));
    }
    function animateIn() {
      $this.tween({ opacity: 1 }, 750, "easeInOutCubic"),
        $title
          .transform({ y: 30 })
          .css({ opacity: 0 })
          .tween({ y: 0, opacity: 1 }, 1200, "easeOutQuint", 500),
        $button
          .transform({ y: 30 })
          .css({ opacity: 0 })
          .tween({ y: 0, opacity: 1 }, 1200, "easeOutQuint", 550),
        "delete" === type &&
          $button2
            .transform({ y: 30 })
            .css({ opacity: 0 })
            .tween({ y: 0, opacity: 1 }, 1200, "easeOutQuint", 600);
    }
    function hoverButton(e, button = 0) {
      switch (e.action) {
        case "over":
          (1 === button ? $glow2 : $glow).tween(
            { opacity: 0.8 },
            300,
            "easeOutSine"
          ),
            (1 === button ? $border2 : $border).tween(
              { opacity: 0.8 },
              300,
              "easeOutSine"
            );
          break;
        case "out":
          (1 === button ? $glow2 : $glow).tween(
            { opacity: 0 },
            500,
            "easeOutSine"
          ),
            (1 === button ? $border2 : $border).tween(
              { opacity: 0.3, boxShadowColor: "#fff" },
              500,
              "easeOutSine"
            );
      }
    }
    async function close() {
      _this.isClosing ||
        ((_this.isClosing = !0),
        await $this.tween({ opacity: 0 }, 650, "easeInOutCubic").promise(),
        _this.destroy());
    }
    function addHandlers() {
      "delete" === type
        ? ($button.interact(hoverButton, () => {
            _this.onConfirm && _this.onConfirm(), close();
          }),
          $button2.interact((e) => {
            hoverButton(e, 1);
          }, close))
        : $button.interact(hoverButton, close);
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    $this._willChangeLock = !0;
    var $cnt,
      $inner,
      $title,
      $button,
      $border,
      $glow,
      $button2,
      $border2,
      $glow2;
    const TITLE_TEXT =
        "url" === type
          ? Data.copy("REPORT_SHARE_COPIED")
          : "preset" === type
          ? Data.copy("RESET_TEXT") + " " + preset
          : Data.copy("REPORT_DELETE_ALL_CONFIRM"),
      BUTTON_TEXT = Data.copy(
        "url" === type
          ? "REPORT_SHARE_BUTTON"
          : "preset" === type
          ? "RESET_BUTTON_TEXT"
          : "REPORT_DELETE_ALL_OK"
      ),
      BUTTON2_TEXT =
        "delete" === type ? Data.copy("REPORT_DELETE_ALL_CANCEL") : "";
    init(), style(), addHandlers(), animateIn();
  }),
  Class(function UIContactLink() {
    function initHTML() {
      $this.text(Data.copy("UI_CONTACT_TEXT")),
        $this.css({
          color: "#fff",
          fontFamily: "bebas",
          fontSize: 16,
          textTransform: "uppercase",
          letterSpacing: 2,
          bottom: 40,
          left: 40,
          opacity: 0,
          paddingLeft: 20,
          textDecoration: "none",
          zIndex: 99,
        }),
        ($line = $this.create("Line")).css({
          background: "#fff",
          padding: "1px 6px",
          margin: "-1px 0",
          borderRadius: 2,
          top: "50%",
          left: 0,
        });
    }
    function addHandlers() {
      $this.interact(hover, (_) => {
        _this.events.fire(UI.OPEN_MODAL, { textField: !0 });
      }),
        _this.events.sub(UISection.OPEN_CUSTOMISE, changeColor),
        _this.events.sub(UISection.CLOSE_CUSTOMISE, changeColor),
        _this.events.sub(UI.FADE, fade);
    }
    function fade({ hide: hide }) {
      _fadeAnimation && _fadeAnimation.stop(),
        (_fadeAnimation = $this.tween(
          { opacity: hide ? 0 : 0.6 },
          600,
          "easeOutCubic"
        ));
    }
    function changeColor(e) {
      let bgColor = e.productCode ? darkLineColor : "#ffffff";
      $this.tween({ color: bgColor }, 600, "easeOutCubic"),
        $line.tween({ backgroundColor: bgColor }, 600, "easeOutCubic");
    }
    function hover({ action: action }) {
      "over" === action
        ? ($line.tween({ x: 2 }, 400, "easeOutCubic"),
          $this.tween({ opacity: 1 }, 400, "easeOutCubic"))
        : ($line.tween({ x: 0 }, 400, "easeOutCubic"),
          $this.tween({ opacity: 0.6 }, 400, "easeOutCubic"));
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element,
      darkLineColor = "#3c3c3c";
    var $line, _fadeAnimation;
    initHTML(),
      addHandlers(),
      (this.animateIn = function () {
        $this.tween({ opacity: 0.6 }, 2e3, "easeOutCubic");
      }),
      (this.animateOut = function () {
        $this.tween({ opacity: 0 }, 700, "easeOutCubic");
      });
  }),
  Class(function CookiesView() {
    function initHTML() {
      $this
        .size("100%", "auto")
        .css({ position: "fixed", bottom: 0, left: 0 })
        .bg(Config.COOKIES_BG_COLOR)
        .fontStyle("montserrat", 12, "white")
        .setZ(105)
        .invisible(),
        ($cnt = $this.create("Cnt")).css({
          position: "relative",
          margin: "auto",
          maxWidth: size,
          padding: "20px 10px 17px 10px",
        }),
        ($text = $cnt.create("Text")).css({
          display: "block",
          position: "relative",
          paddingRight: btnCntSize,
        }),
        $text.text(Data.COPY.COOKIES_TEXT),
        ($btnCnt = $cnt.create("ButtonsCnt"))
          .size(btnCntSize, 40)
          .css({ display: "block", top: 0, right: 10, textAlign: "center" })
          .center(!1, !0),
        ($buttonOk = _this.initClass(CookiesViewButton, {
          text: Data.copy("COOKIES_OK"),
          url: !1,
        })),
        $btnCnt.add($buttonOk),
        ($buttonInfo = _this.initClass(CookiesViewButton, {
          text: Data.copy("COOKIES_MORE"),
          url: Data.copy("COOKIES_MORE_URL"),
        })),
        $btnCnt.add($buttonInfo);
    }
    function animateIn() {
      $this
        .visible()
        .transform({ y: "100%" })
        .tween({ y: "0%" }, 600, "easeOutQuad");
    }
    async function animateOut() {
      await $this.tween({ y: "100%" }, 600, "easeOutQuad").promise(),
        _this.destroy();
    }
    function addHandlers() {
      _this.events.sub($buttonOk, CookiesViewButton.CLICK_OK, clickOK);
    }
    function clickOK() {
      Storage.set("autoneum_cookies_accepted", "true"),
        cookiesAccepted(),
        animateOut();
    }
    function cookiesAccepted() {}
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    var $cnt,
      $text,
      $btnCnt,
      $buttonOk,
      $buttonInfo,
      size = 900,
      btnCntSize = 280;
    !(async function () {
      await _this.wait(Data, "dataReady"),
        initHTML(),
        addHandlers(),
        await _this.wait(1e3),
        animateIn();
    })();
  }),
  Class(
    function CookiesViewButton(options) {
      function initHTML() {
        $this
          .size("auto", 21)
          .css({
            position: "relative",
            display: "inline-block",
            borderRadius: 15,
            margin: "9px 10px 0px 10px",
            padding: "0 20px",
            lineHeight: 22,
            textTransform: "uppercase",
            letterSpacing: 2,
            cursor: "pointer",
          })
          .fontStyle("din", 10, "white"),
          ($border = $this.create("border"))
            .size("100%", "100%")
            .css({
              top: 0,
              left: 0,
              opacity: 0.3,
              borderRadius: 1e3,
              boxShadow: "rgb(255, 255, 255) 0px 0px 0px 2px",
            }),
          ($glow = $this.create("glow"))
            .size("100%")
            .css({
              top: 0,
              left: 0,
              boxShadow: "0 0 10px rgb(255, 255, 255)",
              opacity: 0,
              top: 0,
              borderRadius: 1e3,
            }),
          $this.text(options.text);
      }
      function addHandlers() {
        $this.interact(hover, click);
      }
      function hover(e) {
        switch (e.action) {
          case "over":
            $glow.tween({ opacity: 0.8 }, 300, "easeOutSine"),
              $border.tween({ opacity: 0.8 }, 300, "easeOutSine");
            break;
          case "out":
            $glow.tween({ opacity: 0 }, 500, "easeOutSine"),
              $border.tween(
                { opacity: 0.3, boxShadowColor: "#fff" },
                500,
                "easeOutSine"
              );
        }
      }
      function click() {
        _url
          ? window.open(_url, "_blank")
          : _this.events.fire(CookiesViewButton.CLICK_OK);
      }
      Inherit(this, Element);
      const _this = this,
        $this = this.element;
      var $border,
        $glow,
        _url = options.url;
      initHTML(), addHandlers();
    },
    () => {
      CookiesViewButton.CLICK_OK = "click_ok_cookies";
    }
  ),
  Class(function UICustomise(_productCode) {
    function init() {
      $this.invisible().setZ(30),
        (_this.isComplex = !!Configuration.getProductVariables(_productCode));
      const dataPromise = _this.isComplex
        ? API.getProductData(_productCode)
        : Promise.resolve(
            Meta.getProductTechnologyOption(
              _productCode,
              Configuration.getProductTechnologyOption(_productCode)
            )
          );
      ($container = $this.create("Container")),
        (_info = _this.initClass(UICustomiseInfo, _productCode, dataPromise)),
        $container.add(_info.element),
        ($productCatch = $container.create("ProductCatch")),
        ($crossCatch = $container.create("CrossCatch")),
        ProductSolo.instance().addCameraCatch($productCatch),
        CrossSection.instance().addCameraCatch($crossCatch),
        ($graphs = $container.create("Graphs"));
      let keyValuesTab = ($graphsTabs = $graphs.create("GraphTabs")).create(
        "KeyValuesTab"
      );
      keyValuesTab.text(Data.copy("KEY_VALUES")),
        (keyValuesTab.__popup = _this.initClass(
          UICustomisePopup,
          Data.copy("KEY_VALUES_POPUP"),
          "left"
        )),
        keyValuesTab.add(keyValuesTab.__popup),
        (keyValuesTab.__track = "key-values");
      const keyValues = _this.initClass(UICustomiseKeyValues, _productCode);
      if (
        ($graphs.add(keyValues.element),
        _graphTabs.push(keyValuesTab),
        _graphs.push(keyValues),
        _this.isComplex)
      ) {
        const transmissionTab = $graphsTabs.create("TransmissionTab");
        transmissionTab.text(Data.copy("TRANSMISSION_LOSS")),
          (transmissionTab.__popup = _this.initClass(
            UICustomisePopup,
            Data.copy("TRANSMISSION_LOSS_POPUP")
          )),
          transmissionTab.add(transmissionTab.__popup),
          (transmissionTab.__track = "transmission-loss");
        const transmission = _this.initClass(
          UICustomiseGraph,
          "tl",
          dataPromise
        );
        $graphs.add(transmission.element);
        const absorptionTab = $graphsTabs.create("AbsorptionTab");
        absorptionTab.text(Data.copy("ABSORPTION")),
          (absorptionTab.__popup = _this.initClass(
            UICustomisePopup,
            Data.copy("ABSORPTION_POPUP")
          )),
          absorptionTab.add(absorptionTab.__popup),
          (absorptionTab.__track = "absorption");
        const absorption = _this.initClass(
          UICustomiseGraph,
          "abs",
          dataPromise
        );
        $graphs.add(absorption.element),
          _graphTabs.push(transmissionTab),
          _graphTabs.push(absorptionTab),
          _graphs.push(transmission),
          _graphs.push(absorption);
      }
      _this.isComplex &&
        ((_variables = _this.initClass(UICustomiseVariables, _productCode)),
        $container.add(_variables.element),
        (_variables.onChange = updateData)),
        ((_technologies = _this.isComplex
          ? _this.initClass(UICustomiseTechnologiesComplex, _productCode)
          : _this.initClass(
              UICustomiseTechnologiesSimple,
              _productCode
            )).onChange = updateData),
        $container.add(_technologies.element),
        (_closePrompt = _this.initClass(UICustomiseClose)),
        Track.event("customise", "open", "customise-cta"),
        Track.page(`/customise/${Data.product(_productCode).perma}`);
    }
    function style() {
      $this.css({ position: "static" }),
        $container.size(1200, 660).center(),
        _info.element
          .size(400, 220)
          .css({ position: "absolute", top: 0, left: 0 }),
        $productCatch
          .size(400, 220)
          .css({ position: "absolute", top: 0, left: 400 }),
        $crossCatch
          .size(400, 220)
          .css({ position: "absolute", top: 0, left: 800 }),
        $graphs
          .size(400, 450)
          .css({ position: "absolute", top: 220, left: 0, zIndex: 10 }),
        _variables &&
          _variables.element
            .size(400, 450)
            .css({ position: "absolute", top: 220, left: 400 }),
        _technologies &&
          (_this.isComplex
            ? _technologies.element
                .size(400, 450)
                .css({ position: "absolute", top: 220, left: 800 })
            : _technologies.element
                .size(800, 450)
                .css({ position: "absolute", top: 220, left: 400 })),
        $graphsTabs.css({ position: "relative" }),
        _graphTabs.forEach((tab, i) => {
          tab.css({
            position: "relative",
            display: "inline-block",
            textTransform: "uppercase",
            fontFamily: "din",
            fontSize: 12,
            fontWeight: "bold",
            letterSpacing: "0.1em",
            lineHeight: 50,
            color: 0 === i ? "#000" : "#b7b7b7",
            marginRight: 20,
          });
        }),
        _listenPrompt && _listenPrompt.element.css({ bottom: 20 });
    }
    function animateIn() {
      _listenPrompt && _listenPrompt.animateIn(), $this.visible();
      let elements = [];
      (elements = elements.concat(_info.elements)).push($graphs),
        _variables && (elements = elements.concat(_variables.elements)),
        _technologies && (elements = elements.concat(_technologies.elements)),
        _listenPrompt && elements.push(_listenPrompt.element);
      let delay = 1e3;
      elements.forEach(($el, i) => {
        $el
          .transform({ scale: 1, y: 30 })
          .css({ opacity: 0 })
          .tween({ y: 0, scale: 1, opacity: 1 }, 1e3, "easeOutQuart", delay),
          (delay += 100);
      });
    }
    function addHandlers() {
      (_closePrompt.onClick = onClose),
        _this.onResize(resize),
        $productCatch.interact(productHover, () => {}),
        $productCatch.hit.css({ cursor: "default" }),
        $crossCatch.interact(crossHover, () => {}),
        $crossCatch.hit.css({ cursor: "default" }),
        _graphTabs.forEach((tab, i) => {
          tab.interact(
            function hover(e) {
              e.object.__popup && e.object.__popup.hover(e);
            },
            function click(e) {
              i !== _currentTab &&
                (e.object.__popup && e.object.__popup.hover({ action: "out" }),
                _graphTabs[_currentTab].tween(
                  { color: "#b7b7b7" },
                  500,
                  "easeOutSine"
                ),
                _graphs[_currentTab].animateOut(),
                _graphTabs[(_currentTab = i)].tween(
                  { color: "#000000" },
                  500,
                  "easeOutSine"
                ),
                _graphs[_currentTab].animateIn(),
                Track.event("product-detail", "graph-nav", e.object.__track));
            }
          ),
            _graphTabs.length < 2 && tab.hit.css({ cursor: "default" });
        });
    }
    function productHover(e) {
      switch (e.action) {
        case "over":
          (_productDolly.value = 0),
            tween(
              _productDolly,
              { value: _zoomAmount },
              1e3,
              "easeOutCubic"
            ).onUpdate(() => {
              ProductSolo.instance().camera.dolly(
                1 + _zoomAmount - _productDolly.value
              );
            });
          break;
        case "out":
          (_productDolly.value = 0),
            tween(
              _productDolly,
              { value: _zoomAmount },
              1e3,
              "easeOutCubic"
            ).onUpdate(() => {
              ProductSolo.instance().camera.dolly(
                1 - _zoomAmount + _productDolly.value
              );
            });
      }
    }
    function crossHover(e) {
      switch (e.action) {
        case "over":
          (_crossDolly.value = 0),
            tween(
              _crossDolly,
              { value: _zoomAmount },
              1e3,
              "easeOutCubic"
            ).onUpdate(() => {
              CrossSection.instance().camera.dolly(
                1 + _zoomAmount - _crossDolly.value
              );
            });
          break;
        case "out":
          (_crossDolly.value = 0),
            tween(
              _crossDolly,
              { value: _zoomAmount },
              1e3,
              "easeOutCubic"
            ).onUpdate(() => {
              CrossSection.instance().camera.dolly(
                1 - _zoomAmount + _crossDolly.value
              );
            });
      }
    }
    function onClose() {
      _this.isDestroying ||
        (Track.page("/customise"),
        _this.events.fire(UISection.CLOSE_CUSTOMISE));
    }
    function resize() {
      let scaleH = Math.min(1, (Stage.width - 90) / 1200),
        scaleV = Math.min(1, (Stage.height - 30) / 745),
        scale = Math.min(scaleH, scaleV);
      $container.transform({ scale: scale });
    }
    function updateData() {
      const dataPromise = _this.isComplex
        ? API.getProductData(_productCode)
        : Promise.resolve(
            Meta.getProductTechnologyOption(
              _productCode,
              Configuration.getProductTechnologyOption(_productCode)
            )
          );
      _info.updateWeight(dataPromise),
        _graphs.forEach((graph) => {
          graph.updateData(dataPromise);
        });
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let _closePrompt,
      _info,
      _variables,
      _technologies,
      _listenPrompt,
      $container,
      $productCatch,
      $crossCatch,
      $graphs,
      $graphsTabs,
      _graphTabs = [],
      _graphs = [],
      _currentTab = 0,
      _productDolly = { value: 0 },
      _crossDolly = { value: 0 },
      _zoomAmount = 0.01;
    init(),
      style(),
      animateIn(),
      addHandlers(),
      (this.animateIn = function () {}),
      (this.animateOut = async function () {
        (_this.isDestroying = !0),
          await $this.tween({ opacity: 0 }, 800, "easeOutCubic").promise(),
          _this.destroy();
      });
  }),
  Class(function UICustomiseGraph(_type, _dataPromise) {
    function init() {
      (_graph = _this.initClass(Graph, 370, 235, {
        xAxis: "100 315 1000 3150 10000",
        label: Data.copy("FREQUENCY"),
      })),
        defer(() => {
          _this.updateData(_dataPromise);
        });
    }
    function style() {
      $this.css({ width: 370, height: 370, background: "rgba(0, 0, 0, 0.03)" }),
        _graph.element.css({ marginTop: 60 }),
        $this.css({ opacity: 0 }).hide();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let _graph;
    init(),
      style(),
      (this.animateIn = function () {
        $this.show(), $this.tween({ opacity: 1 }, 2e3, "easeOutCubic");
      }),
      (this.animateOut = async function () {
        await $this.tween({ opacity: 0 }, 1e3, "easeOutCubic").promise(),
          $this.hide();
      }),
      (this.updateData = async function (dataPromise) {
        const data = await dataPromise;
        if (!data || !data[_type]) return;
        if (!_graph || !_graph.setData) return;
        let curve = {
          label: _type,
          color: Colors.instance().UI.dark,
          points: null,
          min: null,
          max: null,
        };
        (curve.points = data[_type]),
          "abs" === _type
            ? ((curve.max = 1), (curve.min = 0))
            : ((curve.max = 120), (curve.min = 0)),
          _graph.setData(curve);
      });
  }),
  Class(function UICustomiseKeyValues(_productCode) {
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let _graph;
    const _titles = [];
    !(function () {
      $this.css({ width: 370, height: 370, background: "rgba(0, 0, 0, 0.02)" });
      const data = KeyValues.getProductKeyValues(_productCode);
      _graph = _this.initClass(UICustomiseSpiderGraph, data);
      const num = data.length;
      data.forEach((d, i) => {
        const angle = i * ((2 * Math.PI) / num),
          title = $this.create("Title");
        (title.__text = title.create("Text")),
          title.__text.html(`${d.name.replace(" ", "<br />")}`),
          (title.__popup = _this.initClass(
            UICustomisePopup,
            d.description,
            angle > Math.PI && angle < 2 * Math.PI ? "left" : "center",
            [title]
          )),
          title.interact(
            (e) => {
              e.object.__popup && e.object.__popup.hover(e);
            },
            () => {}
          ),
          title.hit.css({ cursor: "default" });
        let x = 80 * Math.sin(angle) + 185,
          y = 80 * Math.cos(angle) + 185;
        title.__text.css({ position: "relative" }),
          title.css({
            left: x,
            top: y,
            textTransform: "uppercase",
            fontSize: 11,
            letterSpacing: "0.1em",
            fontWeight: "bold",
            color: "#9a9a9a",
            opacity: 1,
            zIndex: Math.floor((Math.abs(angle - Math.PI) / Math.PI) * 10),
          }),
          (x = Math.sin(angle)),
          Math.abs(x) < 0.001 && (x = 0),
          (y = Math.cos(angle)),
          Math.abs(y) < 0.001 && (y = 0),
          title.css({
            textAlign: x ? (x < 0 ? "right" : "left") : "center",
            transform: `translate(${x ? (x < 0 ? "-100" : "0") : "-50"}%, ${
              y ? (y < 0 ? "-100" : "0") : "-50"
            }%)`,
          }),
          _titles.push(title);
      });
    })(),
      (this.animateIn = function () {
        $this.show(), $this.tween({ opacity: 1 }, 2e3, "easeOutCubic");
      }),
      (this.animateOut = async function () {
        await $this.tween({ opacity: 0 }, 1e3, "easeOutCubic").promise(),
          $this.hide();
      }),
      (this.updateData = function () {
        const data = KeyValues.getProductKeyValues(_productCode);
        data.forEach((d, i) => {
          _titles[i].__text.html(`${d.name.replace(" ", "<br />")}`),
            _titles[i].__popup.textContent.text(d.description);
        }),
          _graph.updateData(data);
      });
  }),
  Class(function UICustomiseSpiderGraph(_data) {
    function init() {
      $this.size(_width, _height).center().css({}),
        (_canvas = _this.initClass(Canvas, _width, _height)).element.css({
          width: _width,
          height: _height,
          position: "absolute",
          top: 0,
          left: 0,
        }),
        (_ctx = _canvas.context),
        $this.add(_canvas.element);
    }
    function drawBackground() {
      const size = _width,
        num = _data.length,
        r = 0.45;
      _ctx.beginPath();
      for (let i = 0; i < num; i++) {
        const angle = i * ((2 * Math.PI) / num);
        let x = r * Math.sin(angle) * size + 0.5 * size,
          y = r * Math.cos(angle) * size + 0.5 * size;
        i ? _ctx.lineTo(x, y) : _ctx.moveTo(x, y);
      }
      _ctx.closePath(),
        (_ctx.lineWidth = 5),
        (_ctx.strokeStyle = "#e5e5e5"),
        _ctx.stroke();
      for (let i = 0; i < num; i++) {
        const angle = i * ((2 * Math.PI) / num);
        _ctx.beginPath();
        let x = 0.5 * size,
          y = 0.5 * size;
        _ctx.moveTo(x, y),
          (x = r * Math.sin(angle) * size + 0.5 * size),
          (y = r * Math.cos(angle) * size + 0.5 * size),
          _ctx.lineTo(x, y),
          _ctx.closePath(),
          (_ctx.lineWidth = 1),
          (_ctx.strokeStyle = "#e5e5e5"),
          _ctx.stroke();
      }
    }
    function drawData(data) {
      const size = _width,
        num = data.length;
      _ctx.beginPath();
      for (let i = 0; i < num; i++) {
        const angle = i * ((2 * Math.PI) / num),
          r2 = (Math.clamp(0, 10, data[i].value) / 10) * 0.45;
        let x = r2 * Math.sin(angle) * size + 0.5 * size,
          y = r2 * Math.cos(angle) * size + 0.5 * size;
        i ? _ctx.lineTo(x, y) : _ctx.moveTo(x, y);
      }
      _ctx.closePath(),
        (_ctx.lineWidth = 1),
        (_ctx.strokeStyle = Colors.instance().UI.dark),
        _ctx.stroke(),
        _color.set(Colors.instance().UI.dark),
        (_ctx.fillStyle = `rgba(${255 * _color.r}, ${255 * _color.g}, ${
          255 * _color.b
        }, 0.1)`),
        _ctx.fill();
      for (let i = 0; i < num; i++) {
        const angle = i * ((2 * Math.PI) / num),
          r2 = (Math.clamp(0, 10, data[i].value) / 10) * 0.45;
        let x = r2 * Math.sin(angle) * size + 0.5 * size,
          y = r2 * Math.cos(angle) * size + 0.5 * size;
        _ctx.ellipse &&
          (_ctx.beginPath(),
          _ctx.ellipse(x, y, 1.5, 1.5, 0, 0, 2 * Math.PI),
          _ctx.closePath(),
          (_ctx.fillStyle = "#333"),
          _ctx.fill());
      }
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element,
      _width = 150,
      _height = 150;
    let _canvas, _ctx;
    var _color = new Color(Colors.instance().UI.dark);
    init(),
      drawBackground(),
      drawData(_data),
      (this.updateData = function (data) {
        _ctx.clearRect(0, 0, _width, _height), drawBackground(), drawData(data);
      });
  }),
  Class(function UICustomiseButton(_text) {
    function init() {
      ($cont = $this.create("Container")),
        ($bg = $cont.create("Background")),
        ($text = $cont.create("Text")),
        $this.css({}),
        $cont.css({ position: "relative", opacity: 0 }),
        $bg.css({
          width: "100%",
          height: "100%",
          borderRadius: 20,
          background: Colors.instance().UI.dark,
        }),
        $text
          .html(_text)
          .css({
            position: "relative",
            padding: "14px 30px",
            textTransform: "uppercase",
            fontSize: 11,
            letterSpacing: "0.15em",
            color: "#fff",
          });
    }
    function addHandlers() {
      $text.interact(hover, click);
    }
    function hover(e) {
      e.action;
    }
    function click() {
      _this.onClick && _this.onClick();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $cont, $bg, $text;
    init(),
      addHandlers(),
      (_this.animateIn = function () {
        $cont.transform({ y: -5 }),
          $cont.tween({ opacity: 1, y: 0 }, 2e3, "easeOutCubic");
      }),
      (_this.animateOut = async function (callback) {
        await $cont.tween({ opacity: 0, y: 5 }, 1e3, "easeOutCubic").promise(),
          callback && callback();
      });
  }),
  Class(function UICustomiseClose() {
    function init() {
      $this.css({
        top: "10%",
        left: "50%",
        padding: 30,
        margin: -30,
        opacity: 0.5,
      }),
        (_icon = _this.initClass(UIIcon, {
          size: 50,
          border: !0,
          icon: Tests.svgMask()
            ? "customise/close.svg"
            : "customise/close-dark.svg",
          color: "#222",
          hover: Colors.instance().UI.dark,
        })).element.css({ top: 0, left: 0 });
    }
    function addHandlers() {
      $this.interact(hover, click);
    }
    function hover(e) {
      switch (e.action) {
        case "over":
          _icon.hoverIn(Colors.instance().UI.main);
          break;
        case "out":
          _icon.hoverOut();
      }
    }
    function click() {
      _this.onClick && _this.onClick();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    var _icon;
    init(), addHandlers();
  }),
  Class(function UICustomiseInfo(_productCode, _dataPromise) {
    function init() {
      ($title = $this.create("Title")),
        ($weight = $this.create("Weight")),
        ($desc = $this.create("Description"));
      const data = Data.product(_productCode);
      $title.text(data.name),
        $desc.text(data.description),
        (_this.elements = [$title, $weight, $desc]),
        updateWeight(_dataPromise);
    }
    function style() {
      $this.css({ width: 400, height: 220 }),
        $title.css({
          position: "relative",
          textTransform: "uppercase",
          fontFamily: "bebas",
          fontSize: 40,
          letterSpacing: "0.08em",
          color: Colors.instance().UI.dark,
          marginBottom: 20,
        }),
        $weight.css({
          position: "relative",
          fontSize: 13,
          textTransform: "uppercase",
          letterSpacing: "0.13em",
          color: "#222",
          fontWeight: "bold",
          marginBottom: 10,
        }),
        $desc.css({
          position: "relative",
          fontFamily: "montserrat",
          fontSize: Tests.smallTablet() ? 12 : 11,
          lineHeight: "1.6em",
          color: "#222",
          opacity: 0.6,
          overflow: "auto",
          paddingRight: 30,
        });
    }
    async function updateWeight(promise) {
      $weight.text(
        `${Data.copy("PRODUCT_WEIGHT")}: ${Data.copy(
          "PRODUCT_WEIGHT_CALCULATING"
        )}`
      );
      const data = await promise;
      $weight.text(
        `${Data.copy("PRODUCT_WEIGHT")}: ${Math.round(data.weight, 2)}kg`
      );
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $title, $weight, $desc;
    init(), style(), (this.updateWeight = updateWeight);
  }),
  Class(function UICustomisePopup(copy = "", align = "center", graph = !1) {
    function init() {
      $this.css({
        width: 300,
        bottom: "100%",
        marginBottom: graph ? 20 : 0,
        padding: "15px 25px",
        backgroundColor: "#000",
        color: "#bfbfbf",
        borderRadius: 5,
        fontFamily: "montserrat",
        fontSize: Tests.smallTablet() ? 12 : 11,
        lineHeight: "1.6em",
        fontWeight: "normal",
        letterSpacing: "initial",
        textTransform: "initial",
        textAlign: "left",
        pointerEvents: "none",
        opacity: 0,
      }),
        "center" === align
          ? $this.css({ left: "calc(50% - 340px / 2)" })
          : $this.css({ left: "calc(50% - 340px / 4)" }),
        $this.transform({ y: -10 }),
        (_this.textContent = $this.create("Text", "span")),
        _this.textContent.css({ position: "relative", textTransform: "none" }),
        _this.textContent.text(copy),
        ($square = $this.create("Square")).css({
          width: 10,
          height: 10,
          bottom: -5,
          backgroundColor: "#000",
        }),
        "center" === align
          ? $square.css({ left: "calc(50% - 5px / 2)" })
          : $square.css({ left: "calc(25% - 5px / 2)" }),
        $square.transform({ rotation: 45 }),
        $this.hide();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    var $square;
    init(),
      (this.hover = function (e) {
        switch (e.action) {
          case "over":
            $this.show(),
              $this.tween({ opacity: 1, y: 0 }, 750, "easeOutCubic");
            break;
          case "out":
            $this
              .tween({ opacity: 0, y: -10 }, 750, "easeOutCubic")
              .onComplete(() => {
                $this.hide();
              });
        }
      });
  }),
  Class(function UICustomiseTechnologiesComplex(_productCode) {
    function init() {
      const $title = $this.create("Title");
      ($container = $this.create("Container")),
        $title.text(Data.copy("TECHNOLOGIES")),
        ($dropdowns = $container.create("DropDowns")),
        ($highlights = $container.create("Highlights")),
        _technologies.forEach(addDropdown),
        _technologies.forEach(addHighlight),
        $this.css({
          position: "relative",
          display: "inline-block",
          width: 400,
          height: 450,
          color: "#000000",
        }),
        $title.css({
          position: "relative",
          textTransform: "uppercase",
          fontSize: 12,
          fontWeight: "bold",
          letterSpacing: "0.1em",
          lineHeight: "4em",
          marginLeft: 30,
          opacity: "0.8",
        }),
        _this.elements.push($title),
        _this.elements.push($dropdowns),
        _this.elements.push($highlights),
        $container.css({
          position: "relative",
          width: 370,
          height: 350,
          marginLeft: "30px",
        }),
        $dropdowns.hide();
    }
    function addDropdown(technology, i) {
      const $technology = $dropdowns.create("Technology"),
        $title = $technology.create("Title");
      _dropdowns.push($technology),
        $title.text(technology.name),
        $technology.css({
          position: "relative",
          padding: "15px 20px",
          border: "2px solid #ddd",
          borderRadius: 5,
          display: "block",
          width: "100%",
          marginBottom: 8,
        }),
        $title.css({
          position: "relative",
          textTransform: "uppercase",
          fontSize: 12,
          fontWeight: "bold",
          letterSpacing: "0.1em",
          opacity: "0.6",
        }),
        $technology.interact(
          function hover(e) {
            if (e.object !== $dropdowns.active)
              switch (e.action) {
                case "over":
                  $title.tween({ opacity: 1 }, 300, "easeOutSine"),
                    $technology.tween(
                      { borderColor: Colors.instance().UI.dark },
                      500,
                      "easeOutSine"
                    );
                  break;
                case "out":
                  $title.tween({ opacity: 0.6 }, 300, "easeOutSine"),
                    $technology.tween(
                      { borderColor: "#ddd" },
                      500,
                      "easeOutSine"
                    );
              }
          },
          function click(e) {
            e.object !== $dropdowns.active &&
              (Track.event(
                "product-detail",
                "technology-select",
                _product.perma + "/" + technology.perma
              ),
              Configuration.setProductTechnology(_productCode, technology.code),
              CrossSection.instance().updateTechnology(technology.perma),
              _this.onChange && _this.onChange()),
              showHighlight(i);
          }
        );
    }
    function addHighlight(technology, i) {
      const _highlight = _this.initClass(
        UICustomiseTechnologyHighlight,
        technology,
        _initialState,
        _productCode,
        [$highlights]
      );
      (_highlight.onClick = showDropdowns),
        (_highlight.onChange = () => _this.onChange && _this.onChange()),
        _highlights.push(_highlight),
        _initialState[technology.code]
          ? (($highlights.active = _highlight),
            ($dropdowns.active = _dropdowns[i]),
            _highlight.show())
          : _highlight.hide();
    }
    function showHighlight(index) {
      $dropdowns.tween({ opacity: 0 }, 400, "easeOutSine", (_) => {
        $dropdowns.hide();
      }),
        $highlights
          .show()
          .css({ opacity: 0 })
          .transform({ y: 20, scale: 1 })
          .tween({ opacity: 1, y: 0 }, 1200, "easeOutQuart", 200),
        $highlights.active.hide(),
        ($highlights.active = _highlights[index]),
        ($dropdowns.active = _dropdowns[index]),
        $highlights.active.show();
    }
    function showDropdowns() {
      $highlights.tween(
        { opacity: 0, scale: 0.95, y: 0 },
        400,
        "easeOutSine",
        (_) => {
          $highlights.hide();
        }
      ),
        $dropdowns
          .show()
          .css({ opacity: 0 })
          .tween({ opacity: 1 }, 500, "easeOutSine", 200),
        _dropdowns.forEach(($dropdown, i) => {
          $dropdown
            .css({
              opacity: 0,
              borderColor:
                $dropdown !== $dropdowns.active
                  ? "#ddd"
                  : Colors.instance().UI.dark,
            })
            .transform({ y: 20 })
            .tween({ opacity: 1, y: 0 }, 800, "easeOutQuart", 100 * i);
        });
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element,
      _initialState = Configuration.getProduct(_productCode).technology,
      _product = Meta.PRODUCT(_productCode),
      _technologies = _product.technologies;
    let $container, $dropdowns, $highlights;
    const _dropdowns = [],
      _highlights = [];
    (_this.elements = []), init();
  }),
  Class(function UICustomiseTechnologiesSimple(_productCode) {
    function init() {
      const $title = $this.create("Title");
      ($container = $this.create("Container")),
        $title.text(Data.copy("TECHNOLOGIES")),
        _this.elements.push($title),
        $columns.push($container.create("ColumnLeft")),
        $columns.push($container.create("ColumnRight")),
        _technologies.forEach(addTechnology),
        $this.css({
          position: "relative",
          display: "inline-block",
          width: 800,
          height: 440,
          color: "#000000",
        }),
        $title.css({
          position: "relative",
          textTransform: "uppercase",
          fontSize: 12,
          fontWeight: "bold",
          letterSpacing: "0.1em",
          lineHeight: 50,
          padding: "0px 15px",
          opacity: "0.8",
        }),
        $container.css({
          position: "relative",
          width: 770,
          height: 350,
          margin: "0px 15px",
        }),
        $columns[0].css({
          position: "absolute",
          display: "inline-block",
          left: 0,
          width: 370,
        }),
        $columns[1].css({
          position: "absolute",
          top: 0,
          left: 415,
          width: 370,
        });
    }
    function addTechnology(technology, index) {
      let $technology;
      const $title = ($technology =
          _technologies.length < 3
            ? $columns[index % 2].create("Technology")
            : $columns[index < 2 ? 0 : 1].create("Technology")).create("Title"),
        $description = $technology.create("Description");
      _this.elements.push($technology),
        $title.text(technology.name),
        $description.text(technology.description || "To be connected."),
        $technology.css({
          position: "relative",
          padding: "15px 20px",
          border: "2px solid rgba(0, 0, 0, 0.1)",
          borderRadius: 5,
          marginBottom: 8,
        }),
        $title.css({
          position: "relative",
          textTransform: "uppercase",
          fontSize: 12,
          fontWeight: "bold",
          letterSpacing: "0.1em",
          opacity: "0.8",
          marginBottom: 5,
        }),
        $description.css({
          position: "relative",
          fontFamily: "montserrat",
          fontSize: 10,
          lineHeight: "1.6em",
          opacity: "0.6",
        }),
        technology.code === _initialState
          ? ((_this.active = $technology), select($technology, !0))
          : deselect($technology, !0),
        $technology.interact(
          function hover() {},
          function click() {
            _this.active !== $technology &&
              (deselect(_this.active),
              (_this.active = $technology),
              select(_this.active),
              Track.event(
                "product-detail",
                "technology-option-select",
                _product.perma + "/" + technology.perma
              ),
              Configuration.setProductTechnologyOption(
                _productCode,
                technology.code
              ),
              CrossSection.instance().updateTechnology(technology.perma),
              _this.onChange && _this.onChange());
          }
        );
    }
    function select($technology, isImmediate) {
      isImmediate
        ? $technology.css({ border: "2px solid " + Colors.instance().UI.dark })
        : $technology.tween(
            { border: "2px solid " + Colors.instance().UI.dark },
            300,
            "easeOutSine"
          );
    }
    function deselect($technology, isImmediate) {
      isImmediate
        ? $technology.css({ border: "2px solid rgba(0, 0, 0, 0.1)" })
        : $technology.tween(
            { border: "2px solid rgba(0, 0, 0, 0.1)" },
            isImmediate ? 0 : 300,
            "easeOutSine"
          );
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element,
      _initialState = String(
        Configuration.getProductTechnologyOption(_productCode)
      ),
      _product = Meta.PRODUCT(_productCode),
      _technologies = _product.technologyOptions;
    _technologies.sort((a, b) =>
      "nothing" === a.perma ? -1 : "nothing" === b.perma ? 1 : 0
    );
    let $container,
      $columns = [];
    (_this.elements = []), init();
  }),
  Class(function UICustomiseTechnologyHighlight(
    _technology,
    _initialState,
    _productCode
  ) {
    function init() {
      const $technology = $this.create("Technology"),
        $title = $technology.create("Title"),
        $description = $technology.create("Description"),
        $arrow = $technology.create("Arrow");
      $title.text(_technology.name),
        $description.text(_technology.description || "To be connected."),
        $arrow.bg("assets/images/ui/customise/down-arrow.svg", "contain"),
        _technology.variables.forEach(addVariable),
        $this.css({
          position: "relative",
          border: "2px solid rgba(0, 0, 0, 0.1)",
          borderRadius: 5,
        }),
        $technology.css({
          position: "relative",
          padding: "15px 20px",
          border: "3px solid " + Colors.instance().UI.dark,
          borderRadius: 5,
          margin: 7,
        }),
        $title.css({
          position: "relative",
          textTransform: "uppercase",
          fontSize: 13,
          fontWeight: "bold",
          letterSpacing: "0.1em",
          opacity: "0.8",
          marginBottom: 5,
        }),
        $description.css({
          position: "relative",
          fontFamily: "montserrat",
          fontSize: Tests.smallTablet() ? 11 : 10,
          lineHeight: "1.6em",
          opacity: "0.6",
          marginRight: 35,
        }),
        $arrow.css({
          padding: 5,
          margin: -5,
          top: "50%",
          right: 40,
          backgroundRepeat: "no-repeat",
        }),
        $technology.interact(
          function hover(e) {
            switch (e.action) {
              case "over":
                $technology.tween({ opacity: 0.6 }, 300, "easeOutSine");
                break;
              case "out":
                $technology.tween({ opacity: 1 }, 500, "easeOutSine");
            }
          },
          function click() {
            _this.onClick && _this.onClick();
          }
        );
    }
    function addVariable(variable) {
      const $variable = $this.create("Variable"),
        $title = $variable.create("Title"),
        $description = $variable.create("Description"),
        $options = $variable.create("Options");
      $title.text(variable.name),
        $description.text(variable.description || "To be connected."),
        $variable.css({
          position: "relative",
          padding: "15px 27px",
          paddingRight: 0,
          borderRadius: 5,
          marginBottom: 8,
        }),
        $title.css({
          display: "inline-block",
          position: "relative",
          textTransform: "uppercase",
          fontSize: 12,
          fontWeight: "bold",
          letterSpacing: "0.1em",
          opacity: "0.8",
          marginBottom: 5,
          padding: "3px 6px",
          background: "rgba(0, 0, 0, 0.05)",
        }),
        $description.css({
          position: "relative",
          fontFamily: "montserrat",
          fontSize: Tests.smallTablet() ? 11 : 10,
          lineHeight: "1.6em",
          marginBottom: 10,
          opacity: "0.6",
        }),
        $options.css({ position: "relative", textTransform: "uppercase" }),
        variable.options.forEach((option, i) => {
          const $option = $options.create("Option");
          $option.text(option.name),
            ($option.icon = $option.create("Icon")),
            Tests.svgMask()
              ? ($option.icon.mask(
                  `assets/images/ui/customise/variables/${
                    option.perma || "average"
                  }.svg`,
                  "contain"
                ),
                $option.icon.css({ backgroundColor: "#444" }))
              : $option.icon.bg(
                  `assets/images/ui/customise/variables/no-mask/${
                    option.perma || "average"
                  }.svg`,
                  "contain"
                ),
            ($option.isActive =
              !!_initialState &&
              (_initialState[_technology.code]
                ? _initialState[_technology.code][variable.code] === option.code
                : 0 === i)),
            $option.isActive
              ? ((variable.active = $option), selectOption(variable.active))
              : deselectOption($option),
            $option.css({
              position: "relative",
              display: "inline-block",
              fontSize: 12,
              lineHeight: "2em",
              paddingLeft: 24,
              letterSpacing: "0.1em",
              paddingRight: 10,
              marginRight: 15,
            }),
            $option.icon.css({
              backgroundSize: "contain",
              backgroundPosition: "center center",
              left: 0,
              top: "50%",
              padding: 7,
              marginTop: -7,
              opacity: "0.8",
            }),
            $option.interact(
              function hover(e) {
                if (!e.object.isActive)
                  switch (e.action) {
                    case "over":
                      e.object.tween({ opacity: 1 }, 300, "easeOutSine");
                      break;
                    case "out":
                      e.object.tween({ opacity: 0.6 }, 300, "easeOutSine");
                  }
              },
              function click() {
                variable.active !== $option &&
                  (deselectOption(variable.active),
                  (variable.active = $option),
                  selectOption(variable.active),
                  Track.event(
                    "product-detail",
                    "technology-variable-option-select",
                    _product.perma +
                      "/" +
                      _technology.perma +
                      "/" +
                      variable.code +
                      "/" +
                      option.perma
                  ),
                  Configuration.setProductTechnology(
                    _productCode,
                    _technology.code,
                    variable.code,
                    option.code
                  ),
                  _this.onChange && _this.onChange());
              }
            );
        });
    }
    function deselectOption($option) {
      $option.tween(
        { color: "#222", fontWeight: "normal", opacity: 0.5 },
        500,
        "easeOutSine"
      ),
        ($option.isActive = !1),
        Tests.svgMask() &&
          $option.icon.tween(
            { backgroundColor: "#555", opacity: 0.8 },
            500,
            "easeOutSine"
          );
    }
    function selectOption($option) {
      ($option.isActive = !0),
        $option.tween(
          { color: Colors.instance().UI.dark, fontWeight: "bold", opacity: 1 },
          500,
          "easeOutSine"
        ),
        Tests.svgMask() &&
          $option.icon.tween(
            { backgroundColor: Colors.instance().UI.dark, opacity: 1 },
            500,
            "easeOutSine"
          );
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element,
      _product = Meta.PRODUCT(_productCode);
    init(),
      (this.show = function () {
        $this.show();
      }),
      (this.hide = function () {
        $this.hide();
      });
  }),
  Class(
    function UICustomiseVariables(_productCode) {
      function init() {
        const $title = $this.create("Title");
        ($container = $this.create("Container")),
          $title.text(Data.copy("VARIABLES")),
          _this.elements.push($title),
          _variables.forEach(addVariable),
          $this.css({
            position: "relative",
            display: "inline-block",
            width: 400,
            height: 450,
            color: "#000000",
          }),
          $title.css({
            position: "relative",
            textTransform: "uppercase",
            fontSize: 12,
            fontWeight: "bold",
            letterSpacing: "0.1em",
            lineHeight: 50,
            padding: "0px 15px",
            opacity: "0.8",
          }),
          $container.css({
            position: "relative",
            width: 370,
            height: 400,
            margin: "0px 15px",
          });
      }
      function addVariable(variable) {
        const $variable = $container.create("Variable"),
          $title = $variable.create("Title"),
          $description = $variable.create("Description"),
          $options = $variable.create("Options");
        _this.elements.push($variable), $title.text(variable.name);
        let desc = variable.description || "To be connected.";
        desc.length > 100 && (desc = desc.substring(0, 100) + "..."),
          $description.text(desc),
          $variable.css({
            position: "relative",
            padding: "15px 20px",
            border: "2px solid " + Colors.instance().UI.dark,
            borderRadius: 5,
            marginBottom: 8,
          }),
          $title.css({
            position: "relative",
            textTransform: "uppercase",
            fontSize: 13,
            fontWeight: "bold",
            letterSpacing: "0.1em",
            opacity: "0.8",
            marginBottom: 5,
          }),
          $description.css({
            position: "relative",
            fontFamily: "montserrat",
            fontSize: Tests.smallTablet() ? 11 : 10,
            lineHeight: "1.6em",
            marginBottom: 10,
            opacity: "0.6",
          }),
          $options.css({ position: "relative", textTransform: "uppercase" }),
          variable.options.forEach((option) => {
            const $option = $options.create("Option");
            $option.text(option.name),
              ($option.icon = $option.create("Icon")),
              Tests.svgMask()
                ? ($option.icon.mask(
                    `assets/images/ui/customise/variables/${
                      option.perma || "average"
                    }.svg`,
                    "contain"
                  ),
                  $option.icon.css({ backgroundColor: "#444" }))
                : $option.icon.bg(
                    `assets/images/ui/customise/variables/no-mask/${
                      option.perma || "average"
                    }.svg`,
                    "contain"
                  ),
              ($option.isActive = _initialState[variable.code] === option.code),
              $option.isActive
                ? ((variable.active = $option), selectOption(variable.active))
                : deselectOption($option),
              $option.css({
                position: "relative",
                display: "inline-block",
                fontSize: 12,
                lineHeight: "2em",
                paddingLeft: 24,
                letterSpacing: "0.1em",
                paddingRight: 10,
                marginRight: 15,
              }),
              $option.icon.css({
                backgroundSize: "contain",
                backgroundPosition: "center center",
                left: 0,
                top: "50%",
                padding: 7,
                marginTop: -7,
                opacity: "0.8",
              }),
              $option.interact(
                function hover(e) {
                  if (!e.object.isActive)
                    switch (e.action) {
                      case "over":
                        e.object.tween({ opacity: 1 }, 300, "easeOutSine");
                        break;
                      case "out":
                        e.object.tween({ opacity: 0.6 }, 300, "easeOutSine");
                    }
                },
                function click() {
                  variable.active !== $option &&
                    (deselectOption(variable.active),
                    (variable.active = $option),
                    selectOption(variable.active),
                    Track.event(
                      "product-detail",
                      "variable-option-select",
                      _product.perma + "/" + variable.perma + "/" + option.perma
                    ),
                    Configuration.setProductVariable(
                      _productCode,
                      variable.code,
                      option.code
                    ),
                    _this.onChange && _this.onChange(),
                    _this.events.fire(UICustomiseVariables.CHANGE, {
                      variable: variable,
                      option: option,
                    }));
                }
              );
          });
      }
      function deselectOption($option) {
        $option.tween(
          { color: "#222", fontWeight: "normal", opacity: 0.5 },
          500,
          "easeOutSine"
        ),
          ($option.isActive = !1),
          Tests.svgMask() &&
            $option.icon.tween(
              { backgroundColor: "#555", opacity: 0.8 },
              500,
              "easeOutSine"
            );
      }
      function selectOption($option) {
        ($option.isActive = !0),
          $option.tween(
            {
              color: Colors.instance().UI.dark,
              fontWeight: "bold",
              opacity: 1,
            },
            500,
            "easeOutSine"
          ),
          Tests.svgMask() &&
            $option.icon.tween(
              { backgroundColor: Colors.instance().UI.dark, opacity: 1 },
              500,
              "easeOutSine"
            );
      }
      Inherit(this, Element);
      const _this = this,
        $this = this.element,
        _initialState = Configuration.getProductVariables(_productCode),
        _product = Meta.PRODUCT(_productCode),
        _variables = _product.productVariables;
      let $container;
      (_this.elements = []), init();
    },
    () => {
      UICustomiseVariables.CHANGE = "event_variable_change";
    }
  ),
  Class(function Graph(
    _width = 600,
    _height = 200,
    _labels = {},
    _colours = ["#000"],
    _fontsizeOffset = 0
  ) {
    function initHTML() {
      $this
        .size(WIDTH + 100, "auto")
        .css({ position: "relative", textAlign: "center" }),
        ($container = $this.create("container")).css({
          position: "relative",
          display: "inline-block",
        }),
        ($graph = $container.create("graph-container"))
          .size(WIDTH, HEIGHT)
          .css({ position: "relative", display: "inline-block" });
      let $xLabel = $container.create("x-label");
      $xLabel
        .fontStyle("din", 11 + _fontsizeOffset, _colours[0])
        .css({
          position: "relative",
          textAlign: "justify",
          width: WIDTH,
          marginTop: 5,
        }),
        $xLabel.text(_labels.xAxis || "100 315 1000 3150 10000");
      let span = $("span", "span");
      span.css({ width: "100%", display: "inline-block" }), $xLabel.add(span);
      let $label = $container.create("label");
      $label
        .fontStyle("din", 12 + _fontsizeOffset, _colours[0])
        .css({
          position: "relative",
          textAlign: "center",
          width: WIDTH,
          marginTop: 2,
        }),
        $label.text(_labels.label || Data.copy("FREQUENCY")),
        ($higherLabel = $container.create("label"))
          .fontStyle("din", 12 + _fontsizeOffset, _colours[0])
          .css({
            textAlign: "left",
            top: -35,
            left: 0,
            background:
              "url(assets/images/ui/customise/info.svg) left center / contain no-repeat",
            paddingLeft: 20,
          }),
        $higherLabel.text(Data.copy("HIGHER_BETTER_TEXT"));
    }
    function initGrid() {
      let $baseline = $graph.create("baseline");
      $baseline.size("100%", "2px").bg(_colours[0]),
        $baseline.css({ opacity: 0.5, bottom: 0 });
      for (let i = 0; i < LINES; i++) {
        let $line = $graph.create("line");
        $line.size("100%", "2px").bg(_colours[0]),
          $line.css({ opacity: 0.05, top: LINE_SPACING * i - 1 }),
          _lines.push($line);
      }
    }
    function initGraph() {
      (_graph = _this.initClass(GraphCanvas, 2 * WIDTH, 2 * HEIGHT, 1, !1, [
        $graph,
      ])).element.size(WIDTH, HEIGHT);
    }
    function initLabels() {
      ($lineLabel = $this.create("label-left")).fontStyle(
        "din",
        10 + _fontsizeOffset
      ),
        $lineLabel.css({
          textTransform: "initial",
          minWidth: 40,
          letterSpacing: "0.1em",
          left: 0,
          top: -6,
          display: "inline-block",
          textAlign: "right",
          fontWeight: "bold",
        }),
        $lineLabel.css({ opacity: 0 }).transform({ y: 20 }),
        ($lineLabel2 = $this.create("label-left2")).fontStyle(
          "din",
          11 + _fontsizeOffset,
          _colours[0]
        ),
        $lineLabel2.css({
          minWidth: 40,
          left: 0,
          bottom: 44,
          display: "inline-block",
          textAlign: "right",
        }),
        $lineLabel2.css({ opacity: 0 }).transform({ y: 20 }),
        ($topValue = $this.create("right-top-value"))
          .fontStyle("din", 10 + _fontsizeOffset, _colours[0])
          .text("1"),
        $topValue.css({
          position: "absolute",
          textAlign: "left",
          width: 45,
          right: 0,
          top: -6,
        }),
        ($inter00 = $this.create("inter-val-00"))
          .fontStyle("din", 10 + _fontsizeOffset, _colours[0])
          .text("00"),
        $inter00.css({
          position: "absolute",
          textAlign: "left",
          width: 45,
          right: 0,
          top: -2 === _fontsizeOffset ? 11 : 23,
        }),
        ($interValue1 = $this.create("inter-val-0"))
          .fontStyle("din", 10 + _fontsizeOffset, _colours[0])
          .text("00"),
        $interValue1.css({
          position: "absolute",
          textAlign: "left",
          width: 45,
          right: 0,
          top: -2 === _fontsizeOffset ? 85 : 170,
        }),
        ($inter01 = $this.create("inter-val-01"))
          .fontStyle("din", 10 + _fontsizeOffset, _colours[0])
          .text("00"),
        $inter01.css({
          position: "absolute",
          textAlign: "left",
          width: 45,
          right: 0,
          top: -2 === _fontsizeOffset ? 41 : 82,
        }),
        ($interValue2 = $this.create("inter-val-2"))
          .fontStyle("din", 10 + _fontsizeOffset, _colours[0])
          .text("00"),
        $interValue2.css({
          position: "absolute",
          textAlign: "left",
          width: 45,
          right: 0,
          top: -2 === _fontsizeOffset ? 55 : 113,
        }),
        ($inter02 = $this.create("inter-val-02"))
          .fontStyle("din", 10 + _fontsizeOffset, _colours[0])
          .text("00"),
        $inter02.css({
          position: "absolute",
          textAlign: "left",
          width: 45,
          right: 0,
          top: -2 === _fontsizeOffset ? 70 : 142,
        }),
        ($interValue3 = $this.create("inter-val-3"))
          .fontStyle("din", 10 + _fontsizeOffset, _colours[0])
          .text("00"),
        $interValue3.css({
          position: "absolute",
          textAlign: "left",
          width: 45,
          right: 0,
          top: -2 === _fontsizeOffset ? 26 : 53,
        }),
        ($inter03 = $this.create("inter-val-03"))
          .fontStyle("din", 10 + _fontsizeOffset, _colours[0])
          .text("00"),
        $inter03.css({
          position: "absolute",
          textAlign: "left",
          width: 45,
          right: 0,
          top: -2 === _fontsizeOffset ? 100 : 200,
        }),
        ($bottomValue = $this.create("right-bottom-value"))
          .fontStyle("din", 10 + _fontsizeOffset, _colours[0])
          .text("0"),
        $bottomValue.css({
          position: "absolute",
          textAlign: "left",
          width: 45,
          right: 0,
          bottom: -2 === _fontsizeOffset ? 39 : 43,
        });
    }
    async function animateInGraph() {
      _graph.animateIn(450),
        $lineLabel.tween({ opacity: 1, y: 0 }, 700, "easeOutQuad", 600),
        $lineLabel2.tween({ opacity: 1, y: 0 }, 700, "easeOutQuad", 600);
    }
    Inherit(this, Element);
    const _this = this,
      $this = _this.element;
    let _graph,
      $container,
      $graph,
      $higherLabel,
      $lineLabel,
      $lineLabel2,
      $topValue,
      $bottomValue,
      $interValue1,
      $interValue2,
      $interValue3,
      $inter00,
      $inter01,
      $inter02,
      $inter03,
      _lines = [];
    const WIDTH = _width - 100,
      HEIGHT = _height,
      LINES = 8,
      LINE_SPACING = HEIGHT / LINES;
    initHTML(),
      initGrid(),
      initGraph(),
      initLabels(),
      (this.fadeIn = function () {
        return (
          _graph.animateIn(100),
          $this.tween({ opacity: 1 }, 500, "easeInOutQuad").promise()
        );
      }),
      (this.fadeOut = function () {
        return (
          _graph.animateOut(400),
          $this.tween({ opacity: 0 }, 500, "easeInOutQuad", 500).promise()
        );
      }),
      (this.setData = function (curve) {
        let label1 = curve.label.toUpperCase();
        "tl" === curve.label && (label1 += ` ${Data.copy("DECIBELS")}`),
          "abs" === curve.label && (label1 += " [-]"),
          $lineLabel.text(label1).css({ color: curve.color || "#fff" }),
          $topValue.text(curve.max),
          $bottomValue.text(curve.min),
          [
            $inter03,
            $interValue1,
            $inter02,
            $interValue2,
            $inter01,
            $interValue3,
            $inter00,
          ].forEach((el, i) => {
            el.text(((curve.max - curve.min) / LINES) * (i + 1) + curve.min);
          }),
          _graph.setData([curve]),
          animateInGraph();
      });
  }),
  Class(function GraphCanvas(
    _width = 500,
    _height = 300,
    _marginX = 1,
    _isShadow = !1
  ) {
    function initHTML() {
      ($this = _this.element).size(_width, _height),
        $this
          .css({ position: "relative", opacity: 0 })
          .transform({ y: 15, scale: 0.6 });
    }
    function initCanvas() {
      (_canvas = _this.initClass(Canvas, _width, _height)).element.css({
        position: "absolute",
        top: 0,
        left: 0,
      }),
        _canvas.element.size("100%", "100%"),
        (_ctx = _canvas.context),
        $this.add(_canvas.element);
    }
    function remap(curve) {
      let xMax = curve.points.length - 1,
        yMax = curve.max,
        yMin = curve.min,
        points = [];
      for (let i = 0; i < curve.points.length; i++) {
        let x = Math.range(i, 0, xMax, 0, _width * _marginX),
          y = Math.range(curve.points[i], yMin, yMax, 0, _height * _marginY);
        points.push(
          x + _width * ((1 - _marginX) / 2),
          y + _height * ((1 - _marginY) / 2)
        );
      }
      return (curve.points = points), curve;
    }
    function drawCurve(curve) {
      (_ctx.lineWidth = 5),
        _isShadow && (_ctx.shadowBlur = 30),
        (_ctx.lineCap = "round");
      let { points: points, color: color } = curve,
        rgb = new Color(curve.color || "#ffffff")
          .toArray()
          .map((c) => 255 * c)
          .join(", ");
      _ctx.beginPath(),
        smooth(points),
        (_ctx.strokeStyle = color),
        _isShadow && (_ctx.shadowColor = `rgba(${rgb || "255,255,255"}, 1)`),
        _ctx.stroke(),
        _isShadow ||
          (_ctx.lineTo(_canvas.width, _canvas.height),
          _ctx.lineTo(0, _canvas.height),
          (_ctx.fillStyle = `rgba(${rgb}, 0.1)`),
          _ctx.fill()),
        _ctx.closePath();
    }
    function smooth(points, flip = !0) {
      flip && (_ctx.save(), _ctx.transform(1, 0, 0, -1, 0, _canvas.height));
      let x = points[0],
        y = points[1];
      _ctx.moveTo(x, y);
      let i = 0;
      for (; i < points.length - 4; i += 2) {
        let x1 = points[i],
          y1 = points[i + 1],
          xc = (x1 + points[i + 2]) / 2,
          yc = (y1 + points[i + 3]) / 2;
        _ctx.quadraticCurveTo(x1, y1, xc, yc);
      }
      let x1 = points[i],
        y1 = points[i + 1],
        x2 = points[i + 2],
        y2 = points[i + 3];
      _ctx.quadraticCurveTo(x1, y1, x2, y2), _ctx.restore();
    }
    Inherit(this, Element);
    const _this = this;
    let $this,
      _ctx,
      _canvas,
      _marginY = 0.9;
    initHTML(),
      initCanvas(),
      (this.setData = function (curves) {
        _ctx.clearRect(0, 0, _width, _height),
          drawCurve(remap(curves[0])),
          curves.length < 2 || drawCurve(remap(curves[1]));
      }),
      (this.animateIn = function (delay = 0) {
        return $this
          .tween({ opacity: 1, y: 0, scale: 1 }, 700, "easeOutCubic", delay)
          .promise();
      }),
      (this.animateOut = function (delay = 0) {
        return $this
          .tween({ opacity: 0, y: 15, scale: 0.6 }, 700, "easeOutCubic", delay)
          .promise();
      });
  }),
  Class(function SoundGraph(_curves, _min, _max, _presetIndex) {
    function initHTML() {
      $this
        .size(WIDTH + 100, "auto")
        .css({ position: "relative", textAlign: "center", marginTop: 20 }),
        ($container = $this.create("container")).css({
          position: "relative",
          display: "inline-block",
        }),
        ($graph = $container.create("graph-container"))
          .size(WIDTH, HEIGHT)
          .css({ position: "relative", display: "inline-block" });
      let $xLabel = $container.create("x-label");
      $xLabel
        .fontStyle("din", 10, "#fff")
        .css({
          position: "relative",
          textAlign: "justify",
          width: WIDTH,
          marginTop: 5,
        }),
        $xLabel.text("400 800 1600 4000 8000");
      let span = $("span", "span");
      span.css({ width: "100%", display: "inline-block" }), $xLabel.add(span);
    }
    function initGrid() {
      let $baseline = $graph.create("baseline");
      $baseline.size("100%", "2px").bg("#fff"),
        $baseline.css({ opacity: 0.5, bottom: 0 });
      for (let i = 0; i < LINES; i++) {
        let $line = $graph.create("line");
        $line.size("100%", "1px").bg("#fff"),
          $line.css({ opacity: 0.1, top: LINE_SPACING * i }),
          _lines.push($line);
      }
    }
    function initGraph() {
      (_graph = _this.initClass(GraphCanvas, 2 * WIDTH, 2 * HEIGHT, 0.95, !0, [
        $graph,
      ])).element.size(WIDTH, HEIGHT);
    }
    function initLabels() {
      ($lineLabel = $this.create("label-left")).css({
        textTransform: "initial",
        right: "97%",
        whiteSpace: "nowrap",
        top: 45,
        position: "absolute",
        fontSize: 7,
        display: "inline-block",
        opacity: "0.5",
        transformOrigin: "100% 0%",
      }),
        $lineLabel.transform({ rotation: -90 }),
        $lineLabel.text(Data.copy("SOUND_PRESSURE")),
        ($topValue = $this.create("right-top-value")).fontStyle(
          "din",
          9,
          "#fff"
        ),
        $topValue.css({
          position: "absolute",
          textAlign: "right",
          width: 45,
          left: 0,
          top: -4,
          opacity: 0.5,
        }),
        ($inter1 = $this.create("intermediate-value")).fontStyle(
          "din",
          9,
          "#fff"
        ),
        $inter1.css({
          position: "absolute",
          textAlign: "right",
          width: 45,
          left: 0,
          top: 23,
          opacity: 0.5,
        }),
        ($middleValue1 = $this.create("middle-top-value")).fontStyle(
          "din",
          9,
          "#fff"
        ),
        $middleValue1.css({
          position: "absolute",
          textAlign: "right",
          width: 45,
          left: 0,
          top: 50,
          opacity: 0.5,
        }),
        ($inter2 = $this.create("intermediate-value")).fontStyle(
          "din",
          9,
          "#fff"
        ),
        $inter2.css({
          position: "absolute",
          textAlign: "right",
          width: 45,
          left: 0,
          top: 78,
          opacity: 0.5,
        }),
        ($middleValue2 = $this.create("middle-top-value")).fontStyle(
          "din",
          9,
          "#fff"
        ),
        $middleValue2.css({
          position: "absolute",
          textAlign: "right",
          width: 45,
          left: 0,
          top: 105,
          opacity: 0.5,
        }),
        ($inter3 = $this.create("intermediate-value")).fontStyle(
          "din",
          9,
          "#fff"
        ),
        $inter3.css({
          position: "absolute",
          textAlign: "right",
          width: 45,
          left: 0,
          top: 133,
          opacity: 0.5,
        }),
        ($middleValue3 = $this.create("middle-top-value")).fontStyle(
          "din",
          9,
          "#fff"
        ),
        $middleValue3.css({
          position: "absolute",
          textAlign: "right",
          width: 45,
          left: 0,
          top: 160,
          opacity: 0.5,
        }),
        ($inter4 = $this.create("intermediate-value")).fontStyle(
          "din",
          9,
          "#fff"
        ),
        $inter4.css({
          position: "absolute",
          textAlign: "right",
          width: 45,
          left: 0,
          top: 189,
          opacity: 0.5,
        }),
        ($bottomValue = $this.create("right-bottom-value")).fontStyle(
          "din",
          9,
          "#fff"
        ),
        $bottomValue.css({
          position: "absolute",
          textAlign: "right",
          width: 45,
          left: 0,
          bottom: 27,
          opacity: 0.5,
        });
      const els = [
        $bottomValue,
        $inter4,
        $middleValue3,
        $inter3,
        $middleValue2,
        $inter2,
        $middleValue1,
        $inter1,
        $topValue,
      ];
      els.forEach((el, i) => {
        el.text(Math.round(((_max - _min) / (els.length - 1)) * i + _min));
      });
    }
    function drawCurves() {
      const curves = [
        { points: _curves[0], color: "#ffffff", min: _min, max: _max },
        {
          points: _curves[1],
          color: Config.PRESET_COLORS[_presetIndex][0][0],
          min: _min,
          max: _max,
        },
      ];
      _graph.setData(curves), animateInGraph();
    }
    async function animateInGraph() {
      _graph.animateIn(450);
    }
    Inherit(this, Element);
    const _this = this,
      $this = _this.element;
    let _graph,
      $container,
      $graph,
      $lineLabel,
      $topValue,
      $middleValue1,
      $middleValue2,
      $middleValue3,
      $bottomValue,
      $inter1,
      $inter2,
      $inter3,
      $inter4,
      _lines = [];
    const WIDTH = (Tests.smallTablet() ? 470 : 500) - 100,
      HEIGHT = 220,
      LINES = 8,
      LINE_SPACING = HEIGHT / LINES;
    !(async function () {
      initHTML(), initGrid(), initGraph(), initLabels(), drawCurves();
    })(),
      (this.animateIn = function () {
        return (
          _graph.animateIn(100),
          $this.tween({ opacity: 1 }, 500, "easeInOutQuad").promise()
        );
      }),
      (this.animateOut = function () {
        return (
          _graph.animateOut(400),
          $this.tween({ opacity: 0 }, 500, "easeInOutQuad", 500).promise()
        );
      });
  }),
  Class(function SpiderGraph(
    _data,
    _colours = ["#ccc", "#1e9cfc", "rgba(30, 156, 252, 0.1)", "#333"]
  ) {
    function init() {
      $this.size(_width, _height).center().css({}),
        (_canvas = _this.initClass(Canvas, _width, _height)).element.css({
          width: _width,
          height: _height,
          position: "absolute",
          top: 0,
          left: 0,
        }),
        (_ctx = _canvas.context),
        $this.add(_canvas.element);
    }
    function drawBackground() {
      const size = _width,
        num = _data.length,
        r = 0.45;
      _ctx.beginPath();
      for (let i = 0; i < num; i++) {
        const angle = i * ((2 * Math.PI) / num);
        let x = r * Math.sin(angle) * size + 0.5 * size,
          y = r * Math.cos(angle) * size + 0.5 * size;
        i ? _ctx.lineTo(x, y) : _ctx.moveTo(x, y);
      }
      _ctx.closePath(),
        (_ctx.lineWidth = 5),
        (_ctx.strokeStyle = _colours[0]),
        _ctx.stroke();
      for (let i = 0; i < num; i++) {
        const angle = i * ((2 * Math.PI) / num);
        _ctx.beginPath();
        let x = 0.5 * size,
          y = 0.5 * size;
        _ctx.moveTo(x, y),
          (x = r * Math.sin(angle) * size + 0.5 * size),
          (y = r * Math.cos(angle) * size + 0.5 * size),
          _ctx.lineTo(x, y),
          _ctx.closePath(),
          (_ctx.lineWidth = 1),
          (_ctx.strokeStyle = _colours[0]),
          _ctx.stroke();
      }
    }
    function drawData(data) {
      const size = _width,
        num = data.length;
      _ctx.beginPath();
      for (let i = 0; i < num; i++) {
        const angle = i * ((2 * Math.PI) / num),
          r2 = (Math.clamp(0, 10, data[i].value) / 10) * 0.45;
        let x = r2 * Math.sin(angle) * size + 0.5 * size,
          y = r2 * Math.cos(angle) * size + 0.5 * size;
        i ? _ctx.lineTo(x, y) : _ctx.moveTo(x, y);
      }
      _ctx.closePath(),
        (_ctx.lineWidth = 1),
        (_ctx.strokeStyle = _colours[1]),
        _ctx.stroke(),
        _color.set(_colours[2]),
        (_ctx.fillStyle = `rgba(${255 * _color.r}, ${255 * _color.g}, ${
          255 * _color.b
        }, 0.1)`),
        _ctx.fill();
      for (let i = 0; i < num; i++) {
        const angle = i * ((2 * Math.PI) / num),
          r2 = (Math.clamp(0, 10, data[i].value) / 10) * 0.45;
        let x = r2 * Math.sin(angle) * size + 0.5 * size,
          y = r2 * Math.cos(angle) * size + 0.5 * size;
        _ctx.ellipse &&
          (_ctx.beginPath(),
          _ctx.ellipse(x, y, 1.5, 1.5, 0, 0, 2 * Math.PI),
          _ctx.closePath(),
          (_ctx.fillStyle = _colours[3]),
          _ctx.fill());
      }
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element,
      _width = 150,
      _height = 150;
    let _canvas, _ctx;
    var _color = new Color(Colors.instance().UI.dark);
    init(),
      drawBackground(),
      drawData(_data),
      (this.updateData = function (data) {
        _ctx.clearRect(0, 0, _width, _height), drawBackground(), drawData(data);
      });
  }),
  Class(function UIIcon(_config) {
    function initHTML() {
      ($this = _this.element).size(_config.size, _config.size),
        ($wrapper = $this.create(".wrapper"))
          .size("100%")
          .css({ overflow: "hidden" });
    }
    function initIcon() {
      let size = _config.iconSize || Math.round(0.36 * _config.size);
      ($icon = $wrapper.create(".icon"))
        .size(size, size)
        .center()
        .css({ opacity: 0.8 }),
        ($over = $icon.clone()),
        $wrapper.add($over),
        $over.css({ opacity: 0 }).transform({ y: 0.4 * -_config.size }),
        Tests.svgMask() && _config.hover
          ? ($icon.mask("assets/images/ui/" + _config.icon),
            $icon.css({ backgroundColor: _config.color }),
            $over.mask(
              "assets/images/ui/" + (_config.overIcon || _config.icon)
            ),
            $over.css({ backgroundColor: _config.hover }))
          : ($icon.bg("assets/images/ui/" + _config.icon),
            $over.bg("assets/images/ui/" + (_config.overIcon || _config.icon)));
    }
    function initBorder() {
      ($border = $this.create(".border"))
        .size(_config.size - 4, _config.size - 4)
        .css({
          opacity: 0.3,
          borderRadius: "50%",
          border: "2px solid " + _config.color,
        }),
        ($ring = $this.create(".border"))
          .size(_config.size - 1, _config.size - 1)
          .css({
            opacity: 0,
            borderRadius: "50%",
            border: "1px solid " + _config.color,
          });
    }
    Inherit(this, Element);
    const _this = this;
    var $this, $wrapper, $icon, $over, $border, $ring;
    (_config.color = _config.color || "#fff"),
      initHTML(),
      initIcon(),
      _config.border && initBorder(),
      (this.hoverIn = function (color = "#fff") {
        Tests.svgMask() && $over.css({ backgroundColor: color }),
          $over.tween({ y: 0, opacity: 1 }, 300, "easeOutCubic"),
          $icon.tween(
            { opacity: 0, y: 0.4 * _config.size },
            300,
            "easeOutCubic"
          ),
          $ring &&
            $ring
              .clearTween()
              .css({ opacity: 0.4 })
              .transform({ scale: 1 })
              .tween({ opacity: 0, scale: 1.5 }, 1200, "easeOutQuart"),
          $border &&
            $border.tween(
              { opacity: 1, borderColor: color },
              300,
              "easeOutSine"
            );
      }),
      (this.hoverOut = function () {
        $over.tween(
          { y: 0.4 * -_config.size, opacity: 0 },
          600,
          "easeOutCubic"
        ),
          $icon.tween({ opacity: 0.8, y: 0 }, 600, "easeOutCubic"),
          $border &&
            $border.tween(
              { opacity: 0.3, borderColor: _config.color },
              600,
              "easeOutSine"
            );
      }),
      (this.animateIn = function () {}),
      (this.changeIcon = function (src) {
        (_config.icon = src),
          Tests.svgMask() && _config.hover
            ? ($icon.mask("assets/images/ui/" + _config.icon),
              $over.mask(
                "assets/images/ui/" + (_config.overIcon || _config.icon)
              ))
            : ($icon.bg("assets/images/ui/" + _config.icon),
              $over.bg(
                "assets/images/ui/" + (_config.overIcon || _config.icon)
              ));
      });
  }),
  Class(
    function UIIntroText(_data) {
      function initText() {
        $this
          .css({
            color: "#fff",
            top: Device.mobile ? "14%" : "16%",
            left: 0,
            right: 0,
            margin: "-50px auto 0 auto",
            width: 450,
            maxWidth: "80%",
            textAlign: "center",
            opacity: 1e-4,
          })
          .mouseEnabled(!1),
          ($wrapper = $this.create(".wrapper")).size("100%"),
          ($title = $wrapper.create(".text")).css({
            fontFamily: "bebas",
            width: "100%",
            fontSize: 28,
            position: "relative",
            display: "block",
            lineHeight: "1em",
            letterSpacing: "0.18em",
            textTransform: "uppercase",
            marginBottom: 15,
          }),
          $title.text(Data.copy("INTRO_TITLE")),
          ($text = $wrapper.create(".text")).css({
            width: "100%",
            position: "relative",
            display: "block",
            fontSize: Tests.smallTablet() ? 10 : 12,
            lineHeight: "1.8em",
            letterSpacing: "0.18em",
            textTransform: "uppercase",
            opacity: 0.4,
          }),
          $text.text(Data.copy("INTRO_TEXT")),
          (_words = Tests.isSplitText()
            ? SplitTextfield.split($text, "word")
            : [$text]);
      }
      function animateOut(e) {
        _hidden ||
          ((_hidden = !0),
          $wrapper.tween(
            { opacity: 0 },
            e.fast ? 200 : 500,
            "easeOutSine",
            (_) => {
              $this.hide(), _this.destroy();
            }
          ));
      }
      function addHandlers() {
        _this.events.sub(UIIntroText.ANIMATE_OUT, animateOut);
      }
      Inherit(this, Element);
      const _this = this,
        $this = this.element;
      var $wrapper,
        $title,
        $text,
        _hidden = !1;
      let _words;
      initText(),
        addHandlers(),
        (this.animateIn = function animateIn(mainDelay = 0) {
          $this.css({ opacity: 1 }),
            $title
              .transform({ y: 30 })
              .css({ opacity: 0 })
              .tween({ y: 0, opacity: 1 }, 1350, "easeOutCubic", mainDelay),
            _words.forEach((word, i) => {
              word.css({ opacity: 0 }),
                word.transform({
                  y: 20,
                  rotation: Math.range(i, 0, _words.length - 1, 8, 2),
                });
              const delay =
                Math.pow(0.5 * i, 1.5) *
                Math.range(_words.length, 10, 40, 20, 3, !0);
              word.tween(
                { opacity: 1, y: 0, rotation: 0 },
                2e3,
                "easeOutQuint",
                delay + mainDelay + 300
              );
            }),
            _this.delayedCall(() => {
              _this.isAnimationComplete = !0;
            }, 15 * Math.pow(0.5 * _words.length, 1.5) + 1e3 + mainDelay);
        });
    },
    () => {
      UIIntroText.ANIMATE_OUT = "event_uiintrotext_out";
    }
  ),
  Class(function UIJoystick() {
    function initHTML() {
      ($this = _this.element)
        .size(_size, _size)
        .css({ bottom: 30, right: 30, opacity: 1e-4 }),
        ($arrows = $this.create("arrows"))
          .size("100%")
          .css({ top: 0, left: 0 });
      const createArrow = (direction) => {
        let arrow = $arrows.create("arrow");
        switch (
          (arrow.size(7.5, 46 * 0.15).bg("assets/images/ui/arrow.svg"),
          arrow.css({ opacity: 0.4 }),
          direction)
        ) {
          case "top":
            arrow.transform({ rotation: 180 }).css({ top: -3 }).center(1, 0);
            break;
          case "right":
            arrow.transform({ rotation: -90 }).css({ right: -3 }).center(0, 1);
            break;
          case "bottom":
            arrow.transform({ rotation: 0 }).css({ bottom: -3 }).center(1, 0);
            break;
          case "left":
            arrow.transform({ rotation: 90 }).css({ left: -3 }).center(0, 1);
        }
        return (arrow.dir = direction), arrow;
      };
      (_arrows = ["top", "right", "bottom", "left"].map((direction) =>
        createArrow(direction)
      )),
        ($circle = $this.create("circle"))
          .size(Math.round(0.8 * _size), Math.round(0.8 * _size))
          .center(),
        $circle.css({
          borderRadius: 0.8 * _size,
          border: "2px solid rgba(255, 255, 255, 0.2)",
          boxSizing: "border-box",
          opacity: 1,
        }),
        ($thumb = $circle.create("thumb"))
          .size(Math.round(0.3 * _size), Math.round(0.3 * _size))
          .center(),
        $thumb.css({
          borderRadius: 3 * _size,
          boxShadow:
            "inset 0 0 0 2px #fff, 0 0 8px 4px rgba(255,255,255,0.15), inset 0 0 8px 4px rgba(255,255,255,0.15)",
        });
    }
    function initKeys() {
      ($keys = $this.create("Keys"))
        .size(100, 64)
        .css({ right: 95, bottom: 0 });
      (_keys = []),
        ["up", "right", "down", "left"].forEach((k) => {
          let $key = $keys.create("key");
          $key
            .size(100, 64)
            .bg("assets/images/ui/keyboard/" + k + ".png")
            .css({ backgroundRepeat: "no-repeat", opacity: 0.3 }),
            _keys.push($key);
        });
    }
    function loop() {
      if (!CarControls.input) return;
      let lerp = _this.isDown ? 0.1 : 0.05;
      (_this.position.x = _this.drag.x),
        (_this.position.y = _this.drag.y),
        _move.copy(_this.position);
      let sqr = Math.sqrt(Math.pow(_move.x, 2) + Math.pow(_move.y, 2));
      sqr > 1 && ((_move.x /= sqr), (_move.y /= sqr)),
        (_move.y *= -1),
        CarControls.input.joystick.copy(_move),
        _circle.lerp(CarControls.input.master, 2 * lerp),
        ($thumb.x = _circle.x * _size * 0.5),
        ($thumb.y = -_circle.y * _size * 0.5),
        $thumb.transform();
    }
    function pulse() {
      _this.isDown ||
        _over ||
        _pulseCount == MAX ||
        (_arrows.forEach(async (arrow) => {
          let dir,
            dist = 3;
          "top" == arrow.dir && ((dir = "y"), (dist *= -1)),
            "right" == arrow.dir && (dir = "x"),
            "bottom" == arrow.dir && (dir = "y"),
            "left" == arrow.dir && ((dir = "x"), (dist *= -1)),
            await arrow
              .tween({ [dir]: dist, opacity: 1 }, 600, "easeOutSine")
              .promise(),
            arrow.tween({ [dir]: 0, opacity: 0.4 }, 600, "easeInSine");
        }),
        (_pulseCount += 1),
        _this.delayedCall(pulse, PULSE));
    }
    function addListeners() {
      (_interaction = _this.initClass(Interaction, $circle)),
        _this.events.sub(_interaction, Interaction.START, start),
        _this.events.sub(_interaction, Interaction.DRAG, drag),
        _this.events.sub(_interaction, Interaction.END, end),
        _this.events.sub(UI.FADE, fade),
        Tests.isPhone() && (_this.events.sub(Events.RESIZE, resize), resize()),
        Device.mobile ||
          (_this.events.sub(KeyboardUtil.DOWN, down),
          _this.events.sub(KeyboardUtil.UP, up)),
        $circle.hover(hover);
    }
    function down(e) {
      switch (e.keyCode) {
        case 38:
        case 87:
          _arrows[0].tween({ opacity: 1 }, 300, "easeOutSine"),
            _keys[0].tween({ opacity: 1 }, 300, "easeOutSine");
          break;
        case 39:
        case 68:
          _arrows[1].tween({ opacity: 1 }, 300, "easeOutSine"),
            _keys[1].tween({ opacity: 1 }, 300, "easeOutSine");
          break;
        case 40:
        case 83:
          _arrows[2].tween({ opacity: 1 }, 300, "easeOutSine"),
            _keys[2].tween({ opacity: 1 }, 300, "easeOutSine");
          break;
        case 37:
        case 65:
          _arrows[3].tween({ opacity: 1 }, 300, "easeOutSine"),
            _keys[3].tween({ opacity: 1 }, 300, "easeOutSine");
      }
    }
    function up(e) {
      switch (e.keyCode) {
        case 38:
        case 87:
          _arrows[0].tween({ opacity: 0.4 }, 500, "easeOutSine"),
            _keys[0].tween({ opacity: 0.3 }, 500, "easeOutSine");
          break;
        case 39:
        case 68:
          _arrows[1].tween({ opacity: 0.4 }, 500, "easeOutSine"),
            _keys[1].tween({ opacity: 0.3 }, 500, "easeOutSine");
          break;
        case 40:
        case 83:
          _arrows[2].tween({ opacity: 0.4 }, 500, "easeOutSine"),
            _keys[2].tween({ opacity: 0.3 }, 500, "easeOutSine");
          break;
        case 37:
        case 65:
          _arrows[3].tween({ opacity: 0.4 }, 500, "easeOutSine"),
            _keys[3].tween({ opacity: 0.3 }, 500, "easeOutSine");
      }
    }
    function fade({ hide: hide }) {
      _fadeAnimation && _fadeAnimation.stop(),
        (_fadeAnimation = $this.tween(
          { opacity: hide ? 0 : 1 },
          600,
          "easeOutCubic"
        ));
    }
    function start() {
      _this.isDown = !0;
    }
    function drag() {
      (_this.drag.x = Math.clamp(_interaction.move.x / _size, -1, 1)),
        (_this.drag.y = Math.clamp(_interaction.move.y / _size, -1, 1));
    }
    function end() {
      (_this.isDown = !1),
        _this.delayedCall(pulse, PULSE),
        hover({ action: "out" }),
        (_this.drag.x = _this.drag.y = 0);
    }
    function hover(e) {
      if (!_this.isDown)
        switch (e.action) {
          case "over":
            (_over = !0),
              _arrows.forEach((a) =>
                a.tween({ opacity: 1 }, 300, "easeOutSine")
              ),
              $thumb.tween({ scale: 1, opacity: 1 }, 200, "easeOutCubic");
            break;
          case "out":
            (_over = !1),
              _arrows.forEach((a) =>
                a.tween({ opacity: 0.4 }, 300, "easeOutSine")
              ),
              $thumb.tween({ scale: 0.9, opacity: 1 }, 400, "easeOutCubic");
        }
    }
    function resize() {
      let vertical = Stage.width < Stage.height;
      $this.css({
        bottom: vertical ? 30 : 20,
        right: vertical ? "calc(50% - 75px / 2)" : 30,
      });
    }
    Inherit(this, Element);
    const _this = this;
    let $this,
      $thumb,
      $arrows,
      $circle,
      $keys,
      _interaction,
      _over,
      _size = 75,
      _arrows = [],
      _pulseCount = 0;
    var _keys, _fadeAnimation;
    let _move = new Vector2(),
      _circle = new Vector2();
    const PULSE = 1e4,
      MAX = 45;
    (this.position = { x: 0, y: 0 }),
      (this.target = { x: 0, y: 0 }),
      (this.drag = { x: 0, y: 0 }),
      initHTML(),
      Device.mobile || initKeys(),
      addListeners(),
      _this.delayedCall(pulse, PULSE),
      _this.startRender(loop),
      (this.animateIn = function () {
        $this.show(), $this.tween({ opacity: 1 }, 500, "easeInOutQuad");
      }),
      (this.animateOut = function () {
        $this.tween({ opacity: 0 }, 500, "easeInOutQuad", () => $this.hide());
      });
  }, "singleton"),
  Class(function LoaderView() {
    function initHTML() {
      $this.size("100%").setZ(100),
        ($background = $this
          .create("Background")
          .size("100%")
          .css({ background: "#10151A" })),
        ($container = $this
          .create("Container")
          .css({ left: "50%", top: "50%" }))
          .css({ opacity: 0 })
          .transform({ scale: 1.05, y: 0 })
          .tween({ opacity: 1, y: 0, scale: 1 }, 1e3, "easeOutCubic");
    }
    function initCanvas() {
      (_canvas = _this.initClass(Canvas, _size, _size)).element.css({
        margin: -0.5 * _size,
      }),
        (_context = _canvas.context),
        $container.add(_canvas.element);
    }
    function initLogo() {
      ($logo = $container.create("Logo"))
        .size(158, 158)
        .bg("assets/images/ui/logo.svg", "cover")
        .css({ marginTop: -86, marginLeft: -81 });
    }
    function initTagline() {
      ($tag = $container.create("copy"))
        .html(Data.copy("LOADER_TAG").toUpperCase())
        .fontStyle(Config.FONT_BODY, 10, "rgba(255, 255, 255, 0.3)")
        .css({
          letterSpacing: "0.51em",
          paddingLeft: "0.25em",
          whiteSpace: "nowrap",
          textAlign: "center",
          marginTop: 11,
          transform: "translateX(-50%)",
        });
    }
    function initDisclaimer() {
      ($disclaimer = $container.create("disclaimer"))
        .text(
          Data.copy("IE_DISCLAIMER_TEXT", !0) ||
            "This tool is optimized for web browsers other than Internet Explorer."
        )
        .css({
          fontSize: 10,
          lineHeight: "1.3em",
          letterSpacing: "0.1em",
          textTransform: "uppercase",
          bottom: -155 - (Stage.height - 310) / 4,
          left: -Stage.width / 2,
          margin: "-50px auto 0 auto",
          textAlign: "center",
          width: Stage.width,
          height: 12,
          opacity: 0.5,
        })
        .mouseEnabled(!1);
    }
    function loop(t) {
      _context.clearRect(0, 0, _size, _size),
        (_context.lineWidth = Math.round(0.004 * _size)),
        _context.beginPath(),
        (_context.shadowBlur = 0),
        (_context.strokeStyle = "rgba(255, 255, 255, 0.1)"),
        _context.arc(
          0.5 * _size,
          0.5 * _size,
          0.35 * _size,
          0,
          Math.radians(360),
          !1
        ),
        _context.stroke(),
        _context.closePath();
      let start = Math.radians(-90) + 0.0015 * t;
      _context.beginPath(),
        (_context.strokeStyle = "#e9ee46"),
        (_context.shadowBlur = 10),
        (_context.shadowColor = "rgba(230, 235, 61, 0.5)"),
        _context.arc(
          0.5 * _size,
          0.5 * _size,
          0.35 * _size,
          start,
          start +
            Math.radians(360) * (_this.reverse ? 1 - $this.perc : $this.perc),
          _this.reverse
        ),
        _context.stroke(),
        _context.closePath();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $background,
      $container,
      $logo,
      $tag,
      $disclaimer,
      _canvas,
      _context,
      _size = Tests.smallTablet() || Tests.isPhone() ? 350 : 440;
    ($this.perc = 0),
      initHTML(),
      initCanvas(),
      initLogo(),
      initTagline(),
      ("ie" === Device.system.browser || Utils.query("ie")) && initDisclaimer(),
      _this.startRender(loop),
      (this.progress = function (e) {
        _this.isAnimatingOut ||
          tween($this, { perc: 0.5 * e.percent }, 3e3, "easeInOutSine");
      }),
      (this.animateOut = async function (callback) {
        (_this.isAnimatingOut = !0),
          await tween($this, { perc: 1 }, 3e3, "easeInOutSine", 500).promise(),
          (_this.reverse = !0),
          ($this.perc = 0.999),
          tween($this, { perc: 0 }, 1e3, "easeInOutCubic").promise(),
          $background.tween({ opacity: 0 }, 1e3, "easeInOutSine"),
          await $container
            .tween({ scale: 0.92, opacity: 0 }, 1e3, "easeInSine")
            .promise(),
          callback && callback();
      });
  }),
  Class(function UILogo() {
    function initHTML() {
      ($this = _this.element).size(130, 130),
        $this.css({ left: 40, top: -15, zIndex: 99, opacity: 0 }),
        Tests.svgMask()
          ? ($this.mask("assets/images/ui/logo.svg"),
            $this.css({ backgroundColor: Config.BRAND_COLOR }))
          : $this.bg("assets/images/ui/logo.svg"),
        $this.transform({ scale: 0.95, x: -5 });
    }
    function addHandlers() {
      $this.interact(null, click), $this.hit.css({ cursor: "default" });
    }
    function click(e) {
      if (_lastClick && Date.now() - _lastClick < 500)
        return window.location.reload();
      _lastClick = Date.now();
    }
    Inherit(this, Element);
    const _this = this;
    let $this, _lastClick;
    initHTML(),
      addHandlers(),
      (this.customize = function (on) {
        on
          ? $this
              .tween({ opacity: 0 }, 1e3, "easeInOutSine")
              .onComplete((_) => {
                $this.hide();
              })
          : $this.show().tween({ opacity: 1 }, 1e3, "easeInOutSine");
      }),
      (this.animateIn = function () {
        $this.tween({ opacity: 1, scale: 1, x: 0 }, 2e3, "easeOutCubic");
      }),
      (this.animateOut = function () {
        $this.tween({ opacity: 0, scale: 0.95, x: -5 }, 700, "easeOutCubic");
      });
  }),
  Class(function UIMenu() {
    function initHTML() {
      $this.css({ position: "static" }), $this.hide();
    }
    function initViews() {
      (_closeCatch = _this.initClass(UIMenuCloseCatch)),
        (_sidebar = _this.initClass(UIMenuSidebar)),
        (_togglePrompt = _this.initClass(UIMenuPrompt));
    }
    function addHandlers() {
      (_togglePrompt.onClick = toggleClick), (_closeCatch.onClick = close);
    }
    function toggleClick() {
      _this.isActive ? close() : open();
    }
    function open() {
      _this.isActive ||
        ((_this.isActive = !0),
        _togglePrompt.open("white"),
        _closeCatch.animateIn(),
        _sidebar.animateIn(),
        Track.event("menu", "open"));
    }
    function close() {
      _this.isActive &&
        ((_this.isActive = !1),
        _togglePrompt.close(Customise.instance().isPaused ? "white" : "dark"),
        _closeCatch.animateOut(),
        _sidebar.animateOut(),
        Track.event("menu", "close"));
    }
    Inherit(this, Element);
    const _this = this,
      $this = _this.element;
    let _togglePrompt, _sidebar, _closeCatch;
    initHTML(),
      initViews(),
      addHandlers(),
      (this.animateIn = function () {
        $this.show(), _togglePrompt.animateIn();
      }),
      (this.animateOut = async function () {
        _togglePrompt.animateOut(), await _this.defer(700), $this.hide();
      });
  }),
  Class(function UIMenuCloseCatch() {
    function initHTML() {
      $this.css({
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: "#101519",
        opacity: 0.8,
        zIndex: 99,
      }),
        $this.css({ opacity: 0 }),
        $this.hide();
    }
    function addHandlers() {
      $this.interact(null, click);
    }
    function click() {
      _this.onClick && _this.onClick();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    initHTML(),
      addHandlers(),
      (this.animateIn = function () {
        $this.show(), $this.tween({ opacity: 0.8 }, 2e3, "easeOutCubic");
      }),
      (this.animateOut = async function () {
        await $this.tween({ opacity: 0 }, 1e3, "easeOutCubic").promise(),
          $this.hide();
      });
  }),
  Class(function UIMenuPrompt() {
    function initHTML() {
      $this.css({
        top: 20,
        right: 30,
        padding: "30px 30px 30px 80px",
        opacity: 0,
        zIndex: 99,
      }),
        ($line1 = addLine()),
        ($line2 = addLine()),
        ($line3 = addLine()),
        $line1.transform({ y: 5 }),
        $line2.transform({ y: 0 }),
        $line3.transform({ y: -5 }),
        ($text = $this.create("Text")).text(Data.copy("MENU_ICON_TEXT")),
        $text.css({
          color: "#fff",
          fontFamily: "bebas",
          fontSize: 20,
          textTransform: "uppercase",
          letterSpacing: 2,
          top: 19,
          right: 57,
          width: 100,
          textAlign: "right",
          opacity: 0.6,
        });
    }
    function addLine() {
      const line = $this.create("Line");
      return (
        line.css({
          background: "#fff",
          padding: "1px 12px",
          margin: "-1px -12px",
          borderRadius: 2,
          top: "50%",
          opacity: 0.6,
        }),
        line
      );
    }
    function addHandlers() {
      $this.interact(hover, click),
        _this.events.sub(UISection.OPEN_CUSTOMISE, changeColor),
        _this.events.sub(UISection.CLOSE_CUSTOMISE, changeColor);
    }
    function changeColor(e) {
      let bgColor = e.productCode ? darkLineColor : "#ffffff";
      $line1.tween({ "background-color": bgColor }, 600, "easeOutCubic"),
        $line2.tween({ "background-color": bgColor }, 600, "easeOutCubic"),
        $line3.tween({ "background-color": bgColor }, 600, "easeOutCubic"),
        $text.tween({ color: bgColor }, 600, "easeOutCubic");
    }
    function hover({ action: action }) {
      _this.isAnimating ||
        (_this.parent.isActive
          ? "over" === action
            ? ($line1.tween({ opacity: 1 }, 400, "easeOutCubic"),
              $line2.tween({ opacity: 1 }, 400, "easeOutCubic"),
              $line3.tween({ opacity: 1 }, 400, "easeOutCubic"),
              $text.tween({ opacity: 1 }, 400, "easeOutCubic"))
            : ($line1.tween({ opacity: 0.6 }, 400, "easeOutCubic"),
              $line2.tween({ opacity: 0.6 }, 400, "easeOutCubic"),
              $line3.tween({ opacity: 0.6 }, 400, "easeOutCubic"),
              $text.tween({ opacity: 0.6 }, 400, "easeOutCubic"))
          : "over" === action
          ? ($line1.tween({ opacity: 1, y: 6 }, 400, "easeOutCubic"),
            $line2.tween({ opacity: 1, y: 0 }, 400, "easeOutCubic"),
            $line3.tween({ opacity: 1, y: -6 }, 400, "easeOutCubic"),
            $text.tween({ opacity: 1 }, 400, "easeOutCubic"))
          : ($line1.tween({ opacity: 0.6, y: 5 }, 400, "easeOutCubic"),
            $line2.tween({ opacity: 0.6, y: 0 }, 400, "easeOutCubic"),
            $line3.tween({ opacity: 0.6, y: -5 }, 400, "easeOutCubic"),
            $text.tween({ opacity: 0.6 }, 400, "easeOutCubic")));
    }
    function click() {
      _this.onClick && _this.onClick();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element,
      darkLineColor = "#3c3c3c";
    let $line1, $line2, $line3, $text;
    initHTML(),
      addHandlers(),
      (this.open = async function (color = "white") {
        _this.isAnimating = !0;
        let bgColor = "white" === color ? "#ffffff" : darkLineColor;
        $this.css({ padding: "30px" }),
          $text.tween({ opacity: 0 }, 400, "easeOutCubic").onComplete((_) => {
            $text.hide();
          }),
          $line1.tween(
            { opacity: 0.6, y: 0, rotation: 225, "background-color": bgColor },
            600,
            "easeOutCubic"
          ),
          $line2.tween(
            {
              opacity: 0,
              y: 0,
              scaleX: 0,
              rotation: 45,
              "background-color": bgColor,
            },
            600,
            "easeOutCubic"
          ),
          await $line3
            .tween(
              {
                opacity: 0.6,
                y: 0,
                rotation: -45,
                "background-color": bgColor,
              },
              600,
              "easeOutCubic"
            )
            .promise(),
          (_this.isAnimating = !1);
      }),
      (this.close = async function (color = "white") {
        _this.isAnimating = !0;
        let bgColor = "white" === color ? "#ffffff" : darkLineColor;
        $this.css({ padding: "30px 30px 30px 80px" }),
          $text.css({ opacity: 0, display: "block" }),
          $text.tween({ opacity: 0.6 }, 600, "easeOutCubic", 600),
          $line1.tween(
            { opacity: 0.6, y: 5, rotation: 0, "background-color": bgColor },
            600,
            "easeOutCubic"
          ),
          $line2.tween(
            {
              opacity: 0.6,
              y: 0,
              scaleX: 1,
              rotation: 0,
              "background-color": bgColor,
            },
            600,
            "easeOutCubic"
          ),
          await $line3
            .tween(
              { opacity: 0.6, y: -5, rotation: 0, "background-color": bgColor },
              600,
              "easeOutCubic"
            )
            .promise(),
          (_this.isAnimating = !1);
      }),
      (this.animateIn = function () {
        $this.tween({ opacity: 1 }, 2e3, "easeOutQuint");
      }),
      (this.animateOut = function () {
        $this.tween({ opacity: 0 }, 700, "easeOutQuint");
      });
  }),
  Class(function UIMenuSidebar() {
    function init() {
      (_language = _this.initClass(UIMenuLanguage)),
        $this.add(_language.element),
        ($glow = $this.create(".glow"))
          .size("100%")
          .css({ boxShadow: "rgba(216, 255, 62, 0.47) 0px 0px 300px 0px" })
          .mouseEnabled(!1),
        ($container = $this.create("Container"));
      for (let i = 0; i < 3; i++) addLink(Data.MENU[i], i);
      (_contact = _this.initClass(UIMenuContactPrompt)),
        $container.add(_contact.element),
        _elements.push(_contact.element);
    }
    function addLink(data, i) {
      const link = _this.initClass(UIMenuLink, data, i);
      $container.add(link.element), _elements.push(link.element);
    }
    function style() {
      $this.css({
        top: 0,
        bottom: 0,
        right: 0,
        width: 400,
        background: "#10151A",
        zIndex: 99,
      }),
        $container.css({
          position: "relative",
          padding: "0 60px",
          margin: "auto",
        }),
        "ie" === Device.system.browser &&
          Device.system.browserVersion < 12 &&
          $container.css({ marginTop: 120 }),
        $this.css({ opacity: 0 }).transform({ x: 400 }),
        $this.hide();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $container, $glow, _language, _contact;
    var _elements = [];
    init(),
      style(),
      (this.animateIn = function () {
        ($this.div.style.display = "flex"),
          $glow
            .css({ opacity: 0 })
            .tween({ opacity: 1 }, 1500, "easeInOutCubic"),
          $this.tween({ opacity: 1, x: 0 }, 1500, "easeOutExpo"),
          _elements.forEach((el, i) => {
            el.transform({ x: 50 })
              .css({ opacity: 0 })
              .tween({ opacity: 1, x: 0 }, 1e3, "easeOutCubic", 100 * i + 200);
          });
      }),
      (this.animateOut = async function () {
        $glow.tween({ opacity: 0 }, 1e3, "easeOutCubic"),
          await $this
            .tween({ opacity: 0, x: 200 }, 1e3, "easeOutCubic")
            .promise(),
          $this.hide();
      });
  }),
  Class(function UIMenuContactPrompt() {
    function initHTML() {
      $this.css({ position: "relative", opacity: 0.6, marginTop: 60 }),
        ($text = $this.create(".text")).fontStyle("montserrat", 11, "#fff"),
        $text.css({
          position: "relative",
          textTransform: "uppercase",
          letterSpacing: "0.2em",
          display: "block",
          opacity: 0.6,
          textAlign: "center",
          lineHeight: 46,
        }),
        $text.text(Data.copy("MENU_CONTACT")),
        ($border = $this.create(".border"))
          .size("100%")
          .css({
            top: 0,
            opacity: 0.3,
            borderRadius: 1e3,
            boxShadow: "#ffffff 0px 0px 0px 2px",
          }),
        ($glow = $this.create(".glow"))
          .size("100%")
          .css({
            boxShadow: `0 0 40px ${Config.BRAND_COLOR}`,
            opacity: 0,
            top: 0,
            borderRadius: 1e3,
          });
    }
    function addHandlers() {
      $this.interact(hover, click);
    }
    function hover(e) {
      switch (e.action) {
        case "over":
          $glow.tween({ opacity: 1 }, 300, "easeOutSine"),
            $text.tween({ opacity: 1 }, 300, "easeOutSine"),
            $border.tween(
              { opacity: 0.8, boxShadowColor: Config.BRAND_COLOR },
              300,
              "easeOutSine"
            );
          break;
        case "out":
          $glow.tween({ opacity: 0 }, 500, "easeOutSine"),
            $text.tween({ opacity: 0.6 }, 500, "easeOutSine"),
            $border.tween(
              { opacity: 0.3, boxShadowColor: "#fff" },
              500,
              "easeOutSine"
            );
      }
    }
    function click() {
      Track.event("menu", "contact"), _this.events.fire(UI.OPEN_MODAL);
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    var $border, $text, $glow;
    initHTML(),
      addHandlers(),
      (this.animateIn = function () {}),
      (this.animateOut = function () {});
  }),
  Class(function UIMenuLanguage() {
    function initHTML() {
      ($title = $this.create("LanguageTitle")).text(Data.copy("MENU_LANGUAGE")),
        _data.forEach(addLink),
        $this.css({
          fontFamily: "montserrat",
          textTransform: "uppercase",
          letterSpacing: "0.15em",
          fontSize: 11,
          left: 0,
          right: 0,
          margin: "40px 60px",
          lineHeight: 20,
        }),
        $title.css({
          position: "relative",
          display: "inline-block",
          marginRight: 10,
          opacity: 0.3,
          fontSize: 10,
        });
    }
    function addLink(data, i) {
      const link = $this.create("LanguageLink");
      link.text(data.text),
        link.interact(
          (e) => {
            e.object.isActive ||
              e.object.tween(
                { opacity: "over" == e.action ? 1 : 0.5 },
                300,
                "easeOutSine"
              );
          },
          () => {
            Track.event("menu", "language-click", data.link),
              _this.delayedCall(() => {
                location.href =
                  location.origin +
                  location.pathname +
                  (data.link ? `?lang=${data.link}` : "");
              }, 500);
          }
        ),
        link.css({
          display: "inline-block",
          position: "relative",
          padding: "0px 10px",
          opacity: 0.5,
        }),
        (link.isActive = Utils.query("lang") === data.link),
        link.isActive && link.css({ opacity: 1, color: "#BAC50C" }),
        _links.push(link);
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $title;
    const _links = [],
      _data = [
        { text: "DE", link: "de" },
        { text: "EN", link: !1 },
        { text: "", link: "cn" },
        { text: "", link: "ja" },
      ];
    initHTML();
  }),
  Class(function UIMenuLink(_data, _index) {
    function initHTML() {
      ($icon = $this.create("LinkIcon")),
        ($title = $this.create("LinkTitle")),
        ($desc = $this.create("LinkDescription")),
        $title.text(_data.name),
        $desc.text(_data.description),
        $this.css({ position: "relative", marginBottom: 40 }),
        (_icon = _this.initClass(UIIcon, {
          size: 54,
          border: !0,
          icon: "menu/link.svg",
          overIcon: "menu/link-over.svg",
        })).element.css({ top: 0, left: 0 }),
        $title.css({
          position: "relative",
          textTransform: "uppercase",
          fontFamily: "bebas",
          display: "block",
          fontSize: 19,
          letterSpacing: "0.15em",
          paddingLeft: 70,
          marginTop: 3,
          opacity: 0.8,
          marginBottom: 3,
        }),
        $desc.css({
          position: "relative",
          display: "block",
          paddingLeft: 70,
          fontSize: 9,
          opacity: 0.4,
          textTransform: "uppercase",
          letterSpacing: "0.2em",
          lineHeight: "1.5em",
        });
    }
    function addHandlers() {
      $this.interact(hover, click);
    }
    function hover(e) {
      switch (e.action) {
        case "over":
          _icon.hoverIn("transparent"),
            $title.tween(
              { opacity: 1, color: Config.BRAND_COLOR },
              300,
              "easeOutSine"
            ),
            $desc.tween(
              { opacity: 0.7, color: Config.BRAND_COLOR },
              300,
              "easeOutSine"
            );
          break;
        case "out":
          _icon.hoverOut(),
            $title.tween({ opacity: 0.8, color: "#fff" }, 600, "easeOutSine"),
            $desc.tween({ opacity: 0.4, color: "#fff" }, 600, "easeOutSine");
      }
    }
    function click() {
      Track.event("menu", "external-link", _data.name),
        window.open(_data.url, "_blank");
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $icon, $title, $desc;
    var _icon;
    initHTML(), addHandlers();
  }),
  Class(function UIModal(_textField = !1) {
    function init() {
      ($clickCatch = $this.create("ClickCatch")),
        ($container = $this.create("Container")),
        (_closePrompt = _this.initClass(UIModalClose)),
        $clickCatch.add(_closePrompt),
        (_closePrompt.onClick = close),
        ($icon = $container.create("Icon")),
        ($title = $container.create("Title")),
        ($text = $container.create("Text")),
        ($form = $container.create("Form", "form")),
        $title.text(Data.copy("MODAL_ENJOY_TITLE")),
        $text.text(
          _textField
            ? Data.copy("MODAL_CONTACT_TEXT")
            : Data.copy("MODAL_ENJOY_TEXT")
        ),
        _config.forEach((d) => {
          if ("message" !== d.id) {
            const $input = $form.create("Input", "input");
            ($input.div.required = d.required),
              ($input.div.type = d.type),
              ($input.div.placeholder = d.text + (d.required ? "*" : "")),
              _inputs.push($input);
          } else
            ((_textarea = $form.create("Input", "textarea")).div.required =
              d.required),
              (_textarea.div.placeholder = d.text + (d.required ? "*" : "")),
              (_textarea._textarea = !0),
              _inputs.push(_textarea);
        }),
        ($optLabel = $container.create("OptInLabel", "label")).text(
          Data.copy("MODAL_OPT_TEXT")
        ),
        (($opt = $optLabel.create("OptIn", "input")).div.type = "checkbox"),
        ($required = $container.create("Required")),
        ($submit = $container.create("Submit")),
        $required.text("*" + Data.copy("MODAL_REQUIRED")),
        $submit.text(Data.copy("MODAL_SUBMIT"));
    }
    function style() {
      $this.size("100%").css({ zIndex: 100, opacity: 0 }),
        $clickCatch.size("100%").css({ background: "#000000", opacity: "0.9" }),
        $container.css({
          width: 400,
          height: 550,
          left: 0,
          top: 0,
          right: 0,
          bottom: 0,
          margin: "auto",
          textAlign: "center",
          textTransform: "uppercase",
          fontFamily: "montserrat",
        }),
        $icon.bg("assets/images/ui/modal/hand.svg", "contain"),
        $icon.css({
          backgroundRepeat: "no-repeat",
          position: "relative",
          padding: 20,
          display: "inline-block",
        }),
        $title.css({
          position: "relative",
          fontFamily: "bebas",
          fontSize: 30,
          letterSpacing: "0.12em",
          marginBottom: 20,
        }),
        $text.css({
          position: "relative",
          fontSize: 10,
          lineHeight: "1.8em",
          letterSpacing: "0.02em",
          marginBottom: 30,
        }),
        $form.css({ position: "relative" }),
        _inputs.forEach((input, i) => {
          input.css({
            position: "relative",
            display: "inline-block",
            width: 175,
            marginLeft: i % 2 ? 50 : 0,
            marginBottom: 20,
            border: "none",
            borderBottom: "1px solid rgba(255, 255, 255, 0.2)",
            padding: 0,
            background: "none",
            color: "#fff",
            fontSize: 11,
            lineHeight:
              "ja" !== Config.LANG || input._textarea ? "1.8em" : "0.5em",
          });
        }),
        _textarea.css({
          width: 398,
          height: 85,
          border: "1px solid rgba(255, 255, 255, 0.2)",
          marginBottom: 0,
        }),
        $opt.css({ top: 0, left: 0, margin: 0 }),
        $optLabel.css({
          position: "relative",
          fontSize: 8,
          textAlign: "left",
          lineHeight: "1.6em",
          opacity: "0.5",
          marginTop: 20,
          marginBottom: 20,
          display: "inline-block",
          paddingLeft: 20,
        }),
        $required.css({
          position: "relative",
          fontSize: 8,
          opacity: "0.5",
          marginBottom: 10,
        }),
        $submit.css({
          cursor: "pointer",
          position: "relative",
          display: "inline-block",
          border: "1px solid #ffffff",
          borderRadius: 1e3,
          padding: "8px 30px",
          fontSize: 10,
          textTransform: "uppercase",
          letterSpacing: "0.1em",
        });
    }
    function addHandlers() {
      $submit.interact(hoverSubmit, submit),
        $clickCatch.click(close),
        ($clickCatch.div.style.cursor = ""),
        _this.onResize(resize);
    }
    function resize() {
      let scale = Math.min(1, Stage.height / 745);
      $container.transform({ scale: scale });
    }
    function hoverSubmit() {}
    async function submit() {
      let data = {};
      _inputs.map((input, index) => {
        let config = _config[index];
        data[config.id] = input.div.value;
      }),
        (data.terms = $opt.div.checked),
        Track.event("contact-modal", "submit");
      let response = await post(Config.CONTACT, data, {
        headers: { "Content-Type": "application/json" },
      });
      response.success ? close() : error(response.message);
    }
    function error(message) {
      alert(message);
    }
    async function close() {
      _this.isClosing ||
        ((_this.isClosing = !0),
        _this.events.fire(UI.CLOSE_MODAL),
        await animateOut(),
        _this.destroy());
    }
    function animateIn() {
      Track.event("contact-modal", "open"),
        $this.tween({ opacity: 1 }, 2e3, "easeOutCubic");
    }
    function animateOut() {
      return $this.tween({ opacity: 0 }, 1e3, "easeOutCubic").promise();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $clickCatch,
      $container,
      $submit,
      $icon,
      $title,
      $text,
      $form,
      $opt,
      $optLabel,
      $required;
    var _closePrompt, _textarea;
    const _config = [
        {
          id: "firstName",
          text: Data.copy("MODAL_FIRST_NAME"),
          required: !0,
          type: "text",
        },
        {
          id: "lastName",
          text: Data.copy("MODAL_LAST_NAME"),
          required: !0,
          type: "text",
        },
        {
          id: "company",
          text: Data.copy("MODAL_COMPANY"),
          required: !1,
          type: "text",
        },
        {
          id: "position",
          text: Data.copy("MODAL_POSITION"),
          required: !1,
          type: "text",
        },
        {
          id: "email",
          text: Data.copy("MODAL_EMAIL"),
          required: !0,
          type: "email",
        },
        {
          id: "emailConfirm",
          text: Data.copy("MODAL_CONFIRM_EMAIL"),
          required: !0,
          type: "email",
        },
        {
          id: "message",
          text: Data.copy("MODAL_MESSAGE"),
          required: !1,
          type: "textarea",
        },
      ],
      _inputs = [];
    init(), style(), addHandlers(), animateIn();
  }),
  Class(function UIModalClose() {
    function init() {
      $this.css({
        top: "10%",
        left: "50%",
        padding: 30,
        margin: -30,
        opacity: 0.8,
      }),
        (_icon = _this.initClass(UIIcon, {
          size: 50,
          border: !0,
          icon: "customise/close.svg",
          color: "#fff",
          hover: "#fff",
        })).element.css({ top: 0, left: 0 });
    }
    function addHandlers() {
      $this.interact(hover, click);
    }
    function hover(e) {
      switch (e.action) {
        case "over":
          _icon.hoverIn("#fff");
          break;
        case "out":
          _icon.hoverOut();
      }
    }
    function click() {
      _this.onClick && _this.onClick();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    var _icon;
    init(), addHandlers();
  }),
  Class(
    function UICompare() {
      async function swapReport(index, side, isUpdate = !1) {
        _active[side] &&
          (isUpdate
            ? await _active[side].hide()
            : _active[side].element.css({ opacity: 0 }).hide()),
          (_active[side] = _reports[side][index]),
          _active[side]
            ? ((_loaded[side] = !0), enablePagination())
            : ((_preloads[side] = _this.initClass(UIReportSummaryPreload, [
                _sides[side],
              ])),
              (_active[side] = _this.initClass(
                UIReportSummary,
                index,
                "left" === side ? 1 : -1,
                [_sides[side]]
              )),
              (_active[side].isCompareReport = !0),
              (_reports[side][index] = _active[side]),
              _this.events.sub(_active[side], UICompare.HIDE_PRELOAD, () => {
                clearPreloads(side), (_loaded[side] = !0), enablePagination();
              })),
          _active[side].show();
      }
      async function enablePagination(side) {
        _loaded.left &&
          _loaded.right &&
          (await _this.wait(1e3),
          _paginations.forEach((p) => {
            p.isEnabled = !0;
          }));
      }
      function clearPreloads(side = null) {
        side
          ? ("left" === side &&
              _preloads.left &&
              _preloads.left.hide &&
              (_preloads.left.hide(), (_preloads.left = null)),
            "right" === side &&
              _preloads.right &&
              _preloads.right.hide &&
              (_preloads.right.hide(), (_preloads.right = null)))
          : (_preloads.left && _preloads.left.hide && _preloads.left.hide(),
            _preloads.right && _preloads.right.hide && _preloads.right.hide(),
            (_preloads.left = null),
            (_preloads.right = null));
      }
      function addHandlers() {
        $close.interact(closeHover, closeClick),
          $close.hit.size(30, 30).center(),
          _this.events.sub(UICompare.TOGGLE_SUMMARY, toggleSummary);
      }
      function toggleSummary({ index: index, state: state }) {
        _active.left &&
          _active.left.isLoaded &&
          _active.right &&
          _active.right.isLoaded &&
          ["left", "right"].forEach((el) => {
            _active[el].products.products[index].isCollapsed !== state &&
              _active[el].products.products[index].toggleClick();
          });
      }
      function closeHover() {}
      function closeClick() {
        _this.isClosing || (_this.onClose && _this.onClose());
      }
      Inherit(this, Element);
      const _this = this,
        $this = this.element;
      let $container, $wrapper, $scroll, $close;
      const _sides = { left: null, right: null };
      this.sides = _sides;
      const _preloads = { left: null, right: null },
        _loaded = { left: !1, right: !1 },
        _paginations = [];
      let _reports = { left: [], right: [] },
        _leftIndex = -1,
        _rightIndex = -1;
      const _active = { left: null, right: null };
      var _size = Tests.smallTablet() ? 470 : 502;
      (UICompare.reports = _reports),
        (function init() {
          (($container = $this.create("Container")).bg =
            $container.create(".bg")),
            $container.bg
              .size("100%")
              .bg("#10151A")
              .css({ opacity: Device.mobile ? 0.98 : 0.85 }),
            ($scroll = $container.create(".scroll")),
            (_this.scrollElement = $scroll),
            ($wrapper = $scroll.create(".wrapper")),
            ($close = $this.create("ClosePrompt")),
            (_sides.left = $wrapper.create("Left")),
            (_sides.right = $wrapper.create("Right"));
          const paginationLeft = _this.initClass(UIReportPagination, [
            _sides.left,
          ]);
          paginationLeft.element.css({
            position: "relative",
            display: "block",
            left: "",
            marginLeft: "",
            marginTop: 50,
            marginBottom: 50,
          });
          const paginationRight = _this.initClass(UIReportPagination, [
            _sides.right,
          ]);
          paginationRight.element.css({
            position: "relative",
            display: "block",
            left: "",
            marginLeft: "",
            marginTop: 50,
            marginBottom: 50,
          }),
            _paginations.push(paginationLeft),
            _paginations.push(paginationRight),
            (paginationLeft.onChange = (index) => {
              _paginations.forEach((p) => {
                p.isEnabled = !1;
              }),
                (_loaded.left = !1),
                paginationRight.enableReport(_leftIndex),
                (_leftIndex = index),
                paginationRight.disableReport(_leftIndex),
                swapReport(_leftIndex, "left", !0);
            }),
            (paginationRight.onChange = (index) => {
              _paginations.forEach((p) => {
                p.isEnabled = !1;
              }),
                (_loaded.right = !1),
                paginationLeft.enableReport(_rightIndex),
                (_rightIndex = index),
                paginationLeft.disableReport(_rightIndex),
                swapReport(_rightIndex, "right", !0);
            }),
            $this.css({ position: "static" }),
            $container.size("100%").css({ textAlign: "center" }).setZ(20),
            $scroll.size("100%").overflowScroll({ y: 1 }),
            $wrapper.css({
              position: "relative",
              display: "block",
              margin: "100px auto 0 auto",
              width: Tests.smallTablet() ? 980 : 1044,
            }),
            [_sides.left, _sides.right].forEach((el) => {
              el.css({
                width: _size,
                willChange: "opacity",
                position: "relative",
                display: "inline-block",
              });
            }),
            _sides.left.css({ float: "left" }),
            _sides.right.css({ float: "right" }),
            $close
              .bg("assets/images/ui/customise/close.svg", "contain")
              .css({
                top: 100,
                left: "50%",
                padding: 10,
                margin: Device.mobile ? "-10px 0 0 -10px" : "-10px 0 0 -15px",
              })
              .setZ(30)
              .css({ opacity: 0 }),
            $this.hide();
        })(),
        addHandlers(),
        (this.open = function (index) {
          (_this.isOpen = !0), _this.deleteAllReports();
          const num = Reports.list().length;
          for (; _paginations[0].dots.length !== num; )
            _paginations[0].dots.length < num
              ? (_paginations[0].addReport(), _paginations[1].addReport())
              : (_paginations[0].deleteReport(),
                _paginations[1].deleteReport());
          for (let i = 0; i < num; i++)
            _paginations[0].enableReport(i), _paginations[1].enableReport(i);
          _paginations.forEach((p) => {
            (p.isEnabled = !1),
              p.element.css({ opacity: 0 }),
              _this.delayedCall(() => {
                p.show();
              }, 500);
          }),
            (_rightIndex = 0 === (_leftIndex = index) ? 1 : 0),
            (_loaded.left = !1),
            (_loaded.right = !1),
            swapReport(_leftIndex, "left"),
            swapReport(_rightIndex, "right"),
            _paginations[0].selectReport(_leftIndex),
            _paginations[1].selectReport(_rightIndex),
            _paginations[0].disableReport(_rightIndex),
            _paginations[1].disableReport(_leftIndex),
            $this.show(),
            _this.scrollTo(0),
            $container
              .css({ opacity: 0 })
              .transform({ scale: 1.15, y: 0 })
              .tween({ scale: 1, y: 0, opacity: 1 }, 1500, "easeOutCubic"),
            $close.tween({ opacity: 1 }, 1e3, "easeOutCubic", 1e3);
        }),
        (this.close = async function () {
          _this.isClosing ||
            ((_this.isClosing = !0),
            clearPreloads(),
            $close.tween({ opacity: 0 }, 500, "easeOutCubic"),
            await $container
              .tween(
                { scale: 1.1, y: 0, opacity: 0 },
                500,
                "easeOutCubic",
                (_) => {
                  $this.hide(), (_this.isClosing = !1), (_this.isOpen = !1);
                }
              )
              .promise(),
            _this.deleteAllReports());
        }),
        (this.deleteAllReports = function () {
          _paginations[0].deleteAllReports(),
            _paginations[1].deleteAllReports(),
            _reports.left.forEach((report) => {
              report.destroy();
            }),
            _reports.right.forEach((report) => {
              report.destroy();
            }),
            (_reports.left = []),
            (_reports.right = []),
            (UICompare.reports = _reports),
            clearPreloads(),
            (_leftIndex = -1),
            (_rightIndex = -1),
            (_active.left = null),
            (_active.right = null),
            (_loaded.left = !1),
            (_loaded.right = !1);
        }),
        (this.scrollTo = function (value) {
          $scroll.div.scrollTop = Math.round(value);
        }),
        (this.scrollPos = function () {
          return $scroll.div.scrollTop;
        });
    },
    "singleton",
    () => {
      (UICompare.HIDE_PRELOAD = "ui_compare_hide_preload"),
        (UICompare.TOGGLE_SUMMARY = "ui_compare_hide_preload");
    }
  ),
  Class(
    function UIReport() {
      function initReports() {
        Reports.list().forEach(() => {
          _reports.push(null), _pagination.addReport();
        });
      }
      function addHandlers() {
        (_pagination.onChange = swapReport),
          _this.onResize(resize),
          (_functions.onDelete = deleteReport),
          (_functions.onDeleteAll = deleteAllReports),
          (_functions.onCompare = openCompare),
          (UICompare.instance().onClose = closeCompare);
      }
      function resize() {
        $wrapper.css({ marginTop: 0.2 * Stage.height });
      }
      async function swapReport(index, isUpdate) {
        _functions.setActive(null),
          (_pagination.isEnabled = !1),
          _loader.isActive && _loader.animateOut(),
          _activeReport && _activeReport.hide && (await _activeReport.hide()),
          (_activeReport = _reports[index])
            ? enablePagination()
            : ((_activeReport = _this.initClass(UIReportSummary, index, 1, [
                $summaries,
              ])),
              (_reports[index] = _activeReport),
              _this.events.fire(UISection.COMPARE_UPDATE, {
                active: _reports.length > 1,
              }),
              _this.events.fire(UISection.CHOICES_TOGGLE, { active: !1 }),
              _loader.animateIn(!1, _activeReport.report),
              _activeReport.ready.then(() => {
                _loader.animateOut(),
                  _this.events.fire(UISection.CHOICES_TOGGLE, { active: !0 }),
                  enablePagination();
              })),
          _activeReport.show(),
          _this.scrollTo(0),
          _functions.setActive(_activeReport),
          isUpdate && _pagination.selectReport(index);
      }
      async function enablePagination() {
        await _this.wait(1e3), (_pagination.isEnabled = !0);
      }
      function deleteReport(index) {
        Reports.delete(index),
          _pagination.deleteReport(index),
          _reports[index].destroy(),
          _reports.splice(index, 1),
          _this.events.fire(UISection.COMPARE_UPDATE, {
            active: _reports.length > 1,
          }),
          _this.events.fire(UISection.CHOICES_TOGGLE, { active: !1 }),
          _this.events.fire(UISection.CHOICES_TOGGLE, { active: !0 }),
          ($this.div.scrollTop = 0),
          (_activeReport = null),
          _reports.length
            ? swapReport(_reports.length - 1, !0)
            : _this.events.fire(UISection.APPLICATION_RESET);
      }
      function deleteAllReports() {
        let deleteConfirmation = _this.initClass(UIConfirmationPopup, "delete");
        (deleteConfirmation.onConfirm = () => {
          Reports.deleteAll(),
            _pagination.deleteAllReports(),
            _reports.forEach((report) => {
              report &&
                report.hide().then(() => {
                  report.destroy();
                });
            }),
            (UIReport.reports = _reports = []),
            ($this.div.scrollTop = 0),
            (_activeReport = null),
            UICompare.instance().deleteAllReports(),
            _this.events.fire(UISection.APPLICATION_RESET);
        }),
          UI.instance().element.add(deleteConfirmation);
      }
      function openCompare() {
        const index = _reports.indexOf(_activeReport);
        UICompare.instance().open(index), _this.hide();
      }
      async function closeCompare() {
        await UICompare.instance().close(),
          _pagination.show(),
          _activeReport.show(),
          _this.show();
      }
      function loop() {
        let wrapperHeight, scrollableAmount, scrollPercent;
        UICompare.instance().isOpen
          ? ((wrapperHeight =
              100 +
              Math.max(
                UICompare.instance().sides.left &&
                  UICompare.instance().sides.left.div &&
                  UICompare.instance().sides.left.div.clientHeight,
                UICompare.instance().sides.right &&
                  UICompare.instance().sides.right.div &&
                  UICompare.instance().sides.right.div.clientHeight
              )),
            (scrollPercent =
              0 ===
              (scrollableAmount = Math.max(0, wrapperHeight - Stage.height))
                ? 0
                : ((UICompare.instance().scrollElement &&
                    UICompare.instance().scrollElement.div.scrollTop) ||
                    0) / scrollableAmount))
          : ((wrapperHeight =
              $wrapper.div.clientHeight + 0.2 * Stage.height + 100),
            (scrollPercent =
              0 ===
              (scrollableAmount = Math.max(0, wrapperHeight - Stage.height))
                ? 0
                : $scroll.div.scrollTop / scrollableAmount)),
          (_currentCameraRotation +=
            0.05 *
            ((_targetCameraRotation = 0.004 * scrollPercent) -
              _currentCameraRotation)),
          CarCamera.instance().rotateLeft(
            _targetCameraRotation - _currentCameraRotation
          );
      }
      Inherit(this, Element);
      const _this = this,
        $this = this.element;
      let _functions,
        _pagination,
        _loader,
        $scroll,
        $wrapper,
        $summaries,
        _activeReport,
        _reports = [];
      var _size = Tests.smallTablet() ? 470 : 502,
        _targetCameraRotation = 0,
        _currentCameraRotation = 0;
      (UIReport.reports = _reports),
        (function init() {
          $this.css({ position: "static" }),
            ($scroll = $this.create(".scroll")).size("100%"),
            $scroll.overflowScroll({ y: 1 }),
            ($scroll.div.style.webkitMaskImage =
              "linear-gradient(0deg, rgba(0,0,0,0) 2%, rgba(0, 0, 0, 1) 20%, rgba(0,0,0,1) 80%, rgba(0,0,0,0) 98%)"),
            ($scroll.div.style.maskImage =
              "linear-gradient(0deg, rgba(0,0,0,0) 2%, rgba(0, 0, 0, 1) 20%, rgba(0,0,0,1) 80%, rgba(0,0,0,0) 98%)"),
            ($wrapper = $scroll.create(".wrapper")).css({
              width: _size,
              margin: "200px auto 100px auto",
              textAlign: "center",
              position: "relative",
              display: "block",
            }),
            (_functions = _this.initClass(UIReportFunctions, [$wrapper])),
            (_pagination = _this.initClass(UIReportPagination)),
            ($summaries = $wrapper.create("Summaries")).css({
              position: "relative",
            }),
            (_loader = _this.initClass(UIReportLoader)),
            $this.hide();
        })(),
        initReports(),
        addHandlers(),
        (this.show = function () {
          $this.show(),
            _this.scrollTo(0),
            (_targetCameraRotation = 0),
            (_currentCameraRotation = 0),
            _this.startRender(loop);
        }),
        (this.hide = async function () {
          CarCamera.instance().stopRotateLeft(),
            _pagination.hide(),
            _activeReport && _activeReport.hide && (await _activeReport.hide()),
            $this.hide();
        }),
        (this.stopMovingCamera = function () {
          _this.stopRender(loop);
        }),
        (this.generateReport = async function () {
          let deeplink = !!location.search.includes("code=");
          _loader.animateIn(deeplink),
            _this.events.fire(UISection.CHOICES_TOGGLE, { active: !1 }),
            _activeReport && _activeReport.element.css({ opacity: 0 }).hide(),
            _pagination.element.css({ opacity: 0 }),
            (_activeReport = _this.initClass(UIReportSummary, null, 1, [
              $summaries,
            ])),
            _reports.push(_activeReport),
            _this.events.fire(UISection.COMPARE_UPDATE, {
              active: _reports.length > 1,
            });
          const uid = _activeReport.uid;
          _pagination.addReport(),
            _activeReport.ready.then(async () => {
              _activeReport.uid === uid &&
                (_pagination.show(),
                _activeReport.show(),
                _loader.animateOut(),
                await _this.wait(1e3),
                _this.events.fire(UISection.CHOICES_TOGGLE, { active: !0 }));
            }),
            _functions.setActive(_activeReport);
        }),
        (this.scrollTo = function (value) {
          $scroll.div.scrollTop = Math.round(value);
        }),
        (this.scrollPos = function () {
          return $scroll.div.scrollTop;
        });
    },
    "singleton",
    () => {
      UIReport.LINK = "event_report_link";
    }
  ),
  Class(function UIReportFunctions() {
    function addHandlers() {
      _this.events.sub(UIReport.LINK, linkAction);
    }
    function linkAction({ action: action }) {
      _this[action] && _this[action]();
    }
    Inherit(this, Component);
    const _this = this;
    let _activeReport;
    addHandlers(),
      (this.rename = function () {
        _activeReport && _activeReport.focusTitle();
      }),
      (this.delete = function () {
        if (!_activeReport) return;
        const index = Reports.list().indexOf(_activeReport.report);
        index < 0 || (_this.onDelete && _this.onDelete(index));
      }),
      (this.deleteAll = function () {
        _this.onDeleteAll && _this.onDeleteAll();
      }),
      (this.email = function () {
        if (!_activeReport) return;
        let link = _activeReport.report.shareURL(),
          subject = encodeURIComponent(Data.copy("REPORT_EMAIL_SUBJECT")),
          body = encodeURIComponent(
            `${Data.copy("REPORT_EMAIL_CONTENT")}\n\n${
              _activeReport.title
            }\n\n${link}`
          );
        window.location.href = `mailto:?subject=${subject}&body=${body}`;
      }),
      (this.share = function () {
        _activeReport &&
          (Utils.copyToClipboard(_activeReport.report.shareURL()),
          UI.instance().element.add(
            _this.initClass(UIConfirmationPopup, "url")
          ));
      }),
      (this.compare = function () {
        _activeReport &&
          (Reports.list().length < 2 || (_this.onCompare && _this.onCompare()));
      }),
      (this.setActive = function (report) {
        _activeReport = report;
      });
  }),
  Class(function UIReportLoader() {
    function init() {
      ($text = $this.create("Text")).html(
        Data.copy("GENERATING_REPORT").replace(
          "###",
          Configuration.data ? Meta.getPresetName(Configuration.preset) : ""
        )
      ),
        $this.css({ left: "50%", top: "50%", zIndex: 100 }),
        $text.css({
          textTransform: "uppercase",
          lineHeight: "1.6em",
          left: "50%",
          top: "50%",
          fontSize: 13,
          color: _presetColor,
          letterSpacing: "0.2em",
          textAlign: "center",
          width: 150,
          transform: "translate(-50%, -50%)",
        }),
        $this.css({ opacity: 0 }),
        $this.hide();
    }
    function initCanvas() {
      (_canvas = _this.initClass(Canvas, _size, _size)).element.css({
        margin: -0.5 * _size,
      }),
        (_context = _canvas.context),
        $this.add(_canvas.element);
    }
    function loop(t) {
      _context.clearRect(0, 0, _size, _size),
        (_context.lineWidth = Math.round(0.004 * _size)),
        _context.beginPath(),
        (_context.shadowBlur = 0),
        (_context.strokeStyle = "rgba(255, 255, 255, 0.1)"),
        _context.arc(
          0.5 * _size,
          0.5 * _size,
          0.35 * _size,
          0,
          Math.radians(360),
          !1
        ),
        _context.stroke(),
        _context.closePath();
      let start = Math.radians(-90) + 0.0015 * t;
      const alpha = (5e-4 * t) % 2,
        t1 = Math.min(1, alpha) * Math.PI * 2,
        t2 = Math.max(0, alpha - 1) * Math.PI * 2;
      _context.beginPath(),
        (_context.strokeStyle = _presetColor),
        (_context.shadowBlur = 10),
        (_context.shadowColor = "rgba(230, 235, 61, 0.5)"),
        _context.arc(
          0.5 * _size,
          0.5 * _size,
          0.35 * _size,
          start + t2,
          start + t1
        ),
        _context.stroke(),
        _context.closePath();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $text,
      _canvas,
      _context,
      _size = 440;
    var _presetColor;
    !(async function () {
      await Data.ready(),
        (_presetColor = Colors.instance().UI.main),
        init(),
        initCanvas();
    })(),
      (this.animateIn = function (isShare, report) {
        _this.isActive ||
          ((_this.isActive = !0),
          (_presetColor = Colors.instance().UI.main),
          $text.html(
            Data.copy(
              report
                ? "LOADING_REPORT"
                : isShare
                ? "GENERATING_CUSTOMISATION"
                : "GENERATING_REPORT"
            ).replace(
              "###",
              report
                ? ""
                : Configuration.data
                ? Meta.getPresetName(Configuration.preset)
                : ""
            )
          ),
          $text.css({ color: _presetColor }),
          $this.show(),
          $this.tween({ opacity: 1 }, 1e3, "easeOutCubic"),
          _this.isLoop || _this.startRender(loop),
          (_this.isLoop = !0));
      }),
      (this.animateOut = async function () {
        _this.isActive &&
          ((_this.isActive = !1),
          await $this.tween({ opacity: 0 }, 500, "easeOutCubic").promise(),
          _this.isActive ||
            ($this.hide(), _this.stopRender(loop), (_this.isLoop = !1)));
      });
  }),
  Class(function UIReportButton(_text) {
    function init() {
      ($cont = $this.create("Container")),
        ($bg = $cont.create("Background")),
        ($text = $cont.create("Text")),
        $this.css({}),
        $cont.css({ position: "relative" }),
        $bg.css({
          width: "100%",
          height: "100%",
          borderRadius: 20,
          background: "#1e9cfc",
        }),
        $text
          .html(_text)
          .css({
            position: "relative",
            padding: "14px 30px",
            textTransform: "uppercase",
            fontSize: 11,
            letterSpacing: "0.15em",
            color: "#fff",
          });
    }
    function addHandlers() {
      $text.interact(hover, click);
    }
    function hover() {}
    function click() {
      _this.onClick && _this.onClick();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $cont, $bg, $text;
    init(), addHandlers();
  }),
  Class(function UIReportPagination() {
    function init() {
      $this
        .size(Tests.smallTablet() ? 470 : 500, 20)
        .center(1, 0)
        .css({ top: "10%", textAlign: "center" });
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    (this.dots = []),
      (this.isEnabled = !0),
      init(),
      (this.addReport = function () {
        const $dot = $this.create("Dot");
        ($dot.filled = $dot.create("Fill")),
          ($dot.isEnabled = !0),
          $dot.css({
            position: "relative",
            display: "inline-block",
            padding: 4,
            border: "2px solid #fff",
            opacity: 0.3,
            borderRadius: 10,
            marginRight: 10,
          }),
          $dot.filled.css({
            padding: 4,
            margin: -4,
            background: "#fff",
            borderRadius: 10,
          }),
          _this.dots.push($dot),
          _this.dots.forEach((item, index) => {
            item.dotIndex = index;
          }),
          $dot.interact(
            function hover(e) {
              if (!$dot.isSelected)
                switch (e.action) {
                  case "over":
                    $dot.tween({ opacity: 1 }, 200, "easeOutSine");
                    break;
                  case "out":
                    $dot.tween({ opacity: 0.3 }, 400, "easeOutSine");
                }
            },
            function click(e) {
              _this.isEnabled &&
                $dot.isEnabled &&
                !$dot.isSelected &&
                _this.selectReport($dot.dotIndex, !0);
            }
          ),
          $dot.hit.size(20, 20).center(),
          _this.selectReport($dot.dotIndex);
      }),
      (this.selectReport = function (index, isEmit) {
        _this.dots.forEach((dot, i) => {
          (dot.isSelected = i === index),
            dot.tween(
              { opacity: dot.isSelected ? 1 : 0.3 },
              300,
              "easeOutSine"
            ),
            dot.filled.css({ opacity: index !== i && dot.isEnabled ? 0 : 1 });
        }),
          isEmit && _this.onChange && _this.onChange(index);
      }),
      (this.deleteReport = function (index = 0) {
        _this.dots[index].destroy(),
          _this.dots.splice(index, 1),
          _this.dots.forEach((item, index) => {
            item.dotIndex = index;
          });
      }),
      (this.deleteAllReports = function () {
        _this.dots.forEach((dot) => {
          dot.destroy();
        }),
          (_this.dots = []);
      }),
      (this.disableReport = function (index) {
        -1 !== index &&
          ((_this.dots[index].isEnabled = !1),
          _this.dots[index].css({ opacity: 0.3 }),
          _this.dots[index].filled.css({ opacity: 1 }));
      }),
      (this.enableReport = function (index) {
        -1 !== index &&
          ((_this.dots[index].isEnabled = !0),
          _this.dots[index].css({ opacity: 0.3 }),
          _this.dots[index].isSelected ||
            _this.dots[index].filled.css({ opacity: 0 }));
      }),
      (this.show = function () {
        $this.tween(
          { opacity: _this.dots.length < 2 ? 0 : 1 },
          1e3,
          "easeOutCubic"
        );
      }),
      (this.hide = function () {
        $this.tween({ opacity: 0 }, 500, "easeOutCubic");
      });
  }),
  Class(function UIReportSummary(_index, _direction) {
    async function decodeData() {
      let code = Utils.query("code");
      if (
        location.search.includes("code=") &&
        code &&
        Configuration.validCode(code)
      ) {
        _report = Reports.load(code);
        let lang = Utils.query("lang") ? "?lang=" + Utils.query("lang") : "";
        const path = location.origin + location.pathname + lang;
        window.history.pushState({ path: path }, "", path);
      } else _report = null === _index ? Reports.create() : Reports.list()[_index];
      _this.report = _report;
      const configData = _report.getData(),
        techData = await Promise.all(
          Object.entries(configData.products).map(async function (d) {
            const isComplex = !!_report.getProductVariables(d[0]),
              output = await (isComplex
                ? API.getProductData(d[0], _report)
                : Promise.resolve(
                    Meta.getProductTechnologyOption(d[0], d[1].technologyOption)
                  ));
            if (isComplex) {
              const variables = _report.getProductVariables(d[0]);
              (output.variables = []),
                Data.product(d[0]).productVariables.forEach(
                  (productVariable) => {
                    output.variables.push({
                      name: productVariable.name,
                      choice: productVariable.options.find(
                        ({ code: code }) =>
                          code === variables[productVariable.code]
                      ).name,
                    });
                  }
                );
              const technologyCodes = _report.getProductTechnology(d[0]),
                techCode = Object.entries(technologyCodes)[0][0],
                technology = Data.product(d[0]).technologies.find(
                  ({ code: code }) => code === techCode
                );
              (output.technology = { name: technology.name, variables: [] }),
                technology.variables.forEach((variable) => {
                  const option = variable.options.find(
                    ({ code: code }) =>
                      code === technologyCodes[techCode][variable.code]
                  );
                  output.technology.variables.push({
                    name: variable.name,
                    choice: option.name,
                  });
                });
            }
            return output;
          })
        );
      let totalWeight = 0;
      Object.entries(configData.products).forEach((d, i) => {
        const output = {};
        (output.keyValues = KeyValues.getProductKeyValues(d[0], _report)),
          (output.normalData = Data.product(d[0])),
          (output.techData = techData[i]),
          _productData.push(output),
          (totalWeight += output.techData.weight);
      }),
        ((_summaryData = await API.getSummaryData(_report)).title =
          configData.title),
        (_this.title = _summaryData.title);
      let d = configData.date;
      "string" == typeof d && (d = new Date(d));
      let locale =
          (navigator.language ? navigator.language : navigator.userLanguage) ||
          "en-GB",
        displayDate = d.toLocaleDateString(locale, {
          year: "numeric",
          month: "short",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit",
          hour12: !0,
        });
      (_summaryData.date = displayDate),
        (_this.date = _summaryData.date),
        (_summaryData.totalWeight = Math.round(totalWeight, 2)),
        (_this.reportID = _this.report ? _this.report.configID : 0),
        (_this.presetIndex = Data.PRESETS.findIndex(
          (el) => el.code === configData.preset
        )),
        (_this.isLoaded = !0);
    }
    function init() {
      ($date = $this.create("Date")),
        (($title = $this.create("Title", "input")).div.type = "text"),
        ($title.div.maxLength = 25),
        ($weight = $this.create("Weight"));
      let wMin = ($weightGraph = $this.create("WeightGraph")).create("Min");
      wMin.text(`${Data.copy("MIN_ABBR_TEXT")}: ${MINWEIGHT}kg`),
        wMin.css({ display: "inline-block", position: "relative" }),
        ($graphCnt = $weightGraph.create("Graph")).css({
          position: "relative",
          display: "inline-block",
          border: `2px solid ${Config.PRESET_COLORS[_this.presetIndex][0][0]}`,
          width: 100,
          height: 14,
          margin: "0px 20px -4px 20px",
          overflow: "hidden",
        }),
        createInnerCanvas($graphCnt);
      let wMax = $weightGraph.create("Min");
      wMax.text(`${Data.copy("MAX_ABBR_TEXT")}: ${MAXWEIGHT}kg`),
        wMax.css({ display: "inline-block", position: "relative" }),
        (_soundSignature = _this.initClass(
          UIReportSound,
          _summaryData,
          _this.presetIndex
        )),
        (_products = _this.initClass(
          UIReportProducts,
          _productData,
          _direction,
          _this.presetIndex
        )),
        $date.text(_summaryData.date),
        ($title.div.value = _summaryData.title),
        $weight.text(
          `${Data.copy("TOTAL_WEIGHT")}: ${_summaryData.totalWeight}kg`
        );
    }
    function style() {
      $this.css({
        position: "relative",
        textTransform: "uppercase",
        letterSpacing: "0.1em",
        textAlign: "center",
        paddingBottom: 150,
      }),
        $weightGraph.css({
          position: "relative",
          color: "#fff",
          fontSize: 14,
          textAlign: "center",
          marginBottom: 30,
        }),
        $date.css({ position: "relative", fontSize: 11, marginBottom: 5 }),
        $title.css({
          position: "relative",
          fontSize: 27,
          letterSpacing: "0.1em",
          marginBottom: 10,
          background: "none",
          border: "none",
          color: "#fff",
          textTransform: "uppercase",
          width: "98%",
          textAlign: "center",
        }),
        $weight.css({
          position: "relative",
          fontSize: 18,
          opacity: "0.5",
          marginBottom: 10,
          marginTop: 30,
        }),
        _listenPrompt &&
          _listenPrompt.element.css({
            position: "relative",
            display: "inline-block",
            marginBottom: 100,
          }),
        $this.hide();
    }
    function addHandlers() {
      $title.div.addEventListener("input", onTitleChange, !1),
        $title.div.addEventListener("keydown", onTitleKeydown, !1);
    }
    function onTitleKeydown(e) {
      13 == e.keyCode && (e.preventDefault(), $title.div.blur());
    }
    function onTitleChange() {
      const index = Reports.list().indexOf(_report),
        value = $title.div.value;
      let start = $title.div.selectionStart,
        end = $title.div.selectionEnd;
      _this.changeTitle(value),
        $title.div.setSelectionRange(start, end),
        Reports.rename(index, value),
        _this.isCompareReport
          ? UIReport.reports.forEach((r) => {
              r && _this.reportID === r.reportID && r.changeTitle(value);
            })
          : (UICompare.reports.left.forEach((r) => {
              r && _this.reportID === r.reportID && r.changeTitle(value);
            }),
            UICompare.reports.right.forEach((r) => {
              r && _this.reportID === r.reportID && r.changeTitle(value);
            }));
    }
    function createInnerCanvas(parent) {
      let canvas = parent.create("Lines", "canvas"),
        range = MAXWEIGHT - MINWEIGHT,
        w = Math.round(((_summaryData.totalWeight - MINWEIGHT) / range) * 100);
      canvas.css({ top: 0, left: 0, width: w, height: 14 }),
        canvas.attr("height", "14px"),
        canvas.attr("width", `${w}px`);
      let ctx = canvas.div.getContext("2d"),
        color = Config.PRESET_COLORS[_this.presetIndex][0][0],
        darkColor = new Color(color);
      darkColor.setRGB(0.5 * darkColor.r, 0.5 * darkColor.g, 0.5 * darkColor.b);
      let numberOfStripes = Math.ceil(w / 2.5);
      for (let i = -5; i < numberOfStripes + 5; i++) {
        ctx.beginPath(),
          (ctx.strokeStyle = i % 2 == 0 ? darkColor.getHexString() : color),
          (ctx.lineWidth = 2.5);
        let p1X = w + 12.5 - 2.5 * i + 1.25,
          p2X = p1X - 20 / Math.tan(0.785398);
        ctx.moveTo(p1X, -2), ctx.lineTo(p2X, 18), ctx.closePath(), ctx.stroke();
      }
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $date,
      $title,
      $weight,
      $weightGraph,
      $graphCnt,
      _soundSignature,
      _products,
      _listenPrompt,
      _report;
    const _productData = [];
    let _summaryData;
    (this.ready = Promise.create()), (this.uid = Utils.timestamp());
    const MINWEIGHT = 10,
      MAXWEIGHT = 40;
    !(async function () {
      await decodeData(),
        _this.show &&
          (_this.ready.resolve(),
          _this.events.fire(UICompare.HIDE_PRELOAD),
          init(),
          style(),
          addHandlers(),
          _this.show());
    })(),
      (this.show = function () {
        _this.isLoaded &&
          (_this.isCompareReport ||
            ((Config.CURRENT_PRESET = _this.presetIndex),
            Colors.instance().setShaderColors(!0)),
          $this.css({ opacity: 1 }).show(),
          [$date, $title, $weight, $weightGraph].forEach((el) => {
            el.css({ opacity: 0 }).transform({ y: 40 }),
              el
                .tween({ opacity: 1, y: 0 }, 800, "easeOutCubic", 0)
                .onComplete(() => {
                  el.clearTransform();
                });
          }),
          _soundSignature.animateIn(25),
          _products.animateIn(300));
      }),
      (this.hide = async function () {
        await $this.tween({ opacity: 0 }, 500, "easeOutCubic").promise(),
          $this.hide();
      }),
      (this.focusTitle = function () {
        $title &&
          ((_this.parent.element.scrollTop = 0),
          $title.div.focus(),
          $title.div.setSelectionRange(0, 100));
      }),
      (this.changeTitle = function (t) {
        $title && ((_this.title = t), ($title.div.value = t));
      }),
      (this.onDestroy = function () {
        _this.ready.resolve();
      }),
      this.get("products", (_) => _products);
  }),
  Class(function UIReportSummaryPreload() {
    function init() {
      $this.css({ position: "absolute", left: "50%" }),
        $this.css({ opacity: 0 });
    }
    function initCanvas() {
      (_canvas = _this.initClass(Canvas, _size, _size)).element.css({
        margin: -0.5 * _size,
      }),
        (_context = _canvas.context),
        $this.add(_canvas.element);
    }
    function loop(t) {
      $this.css({ top: Stage.height / 2 - 100 }),
        _context.clearRect(0, 0, _size, _size),
        (_context.lineWidth = Math.round(0.016 * _size)),
        _context.beginPath(),
        (_context.shadowBlur = 0),
        (_context.strokeStyle = "rgba(255, 255, 255, 0.1)"),
        _context.arc(
          0.5 * _size,
          0.5 * _size,
          0.35 * _size,
          0,
          Math.radians(360),
          !1
        ),
        _context.stroke(),
        _context.closePath();
      let start = Math.radians(-90) + 0.0015 * t;
      const alpha = (5e-4 * t) % 2,
        t1 = Math.min(1, alpha) * Math.PI * 2,
        t2 = Math.max(0, alpha - 1) * Math.PI * 2;
      _context.beginPath(),
        (_context.strokeStyle = _presetColor),
        (_context.shadowBlur = 10),
        (_context.shadowColor = "rgba(230, 235, 61, 0.5)"),
        _context.arc(
          0.5 * _size,
          0.5 * _size,
          0.35 * _size,
          start + t2,
          start + t1
        ),
        _context.stroke(),
        _context.closePath();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let _canvas,
      _context,
      _size = 120;
    var _presetColor = "#ffffff";
    init(),
      initCanvas(),
      $this.tween({ opacity: 1 }, 1e3, "easeOutCubic"),
      _this.startRender(loop),
      (this.hide = async function () {
        await $this.tween({ opacity: 0 }, 250, "easeOutCubic").promise(),
          _this.stopRender(loop),
          _this.destroy();
      });
  }),
  Class(function UIReportKeyValues(_data, _presetIndex) {
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let _graph;
    const _titles = [];
    !(function () {
      $this.size(370, 250).center().css({}),
        $this.transform({ scale: 300 / 370 });
      let clearColor = Config.PRESET_COLORS[_presetIndex][0][0];
      _graph = _this.initClass(SpiderGraph, _data, [
        "rgba(255, 255, 255, 0.1)",
        clearColor,
        Colors.instance().calculateDark(clearColor),
        "#fff",
      ]);
      const num = _data.length;
      _data.forEach((d, i) => {
        const title = $this.create("Title");
        title.html(`${d.name.replace(" ", "<br />")}`);
        const angle = i * ((2 * Math.PI) / num);
        let x = 80 * Math.sin(angle) + 185,
          y = 80 * Math.cos(angle) + 125;
        title.css({
          left: x,
          top: y,
          textTransform: "uppercase",
          fontSize: 11,
          letterSpacing: "0.1em",
          fontWeight: "bold",
          color: "#fff",
          opacity: 0.7,
        }),
          (x = Math.sin(angle)),
          Math.abs(x) < 0.001 && (x = 0),
          (y = Math.cos(angle)),
          Math.abs(y) < 0.001 && (y = 0),
          title.css({
            textAlign: x ? (x < 0 ? "right" : "left") : "center",
            transform: `translate(${x ? (x < 0 ? "-100" : "0") : "-50"}%, ${
              y ? (y < 0 ? "-100" : "0") : "-50"
            }%)`,
          }),
          _titles.push(title);
      });
    })(),
      (this.animateIn = function () {
        $this.show(), $this.tween({ opacity: 1 }, 2e3, "easeOutCubic");
      }),
      (this.animateOut = async function () {
        await $this.tween({ opacity: 0 }, 1e3, "easeOutCubic").promise(),
          $this.hide();
      });
  }),
  Class(function UIReportProductGraph(_type, _data, _presetIndex) {
    function init() {
      (_graph = _this.initClass(
        Graph,
        300,
        120,
        { xAxis: "100 315 1000 3150 10000", label: Data.copy("FREQUENCY") },
        ["#fff"],
        -2
      )),
        defer(() => {
          _this.updateData(_data);
        });
    }
    function style() {
      $this.css({ width: 300, height: 220 }),
        _graph.element.css({ marginTop: 20 }),
        $this.css({ opacity: 0 }).hide();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let _graph;
    init(),
      style(),
      (this.animateIn = function () {
        $this.show(), $this.tween({ opacity: 1 }, 2e3, "easeOutCubic");
      }),
      (this.animateOut = async function () {
        await $this.tween({ opacity: 0 }, 1e3, "easeOutCubic").promise(),
          $this.hide();
      }),
      (this.updateData = function (data) {
        let curve = {
          label: _type,
          color: Config.PRESET_COLORS[_presetIndex][0][0],
          points: null,
          min: null,
          max: null,
        };
        if (((curve.points = data), "abs" === _type))
          (curve.max = 1), (curve.min = 0);
        else {
          let max = 0,
            min = 999;
          curve.points.forEach((value) => {
            (max = Math.max(max, value)), (min = Math.min(min, value));
          }),
            (curve.max = 5 * Math.ceil(max / 5)),
            (curve.min = 5 * Math.floor(min / 5));
        }
        _graph.setData(curve);
      });
  }),
  Class(function UIReportProductSummary(_data, _presetIndex, _listIndex) {
    function init() {
      ($infoContainer = $this.create("InfoContainer")),
        ($detailsContainer = $this.create("DetailsContainer")),
        ($detailsInner = $detailsContainer.create("DetailsInner")),
        ($title = $infoContainer.create("Title")),
        ($description = $detailsInner.create("Description")),
        ($arrow = $infoContainer.create("Arrow")),
        ($graphBlock = $detailsInner.create("GraphBlock")),
        ($tabsContainer = $graphBlock.create("TabsContainer")),
        ($graphsContainer = $graphBlock.create("GraphsContainer")),
        ($list = $detailsInner.create("List"));
      const keyValuesTab = $tabsContainer.create("KeyValuesTab");
      keyValuesTab.text(Data.copy("KEY_VALUES"));
      const keyValues = _this.initClass(
        UIReportKeyValues,
        _data.keyValues,
        _presetIndex,
        [$graphsContainer]
      );
      if (
        (_graphTabs.push(keyValuesTab),
        _graphs.push(keyValues),
        _data.techData.abs)
      ) {
        const transmissionTab = $tabsContainer.create("TransmissionTab");
        transmissionTab.text(Data.copy("TRANSMISSION_LOSS"));
        const transmission = _this.initClass(
            UIReportProductGraph,
            "tl",
            _data.techData.tl,
            _presetIndex,
            [$graphsContainer]
          ),
          absorptionTab = $tabsContainer.create("AbsorptionTab");
        absorptionTab.text(Data.copy("ABSORPTION"));
        const absorption = _this.initClass(
          UIReportProductGraph,
          "abs",
          _data.techData.abs,
          _presetIndex,
          [$graphsContainer]
        );
        _graphTabs.push(transmissionTab),
          _graphTabs.push(absorptionTab),
          _graphs.push(transmission),
          _graphs.push(absorption);
      }
      _this.initClass(UIReportProductTechList, _data, _presetIndex, [$list]),
        $title.text(_data.normalData.name),
        $description.text(_data.normalData.description);
    }
    function style() {
      $this.css({
        position: "relative",
        border: "1px solid rgba(255, 255, 255, 0.4)",
        opacity: 0.7,
        borderRadius: 5,
        marginBottom: 10,
        willChange: "opacity",
      }),
        ($this._willChangeLock = !0),
        $infoContainer.css({
          position: "relative",
          textAlign: "left",
          padding: 20,
        }),
        $title.css({ position: "relative", fontSize: 14 }),
        $description.css({
          textTransform: "initial",
          position: "relative",
          fontFamily: "montserrat",
          marginBottom: 15,
          padding: "0 20px",
          fontSize: 11,
          opacity: 0.6,
          lineHeight: "1.65em",
          letterSpacing: "0.02em",
        }),
        $arrow.bg("assets/images/ui/arrow.svg", "contain"),
        $arrow.css({
          backgroundSize: "contain",
          backgroundPosition: "center center",
          padding: 5,
          margin: -5,
          top: 27,
          right: 30,
          backgroundRepeat: "no-repeat",
        }),
        $detailsContainer.css({
          position: "relative",
          textAlign: "left",
          overflow: "hidden",
          height: 0,
        }),
        $detailsInner.css({ position: "relative" }).hide(),
        $graphBlock.css({
          width: 300,
          height: 250,
          position: "relative",
          display: "inline-block",
          float: "left",
          overflow: "hidden",
        }),
        $tabsContainer.css({
          position: "relative",
          textAlign: "left",
          paddingLeft: 20,
        }),
        _graphTabs.forEach((tab, i) => {
          tab.css({
            position: "relative",
            display: "inline-block",
            fontSize: 9,
            fontWeight: "bold",
            letterSpacing: "0.1em",
            lineHeight: 30,
            paddingRight: 15,
            opacity: i ? 0.5 : 0.8,
          });
        }),
        $graphsContainer.css({
          position: "relative",
          height: 210,
          overflow: "hidden",
        }),
        $list.css({
          width: Tests.smallTablet() ? 160 : 180,
          height: 250,
          position: "relative",
          display: "inline-block",
          overflow: "hidden",
        });
    }
    function addHandlers() {
      Device.mobile
        ? $infoContainer.click(toggleClick)
        : $infoContainer.interact(toggleHover, toggleClick),
        _graphTabs.length < 2 ||
          _graphTabs.forEach((tab, i) => {
            tab.interact(
              function hover(e) {},
              function click() {
                i !== _currentTab &&
                  (_graphTabs[_currentTab].css({ opacity: 0.5 }),
                  _graphs[_currentTab].animateOut(),
                  _graphTabs[(_currentTab = i)].css({ opacity: 0.8 }),
                  _graphs[_currentTab].animateIn());
              }
            );
          });
    }
    function toggleHover(e) {
      if (_this.isCollapsed && $this._enableHover)
        switch (e.action) {
          case "over":
            $this.tween({ opacity: 1 }, 300, "easeOutSine");
            break;
          case "out":
            $this.tween({ opacity: 0.7 }, 400, "easeOutSine");
        }
    }
    async function toggleClick() {
      let ease = "easeInOutQuart",
        currentScroll = {
          value: UICompare.instance().isOpen
            ? UICompare.instance().scrollPos()
            : UIReport.instance().scrollPos(),
        },
        scrollTo = $this.div.offsetTop + 0.2 * Stage.height + 470;
      (scrollTo -= 0.5 * Stage.height),
        _scrollAnimation && _scrollAnimation.stop(),
        _this.isCollapsed
          ? ($detailsInner.show(),
            await defer(),
            await defer(),
            (scrollTo += 0.5 * ($detailsInner.div.clientHeight + 55)),
            $detailsContainer
              .tween({ height: $detailsInner.div.clientHeight }, 800, ease)
              .onComplete(() => {
                $detailsContainer.css({ height: "auto" });
              }),
            $this.css({
              border: "1px solid " + Config.PRESET_COLORS[_presetIndex][0][0],
            }),
            $this.tween({ opacity: 1 }, 300, "easeOutSine"),
            $arrow.tween({ rotation: 180 }, 800, ease))
          : ((scrollTo -= 0.2 * Stage.height),
            $detailsContainer.css({ height: $detailsInner.div.clientHeight }),
            $detailsContainer.tween({ height: 0 }, 800, ease).onComplete(() => {
              $detailsInner.hide();
            }),
            $this.css({ border: "1px solid rgba(255, 255, 255, 0.4)" }),
            $this.tween({ opacity: 0.7 }, 300, "easeOutSine", 800),
            $arrow.tween({ rotation: 0 }, 800, ease)),
        (_scrollAnimation = tween(
          currentScroll,
          { value: scrollTo },
          800,
          "easeInOutQuart"
        ).onUpdate(() => {
          UICompare.instance().isOpen
            ? UICompare.instance().scrollTo(currentScroll.value)
            : UIReport.instance().scrollTo(currentScroll.value);
        })),
        (_this.isCollapsed = !_this.isCollapsed),
        _this.events.fire(UICompare.TOGGLE_SUMMARY, {
          index: _listIndex,
          state: _this.isCollapsed,
        });
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $infoContainer,
      $title,
      $description,
      $arrow,
      $detailsContainer,
      $detailsInner,
      $graphBlock,
      $tabsContainer,
      $graphsContainer,
      $list;
    const _graphTabs = [],
      _graphs = [];
    let _currentTab = 0;
    var _scrollAnimation;
    (this.isCollapsed = !0),
      init(),
      style(),
      addHandlers(),
      (this.toggleClick = toggleClick);
  }),
  Class(function UIReportProductTechList(_data, _presetIndex) {
    function initComplex() {
      const $variablesTitle = $this.create("Title");
      _data.techData.variables.forEach(addVariable);
      const $technologyTitle = $this.create("Title"),
        $technology = $this.create("Technology");
      _data.techData.technology.variables.forEach(addVariable),
        $variablesTitle.text(Data.copy("VARIABLES")),
        $technologyTitle.text(Data.copy("TECHNOLOGY")),
        $technology.text(_data.techData.technology.name),
        [$variablesTitle, $technologyTitle].forEach((el) => {
          el.css({ position: "relative" });
        }),
        $technologyTitle.css({ marginTop: 20 }),
        $technology.css({ position: "relative" });
    }
    function addVariable(d) {
      const $name = $this.create("Name"),
        $choice = $this.create("Choice");
      $name.text(d.name + ":"),
        $choice.text(d.choice),
        $name.css({
          position: "relative",
          display: "inline-block",
          paddingRight: 5,
        }),
        $choice.css({
          position: "relative",
          display: "inline-block",
          color: Config.PRESET_COLORS[_presetIndex][0][0],
        });
    }
    function initSimple() {
      const $title = $this.create("Title"),
        $tech = $this.create("Technology");
      $title.text(Data.copy("TECHNOLOGY")),
        $tech.text(_data.techData.name),
        $title.css({ position: "relative" }),
        $tech.css({ position: "relative" });
    }
    Inherit(this, Element);
    const $this = this.element;
    _data.techData.technology ? initComplex() : initSimple(),
      $this.css({
        position: "relative",
        textAlign: "left",
        fontSize: 9,
        paddingTop: 7,
        paddingRight: 20,
        paddingBottom: 20,
        lineHeight: "1.8em",
      });
  }),
  Class(function UIReportProducts(_data, _direction, _presetIndex) {
    function init() {
      ($title = $this.create("Title")).text(Data.copy("PRODUCTS_TECH")),
        _data.forEach(addProduct);
    }
    function addProduct(d, i) {
      const product = _this.initClass(
        UIReportProductSummary,
        d,
        _presetIndex,
        i
      );
      _products.push(product);
    }
    function style() {
      $this.css({ position: "relative", marginTop: 50, marginBottom: 50 }),
        $title.css({ position: "relative", fontSize: 13, marginBottom: 20 });
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $title;
    const _products = [];
    init(),
      style(),
      (this.animateIn = function (initialDelay) {
        $title.css({ opacity: 0 }).transform({ y: -10 }),
          $title
            .tween({ opacity: 1, y: 0 }, 800, "easeOutCubic", initialDelay + 50)
            .onComplete(() => {
              $title.clearTransform();
            }),
          _products.forEach((el, i) => {
            let delay = initialDelay + 175 + 1e3 * Math.pow(0.1 * i, 1.5);
            el.element
              .css({ opacity: 0 })
              .transform({ x: (i % 2 == 0 ? 30 : -30) * _direction }),
              (el.element._enableHover = !1),
              el.element
                .tween({ opacity: 0.7, x: 0 }, 800, "easeOutCubic", delay)
                .onComplete(() => {
                  (el.element._enableHover = !0), el.element.clearTransform();
                });
          });
      }),
      this.get("products", (_) => _products);
  }),
  Class(function UIReportSound(_data, _presetIndex) {
    function init() {
      (_toggle = _this.initClass(UIReportSoundToggle)),
        (_graph = _this.initClass(UIReportSoundGraph, _data, _presetIndex)),
        ($labelCnt = $this.create("LabelCnt")),
        $this.create("newline", "br").css({ position: "relative" }),
        ($label = $labelCnt.create("label")).text(Data.copy("FREQUENCY")),
        ($label1 = $labelCnt.create("Label1")),
        ($label2 = $labelCnt.create("Label2")),
        $label1.text(Data.copy("DRIVER_EARS")),
        ($label1.icon = $label1.create("Icon")),
        $label2.text(Data.copy("REAR_PASSENGER_EARS")),
        ($label2.icon = $label2.create("Icon"));
    }
    function style() {
      $this.css({ position: "relative" }),
        $labelCnt.css({ position: "relative", textAlign: "center" }),
        $label
          .fontStyle("din", 10, "#fff")
          .css({
            position: "relative",
            display: "block",
            width: "100%",
            marginBottom: 10,
          }),
        [$label1, $label2].forEach((el) => {
          el.css({
            position: "relative",
            fontSize: 9,
            display: "inline-block",
            padding: "0px 20px",
          }),
            el.icon.css({
              width: 10,
              height: 1,
              background: "#fff",
              left: 0,
              top: "50%",
            });
        }),
        $label2.css({ color: Config.PRESET_COLORS[_presetIndex][0][0] }),
        $label2.icon.css({
          background: Config.PRESET_COLORS[_presetIndex][0][0],
        });
    }
    function addHandlers() {
      _toggle.onChange = function (value) {
        _graph.toggle(value);
      };
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $labelCnt, $label, $label1, $label2, _toggle, _graph;
    init(),
      style(),
      addHandlers(),
      (this.animateIn = function (initialDelay) {
        [[_toggle.element, _graph.element], [$labelCnt]].forEach((els, i) => {
          let delay = initialDelay + 1e3 * Math.pow(0.12 * (i + 1), 1.5);
          els.forEach((el) => {
            el.css({ opacity: 0 }).transform({ y: 40 }),
              el
                .tween({ opacity: 1, y: 0 }, 800, "easeOutCubic", delay)
                .onComplete(() => {
                  el.clearTransform();
                });
          });
        });
      });
  }),
  Class(function UIReportSoundGraph(_data, _presetIndex) {
    function init() {
      calculateLimits();
      const engineGraph = _this.initClass(
          SoundGraph,
          [
            _data.engine.Front_Upper_Cavity_DS,
            _data.engine.Rear_Upper_Cavity_PS,
          ],
          10,
          50,
          _presetIndex
        ),
        tireGraph = _this.initClass(
          SoundGraph,
          [_data.tires.Rear_Upper_Cavity_PS, _data.tires.Front_Upper_Cavity_DS],
          18,
          50,
          _presetIndex
        );
      _graphs.push(engineGraph),
        _graphs.push(tireGraph),
        tireGraph.element.hide();
    }
    function style() {
      $this.css({
        position: "relative",
        width: Tests.smallTablet() ? 470 : 500,
        height: 280,
        overflow: "auto",
      });
    }
    function calculateLimits() {}
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    const _graphs = [];
    init(),
      style(),
      (this.animateIn = function () {
        $this.show(), $this.tween({ opacity: 1 }, 2e3, "easeOutCubic");
      }),
      (this.animateOut = async function () {
        await $this.tween({ opacity: 0 }, 1e3, "easeOutCubic").promise(),
          $this.hide();
      }),
      (this.toggle = function (value) {
        _graphs[value].element.show(), _graphs[Number(!value)].element.hide();
      });
  }),
  Class(function UIReportSoundToggle() {
    function init() {
      ($lower = $this.create("LowerLabel")),
        ($labelLeft = $this.create("LabelLeft")),
        (($toggle = $this.create("Toggle")).thumb = $toggle.create("Thumb")),
        ($labelRight = $this.create("LabelRight")),
        $lower.text(Data.copy("LOWER_BETTER_TEXT")),
        $labelLeft.text(Data.copy("SIGNATURE_ENGINE")),
        $labelRight.text(Data.copy("SIGNATURE_TIRE"));
    }
    function style() {
      $this.css({
        position: "relative",
        padding: "0 40px",
        textAlign: "right",
      }),
        $lower
          .fontStyle("din", 11)
          .css({
            textAlign: "left",
            textTransform: "initial",
            top: 6,
            left: 50,
            background:
              "url(assets/images/ui/info.svg) left center / contain no-repeat",
            paddingLeft: 20,
            opacity: 0.8,
            letterSpacing: "1px",
          }),
        $toggle.css({
          background: "#333333",
          position: "relative",
          display: "inline-block",
          width: 28,
          height: 16,
          borderRadius: 100,
          top: 4,
        }),
        $toggle.thumb.css({
          padding: 6,
          margin: -6,
          left: "50%",
          top: "50%",
          background: "#ffffff",
          borderRadius: 100,
        }),
        [$labelLeft, $labelRight].forEach((el) => {
          el.css({
            position: "relative",
            fontSize: 9,
            display: "inline-block",
            padding: "5px 10px",
          });
        });
    }
    function setValue(value, isSilent = !1) {
      (_this.value = value),
        $labelLeft.css({ opacity: _this.value ? 0.5 : 1 }),
        $labelRight.css({ opacity: _this.value ? 1 : 0.5 }),
        $toggle.thumb.css({
          transform: `translateX(${_this.value ? "" : "-"}50%)`,
        }),
        isSilent || (_this.onChange && _this.onChange(_this.value));
    }
    function addHandlers() {
      $labelLeft.interact(hoverLabel, () => setValue(0)),
        $labelRight.interact(hoverLabel, () => setValue(1)),
        $toggle.interact(hoverToggle, clickToggle);
    }
    function hoverLabel() {}
    function hoverToggle() {}
    function clickToggle() {
      Track.event("report", "click", "engine-tire-toggle"),
        setValue(Number(!_this.value));
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $lower, $labelLeft, $labelRight, $toggle;
    (this.value = 0), init(), style(), addHandlers(), setValue(_this.value, !0);
  }),
  Class(
    function UISection() {
      function initData() {
        (_titleData = [
          {
            perma: "body",
            text: Data.copy("SECTION_BODY"),
            icon: "bodystyles/sedan",
            active: 1,
            disabled: 0,
          },
          {
            perma: "engine",
            text: Data.copy("SECTION_ENGINE"),
            icon: "engines/ice",
            active: 0,
            disabled: 0,
          },
          {
            perma: "presets",
            text: Data.copy("SECTION_PRESETS"),
            icon: "presets/baseline",
            active: 0,
            disabled: 1,
          },
          {
            perma: "customise",
            text: Data.copy("SECTION_CUSTOMISE"),
            icon: "customise/sliders",
            active: 0,
            disabled: 1,
          },
          {
            perma: "report",
            text: Data.copy("SECTION_REPORT"),
            icon: "report/done",
            active: 0,
            disabled: 1,
          },
        ]),
          (_sectionData = [
            {
              sub: Data.copy("SECTION_STEP_1"),
              title: Data.copy("SECTION_STEP_1_TEXT"),
              text: Data.copy("SECTION_BODY_TEXT"),
              dataKey: "BODY_STYLES",
              configureProperty: "bodyStyle",
              track: "body-style",
            },
            {
              sub: Data.copy("SECTION_STEP_2"),
              title: Data.copy("SECTION_STEP_2_TEXT"),
              text: Data.copy("SECTION_ENGINE_TEXT"),
              dataKey: "POWERTRAINS",
              configureProperty: "powertrain",
              track: "engine",
            },
            {
              sub: Data.copy("SECTION_STEP_3"),
              title: Data.copy("SECTION_STEP_3_TEXT"),
              text: Data.copy("SECTION_PRESETS_TEXT"),
              dataKey: "PRESETS",
              configureProperty: "preset",
              track: "presets",
            },
            {
              sub: Data.copy("SECTION_STEP_4"),
              title: Data.copy("SECTION_STEP_4_TEXT"),
              text: Data.copy("SECTION_CUSTOMISE_TEXT"),
              dataKey: "PRODUCTS",
              track: "customise",
            },
            {
              title: Data.copy("SECTION_STEP_5"),
              links: [
                { action: "compare", text: Data.copy("REPORT_COMPARE") },
                { action: "share", text: Data.copy("REPORT_SHARE") },
                { action: "email", text: Data.copy("REPORT_EMAIL") },
                { action: "rename", text: Data.copy("REPORT_RENAME") },
                { action: "delete", text: Data.copy("REPORT_DELETE") },
                { action: "deleteAll", text: Data.copy("REPORT_DELETE_ALL") },
              ],
              track: "play",
            },
          ]);
      }
      function initTitles() {
        _titleData.forEach((data, i) => {
          const title = _this.initClass(UISectionTitle, data.text, data.icon);
          data.active && title.activate(),
            data.disabled && title.disable(),
            (title.onClick = () => {
              i !== _sectionIndex &&
                (_this.isChangingSection ||
                  (4 === i && _this.events.fire(UISection.OPEN_REPORT),
                  4 === _sectionIndex &&
                    _this.events.fire(UISection.CLOSE_REPORT),
                  _this.events.fire(UISection.SECTION_CHANGE, {
                    index: i,
                    data: data,
                  })));
            }),
            _titles.push(title);
        });
      }
      function initSection(index) {
        (_text = null),
          _sectionData[(_sectionIndex = index)].text && initText(),
          Track.page("/" + _sectionData[_sectionIndex].track),
          initChoices(),
          "customise" === _titleData[_sectionIndex].perma &&
            initCustomiseViews(),
          layout();
      }
      function initText() {
        (_this.data = _sectionData[_sectionIndex]),
          _this.activeIndex > 1 &&
            (_this.data.color = Colors.instance().UI.main),
          (_text = _this.initClass(UISectionText, _this.data));
      }
      function initChoices() {
        if (((_choices = []), "report" === _titleData[_sectionIndex].perma))
          return (
            _sectionData[_sectionIndex].links.forEach((data) => {
              const enabled = !(
                  "compare" === data.action && UIReport.reports.length < 1
                ),
                choice = _this.initClass(
                  UISectionChoice,
                  data.text,
                  !1,
                  null,
                  "compare" === data.action
                );
              (choice.data = { perma: data.action }),
                (choice.enabled = enabled),
                _choices.push(choice),
                (choice.onClick = () => {
                  Track.event("report", "click", data.action),
                    _this.events.fire(UIReport.LINK, { action: data.action });
                });
            }),
            void defer(updateTitles)
          );
        let selectedValue =
          Configuration[_sectionData[_sectionIndex].configureProperty];
        (_choiceIndex = 0),
          Meta[_sectionData[_sectionIndex].dataKey].forEach((data, i) => {
            selectedValue && selectedValue === data.code
              ? (_choiceIndex = i)
              : !selectedValue &&
                data.presets &&
                data.presets.includes(Configuration.preset) &&
                (_choiceIndex = i);
          }),
          Meta[_sectionData[_sectionIndex].dataKey].forEach((data, i) => {
            let activeColor;
            "customise" === _titleData[_sectionIndex].perma &&
              (activeColor =
                Config.PRESET_COLORS[Config.CURRENT_PRESET][
                  Config.PRODUCT_DATA[data.perma].colorIndex || 0
                ][0]);
            const enabled = !(!1 === data.enabled),
              choice = _this.initClass(
                UISectionChoice,
                data.name,
                enabled,
                activeColor
              );
            (choice.data = data),
              (choice.enabled = enabled),
              enabled &&
                _choiceIndex === i &&
                Track.event(
                  _sectionData[_sectionIndex].track,
                  "default",
                  data.perma
                ),
              (choice.onClick = () => {
                i !== _choiceIndex &&
                  (_this.isChangingChoice ||
                    ("body" === Car.instance()._currentSectionPerma &&
                      Car.instance().changingBody) ||
                    (activeColor &&
                      (Colors.instance().setUIColor(activeColor),
                      Colors.instance().setShaderColor1(activeColor)),
                    Track.event(
                      _sectionData[_sectionIndex].track,
                      "select",
                      data.perma
                    ),
                    _sectionData[_sectionIndex].configureProperty &&
                      (Configuration[
                        _sectionData[_sectionIndex].configureProperty
                      ] = data.code),
                    _this.events.fire(UISection.CHOICE_CHANGE, {
                      index: i,
                      data: data,
                      total: _choices.length,
                      initial: !1,
                    })));
              }),
              _choices.push(choice);
          }),
          defer(() => {
            _this.events.fire(UISection.CHOICE_CHANGE, {
              index: _choiceIndex,
              data: _choices[_choiceIndex].data,
              total: _choices.length,
              initial: !0,
            });
          });
      }
      function initCustomiseViews() {
        (_customiseButton = _this.initClass(
          UIButton,
          Data.copy("SECTION_CUSTOMISE_PROMPT")
        )).onClick = () => {
          _this.isCustomise ||
            ((_this.isCustomise = !0),
            _this.events.fire(UISection.OPEN_CUSTOMISE, {
              productCode: _choices[_choiceIndex].data.code,
              perma: _choices[_choiceIndex].data.perma,
              data: _choices[_choiceIndex].data,
            }));
        };
        const text = Meta.getPresetName(Configuration.preset);
        (_resetPreset = _this.initClass(UISectionResetPrompt, text)).onClick =
          () => {
            (Configuration.preset = Configuration.preset),
              UI.instance().element.add(
                _this.initClass(UIConfirmationPopup, "preset", text)
              );
          };
      }
      function layout() {
        const size = Config.RADIUS.value;
        if (
          (_titles.forEach((node, i) => {
            const step = 70 / size,
              angle = (i - 0.5 * (_titles.length - 1)) * step,
              x = -size * Math.cos(angle),
              y = size * Math.sin(angle);
            node.element.transform({ x: x, y: y }), node.layout(x, -y);
          }),
          positionChoicesIn(),
          positionChoicesOut(),
          _customiseButton &&
            _customiseButton.element.css({
              left: "50%",
              top: "82%",
              transform: "translate3d(-50%, 0, 0)",
            }),
          _resetPreset)
        ) {
          const step = 35 / size,
            angle = (0 - 0.5 * (_choices.length - 1)) * step,
            x = size * Math.cos(angle) + 10,
            y = size * Math.sin(angle) - 60;
          _resetPreset.element.transform({ x: x, y: y });
        }
      }
      function positionChoicesOut() {
        let count = 0,
          max = 0;
        _oldChoices.forEach((node, i, a) => {
          node.enabled && max++;
        }),
          _oldChoices.forEach((node, i, a) => {
            if (!node.element) return;
            let step = 35 / Config.RADIUS.value,
              angle =
                (count -
                  0.5 * (max - 1) -
                  8 * _animObj.animateOut * _this.direction) *
                step;
            node.enabled && count++,
              (node.element.x = Config.RADIUS.value * Math.cos(angle)),
              (node.element.y = Config.RADIUS.value * Math.sin(angle)),
              node.element.transform(),
              node.layout(node.element.x, -node.element.y);
          });
      }
      function positionChoicesIn() {
        let count = 0,
          max = 0;
        _choices.forEach((node, i, a) => {
          node.enabled && max++;
        }),
          _choices.forEach((node, i, a) => {
            if (!node.element) return;
            let step = 35 / Config.RADIUS.value,
              angle =
                (count -
                  0.5 * (max - 1) +
                  8 * (1 - _animObj.animateIn) * _this.direction) *
                step;
            node.enabled && count++,
              (node.element.x = Config.RADIUS.value * Math.cos(angle)),
              (node.element.y = Config.RADIUS.value * Math.sin(angle)),
              node.element.transform(),
              node.layout(node.element.x, -node.element.y);
          });
      }
      function addHandlers() {
        _this.events.sub(UISection.SECTION_CHANGE, changeSection),
          _this.events.sub(UISection.APPLICATION_RESET, applicationReset),
          _this.events.sub(UISection.CHOICE_CHANGE, changeChoice),
          _this.events.sub(Config.RADIUS_UPDATE, updateRadius),
          _this.events.sub(Container.LOADED, checkDeeplink),
          _this.events.sub(Car.PRODUCT_CLICK, productClicked);
      }
      function productClicked({ perma: perma }) {
        const selection = _choices.find(
          (choice) => choice.data.perma === perma
        );
        selection && selection.onClick();
      }
      function checkDeeplink({ deeplink: deeplink }) {
        if (deeplink)
          switch (deeplink) {
            case "report":
              (_sectionIndex = 4),
                (_this.activeIndex = 4),
                _titleData.forEach((d, i) => {
                  (d.active = d.perma === deeplink ? 1 : 0),
                    (d.disabled = i <= _sectionIndex + 1 ? 0 : 1);
                });
          }
      }
      function updateRadius() {
        layout();
      }
      function hideIntro() {
        (UI.instance().introTextHidden = !0),
          _this.events.fire(UIIntroText.ANIMATE_OUT, { fast: !0 });
      }
      async function changeSection({ index: index, data: data }) {
        if (((_perma = data.perma), hideIntro(), !_this.isChangingSection)) {
          if (
            ((_this.isChangingSection = !0),
            index < 2
              ? Colors.instance().reset()
              : Colors.instance().setShaderColors(!0),
            (_this.direction = _this.activeIndex > index ? -1 : 1),
            (_this.activeIndex = index),
            _oldText && _oldText.destroy && (_oldText = _oldText.destroy()),
            (_oldText = _text) && _oldText.animateOut && _oldText.animateOut(),
            (_oldChoices = []),
            _choices.forEach((node, i) => {
              _oldChoices.push(node),
                node.animateOut(() => {
                  node.destroy();
                }, 50 * i);
            }),
            _customiseButton)
          ) {
            const button = _customiseButton;
            (_customiseButton = null),
              button.animateOut(() => {
                button.destroy();
              });
          }
          if (_resetPreset) {
            const reset = _resetPreset;
            (_resetPreset = null),
              reset.animateOut(() => {
                reset.destroy();
              });
          }
          (Config.RADIUS.state =
            "engine" === data.perma
              ? "engine"
              : "report" === data.perma
              ? "report"
              : "main"),
            (_animObj.animateOut = 0),
            positionChoicesOut(),
            tween(_animObj, { animateOut: 1 }, 1e3, "easeInOutCubic").onUpdate(
              positionChoicesOut
            ),
            initSection(index),
            _text && _text.animateIn(700),
            (_animObj.animateIn = 0),
            positionChoicesIn(),
            tween(_animObj, { animateIn: 1 }, 1500, "easeInOutCubic").onUpdate(
              positionChoicesIn
            ),
            _choices.forEach((node, i) => {
              node.enabled &&
                (i === _choiceIndex &&
                  "report" !== _titleData[_sectionIndex].perma &&
                  node.activate(),
                node.animateIn(150 * i + 300));
            }),
            _customiseButton && _customiseButton.animateIn(),
            _resetPreset && _resetPreset.animateIn(),
            await _this.wait(BLOCK_NAV_TIME),
            (_this.isChangingSection = !1);
        }
      }
      function updateTitles(comingSoon = !1) {
        for (let i = 0; i < _titles.length; i++) {
          const title = _titles[i];
          i <=
            (_maxSectionIndex = Math.max(
              _maxSectionIndex,
              _sectionIndex + 1
            )) &&
            (title.state.disabled && title.enable(),
            title.state.active && title.deactivate()),
            i === _sectionIndex &&
              (title.state.disabled && title.enable(),
              title.state.active || title.activate()),
            comingSoon &&
              i !== _sectionIndex &&
              (title.state.disabled || title.disable(),
              title.state.active && title.deactivate());
        }
      }
      function applicationReset() {
        _titles[0].onClick();
      }
      async function changeChoice({
        index: index,
        data: data,
        initial: initial,
      }) {
        if (_this.isChangingChoice) return;
        if (
          ((_this.isChangingChoice = !0),
          (_this.isChangingSection = !0),
          _choiceTimeout && clearTimeout(_choiceTimeout),
          (_choiceTimeout = setTimeout(() => {
            _this.isChangingSection = !1;
          }, BLOCK_NAV_TIME)),
          initial || _choices[_choiceIndex].deactivate(),
          (_choiceIndex = index),
          initial || _choices[_choiceIndex].activate(initial),
          "presets" === _perma &&
            ((UISection.PRESET = data.perma),
            initial || _titles[2].changeIcon(`presets/${data.perma}`)),
          _customiseButton && _customiseButton.bounce(),
          "suv" === data.perma || "sedan" === data.perma || "hev" === data.perma
            ? (updateTitles(!0),
              Colors.instance().disable(),
              (_soon = _this.initClass(UISectionSoon, data.perma)))
            : (updateTitles(),
              _this.activeIndex < 2 && Colors.instance().reset(),
              _soon && (_soon.animateOut(), (_soon = null))),
          initial || !data.description)
        )
          return void (_this.isChangingChoice = !1);
        hideIntro(),
          _text.animateOut && _text.animateOut(),
          await _this.wait(400);
        let textData = {};
        (textData.title = data.name),
          (textData.text = data.text),
          (textData.description = data.description),
          (textData.sub = data.sub),
          _this.activeIndex > 1 && (textData.color = Colors.instance().UI.main),
          (_text = _this.initClass(UISectionText, textData)).animateIn(),
          (_this.isChangingChoice = !1);
      }
      Inherit(this, Element);
      const _this = this,
        $this = this.element;
      let _oldText,
        _text,
        _customiseButton,
        _resetPreset,
        _perma,
        _soon,
        _titleData,
        _sectionData,
        _titles = [],
        _choices = [],
        _oldChoices = [],
        _sectionIndex = 0,
        _choiceIndex = 0,
        _maxSectionIndex = 1;
      var _choiceTimeout;
      const BLOCK_NAV_TIME = 2e3;
      (_this.activeIndex = -1), (_this.direction = 1);
      let _animObj = { animateIn: 0, animateOut: 0, multiTween: !0 };
      !(async function () {
        addHandlers(),
          $this.size("100%").css({ pointerEvents: "none" }).setZ(10),
          await Data.ready(),
          initData(),
          await Viewport.instance().ready,
          await Car.instance().ready,
          initTitles(),
          initSection(_sectionIndex),
          Colors.instance().reset();
      })(),
        (this.animateIn = function () {
          _titles.forEach((node, i) => {
            node.animateIn(100 * i + 250);
          }),
            _choices.forEach((node, i) => {
              node.enabled &&
                (i === _choiceIndex &&
                  "report" !== _titleData[_sectionIndex].perma &&
                  node.activate(),
                node.animateIn(50 * i + 550));
            }),
            (_animObj.animateIn = 0),
            tween(
              _animObj,
              { animateIn: 1 },
              1500,
              "easeOutCubic",
              700
            ).onUpdate(positionChoicesIn);
        }),
        (this.animeteTextIn = function () {
          _text && _text.animateIn && _text.animateIn();
        }),
        (this.changeColor = function (color1) {
          _customiseButton && _customiseButton.changeColor(color1),
            _titles.forEach((node, i) => {
              node.changeColor(color1);
            }),
            _choices.forEach((node, i) => {
              node.changeColor(color1);
            });
        });
    },
    () => {
      (UISection.SECTION_CHANGE = "event_section_change"),
        (UISection.APPLICATION_RESET = "event_application_reset"),
        (UISection.CHOICE_CHANGE = "event_choice_change"),
        (UISection.OPEN_CUSTOMISE = "event_open_customise"),
        (UISection.CLOSE_CUSTOMISE = "event_close_customise"),
        (UISection.OPEN_REPORT = "event_open_report"),
        (UISection.CLOSE_REPORT = "event_close_report"),
        (UISection.COMPARE_UPDATE = "event_compare_update"),
        (UISection.CHOICES_TOGGLE = "event_choice_toggle");
    }
  ),
  Class(function UISectionChoice(_text, _isEnabled, _activeColor, _isCompare) {
    function initHTML() {
      $this.css({ left: "50%", top: "50%" }),
        ($fade = $this.create("Fade")),
        ($text = $fade.create("Text")),
        ($textInner = $text.create("TextInner")).text(_text),
        $text.css({
          fontFamily: "bebas",
          left: 20,
          whiteSpace: "nowrap",
          textTransform: "uppercase",
          fontSize: Device.mobile ? 14 : 16,
          letterSpacing: "0.15em",
          lineHeight: 0,
          opacity: _this.state.alpha,
        }),
        $this.hide();
    }
    function initGLIcon() {
      _icon = _this.initClass(GLSectionChoice);
    }
    function addHandlers() {
      $this.interact(hover, click),
        $this.hit.css({ padding: "10px 140px", margin: "-10px -10px" }),
        _isCompare &&
          _this.events.sub(UISection.COMPARE_UPDATE, ({ active: active }) => {
            _canBeEnabled = active;
          }),
        _this.events.sub(Car.DRIVING, toggleDriving),
        _this.events.sub(UI.FADE, fade),
        _this.events.sub(CarProductHotspots.HOVER, performHover),
        _this.events.sub(UISection.CHOICES_TOGGLE, enableToggle);
    }
    function toggleDriving({ driving: driving }) {
      CarCamera.instance().fading || _icon.toggleDriving(driving);
    }
    function fade({ hide: hide }) {
      Car.instance().isDriving || _icon.toggleDriving(hide);
    }
    function hover(e) {
      _this.state.disabled ||
        _this.state.active ||
        _this.events.fire(CarProductHotspots.HOVER, {
          action: e.action,
          perma: _this.data.perma,
        });
    }
    function performHover(e) {
      if (_this.data.perma === e.perma)
        switch (e.action) {
          case "over":
            $text.tween({ opacity: 0.8 }, 400, "easeOutCubic"),
              _icon.hoverOver();
            break;
          case "out":
            $text.tween({ opacity: _this.state.alpha }, 600, "easeOutCubic"),
              _icon.hoverOut();
        }
    }
    function click() {
      _this.state.disabled || (_this.onClick && _this.onClick());
    }
    function enableToggle({ active: active = !1 }) {
      (!_canBeEnabled && active) ||
        _this.state.hidden ||
        (active && _this.state.disabled
          ? ((_this.state.disabled = 0),
            (_this.state.alpha = 0.4),
            _icon.enable())
          : active ||
            _this.state.disabled ||
            ((_this.state.disabled = 1),
            (_this.state.alpha = 0.15),
            _icon.disable()),
        $text.tween({ opacity: _this.state.alpha }, 600, "easeInOutCubic"));
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $fade, $text, $textInner, _icon;
    _this.state = {
      hidden: 1,
      active: 0,
      disabled: _isEnabled ? 0 : 1,
      alpha: _isEnabled ? 0.4 : 0.15,
    };
    var _canBeEnabled = !_isCompare;
    initHTML(),
      initGLIcon(),
      addHandlers(),
      (this.animateIn = function animateIn(delay = 0) {
        (_this.state.hidden = 0),
          $this.show(),
          $text.css({ opacity: 0 }),
          $text.tween(
            { opacity: _this.state.active ? 1 : _this.state.alpha },
            1400,
            "easeOutQuart",
            200 + delay
          ),
          $fade.transform({ x: 40 }),
          $fade.tween({ x: 0 }, 1400, "easeOutQuart", 200 + delay),
          _icon.animateIn(delay);
      }),
      (this.animateOut = function animateOut(callback, delay = 0) {
        (_this.state.hidden = 1),
          $text.tween({ opacity: 0 }, 500, "easeOutCubic", delay),
          $fade.tween({ x: 10 }, 500, "easeOutCubic", delay),
          _this.delayedCall(() => {
            _this.state.hidden && ($this.hide(), callback && callback());
          }, 500 + delay),
          _icon.animateOut(delay);
      }),
      (this.changeColor = function (color) {
        _this.state.active &&
          _canBeEnabled &&
          $textInner.tween({ color: color }, 600, "easeOutCubic"),
          (_this.color = color),
          _icon.changeColor(color);
      }),
      (this.activate = function (initial) {
        (_this.state.active = 1),
          $textInner.tween(
            { color: _activeColor || _this.color },
            600,
            "easeOutCubic"
          ),
          initial || $text.tween({ opacity: 1 }, 800, "easeOutQuint"),
          _icon.activate(_activeColor);
      }),
      (this.deactivate = function () {
        (_this.state.active = 0),
          $textInner.tween({ color: "#fff" }, 600, "easeOutCubic"),
          $text.tween({ opacity: _this.state.alpha }, 800, "easeOutQuint"),
          _icon.deactivate(_activeColor);
      }),
      (this.layout = function (x, y) {
        _icon.layout(x, y);
      });
  }),
  Class(function UISectionResetPrompt(_text) {
    function init() {
      ($fade = $this.create("Fade")),
        ($presetIcon = $fade.create("PresetIcon")),
        ($text = $fade.create("Text")),
        ($resetIcon = $fade.create("Reset"));
    }
    function style() {
      $presetIcon.bg(
        `assets/images/ui/main/presets/${
          UISection.PRESET || "lightweight"
        }.svg`,
        "contain"
      ),
        $text.text(_text),
        $resetIcon.bg("assets/images/ui/main/customise/reset.svg", "contain"),
        $this.css({ left: "50%", top: "50%" }),
        $presetIcon.css({
          top: "50%",
          left: 0,
          padding: Device.mobile ? 8 : 10,
          margin: Device.mobile ? -8 : -10,
        }),
        $text.css({
          textTransform: "uppercase",
          position: "relative",
          fontFamily: "bebas",
          letterSpacing: "0.15em",
          padding: "5px 20px",
          fontSize: Device.mobile ? 13 : 15,
          whiteSpace: "nowrap",
        }),
        $resetIcon.css({
          top: "50%",
          right: Device.mobile ? -6 : 0,
          padding: Device.mobile ? 6 : 8,
          margin: Device.mobile ? -6 : -8,
        }),
        $fade.css({ opacity: 0 }).transform({ x: 10 });
    }
    function addHandlers() {
      $fade.interact(hover, click);
    }
    function hover(e) {
      if (!_this.disabled)
        switch (e.action) {
          case "over":
            $resetIcon.tween({ rotation: _rotation + 45 }, 200, "easeOutCubic"),
              $fade.tween({ opacity: 0.8 }, 200, "easeOutSine");
            break;
          case "out":
            $resetIcon.tween({ rotation: _rotation }, 200, "easeOutCubic"),
              $fade.tween({ opacity: 0.3 }, 200, "easeOutSine");
        }
    }
    function click() {
      _this.disabled ||
        ((_this.disabled = !0),
        _this.delayedCall((_) => {
          _this.disabled = !1;
        }, 1e3),
        Track.event("customise", "reset-preset"),
        (_rotation += 360),
        $resetIcon.tween({ rotation: _rotation }, 700, "easeInOutCubic"),
        $fade.css({ opacity: 1 }).tween({ opacity: 0.3 }, 500, "easeInOutSine"),
        _this.onClick && _this.onClick());
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $fade, $presetIcon, $text, $resetIcon;
    var _rotation = 0;
    init(),
      style(),
      addHandlers(),
      (this.animateIn = async function () {
        await defer(),
          $fade.tween({ opacity: 0.3 }, 1e3, "easeInOutCubic", 1e3);
      }),
      (this.animateOut = async function (callback) {
        await $fade.tween({ opacity: 0 }, 300, "easeOutQuint").promise(),
          callback && callback();
      });
  }),
  Class(function UISectionSoon(_perma) {
    function initText() {
      $this
        .css({
          color: Colors.instance().disabledColor,
          bottom: "22%",
          left: 0,
          right: 0,
          margin: "-50px auto 0 auto",
          width: 600,
          maxWidth: "80%",
          textAlign: "center",
        })
        .mouseEnabled(!1),
        ($wrapper = $this.create(".wrapper")).size("100%"),
        ($title = $wrapper.create(".text")).css({
          fontFamily: "bebas",
          width: "100%",
          fontSize: Device.mobile ? 24 : 28,
          position: "relative",
          display: "block",
          lineHeight: "1.8em",
          letterSpacing: "0.18em",
          textTransform: "uppercase",
          opacity: 1e-4,
        }),
        $title.text(Data.copy("COMING_SOON_TITLE")),
        ($text = $wrapper.create(".text")).css({
          width: "50%",
          marginLeft: "25%",
          position: "relative",
          display: "block",
          fontSize: Tests.smallTablet() ? 9 : 10,
          lineHeight: "1.8em",
          letterSpacing: "0.18em",
          textTransform: "uppercase",
          opacity: 0.5,
        }),
        $text.text(Data.copy(`COMING_SOON_${_perma.toUpperCase()}`));
    }
    function animateIn() {
      $title
        .transform({ y: 30 })
        .css({ opacity: 1e-4 })
        .tween({ y: 0, opacity: 1 }, 2e3, "easeOutQuint", MAIN_DELAY),
        $text
          .transform({ y: 30 })
          .css({ opacity: 1e-4 })
          .tween({ y: 0, opacity: 0.8 }, 2e3, "easeOutQuint", MAIN_DELAY + 200);
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    var $wrapper, $title, $text;
    const MAIN_DELAY = 700;
    initText(),
      animateIn(),
      (this.animateIn = animateIn),
      (this.animateOut = function animateOut() {
        $wrapper.tween({ opacity: 0 }, 400, "easeOutSine", (_) => {
          _this.destroy();
        });
      });
  }),
  Class(function UISectionText(_data) {
    function initText() {
      $this
        .css({
          color: _data.color || "#fff",
          top: Device.mobile ? "13%" : "14%",
          left: 0,
          right: 0,
          margin: "-50px auto 0 auto",
          width: 500,
          maxWidth: "80%",
          textAlign: "center",
        })
        .mouseEnabled(!1),
        ($wrapper = $this.create(".wrapper")).size("100%"),
        ($sub = $wrapper.create(".text")).css({
          fontFamily: "bebas",
          position: "relative",
          display: "block",
          width: "100%",
          fontSize: 14,
          lineHeight: "1.3em",
          letterSpacing: "0.35em",
          textTransform: "uppercase",
        }),
        $sub.text(_data.sub),
        ($title = $wrapper.create(".text")).css({
          fontFamily: "bebas",
          width: "100%",
          fontSize: 28,
          position: "relative",
          display: "block",
          lineHeight: "1.8em",
          letterSpacing: "0.18em",
          textTransform: "uppercase",
        }),
        $title.text(_data.title),
        ($text = $wrapper.create(".text")).css({
          width: "100%",
          position: "relative",
          display: "block",
          fontSize: Tests.smallTablet() ? 9 : 10,
          lineHeight: "1.8em",
          letterSpacing: "0.18em",
          textTransform: "uppercase",
          opacity: _data.color ? 0.9 : 0.6,
        });
      let t = _data.text || _data.description;
      t.length > 200 && (t = t.substring(0, 200) + "..."),
        $text.text(t),
        (_words = Tests.isSplitText()
          ? SplitTextfield.split($text, "word")
          : [$text]),
        $this.hide();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    var $sub, $wrapper, $title, $text;
    let _words;
    (_this.isVisible = !0),
      initText(),
      (this.animateIn = function animateIn(mainDelay = 0) {
        $this.show(),
          $sub
            .transform({ y: -20 })
            .css({ opacity: 0 })
            .tween({ y: 0, opacity: 1 }, 2e3, "easeOutQuint", mainDelay),
          $title
            .transform({ y: 30 })
            .css({ opacity: 0 })
            .tween({ y: 0, opacity: 1 }, 2e3, "easeOutQuint", mainDelay),
          _words.forEach((word, i) => {
            word.css({ opacity: 0 }),
              word.transform({
                y: 20,
                rotation: Math.range(i, 0, _words.length - 1, 8, 2),
              });
            const delay =
              Math.pow(0.5 * i, 1.5) *
              Math.range(_words.length, 10, 40, 20, 3, !0);
            word.tween(
              { opacity: 1, y: 0, rotation: 0 },
              2e3,
              "easeOutQuint",
              delay + mainDelay + 500
            );
          }),
          _this.delayedCall(() => {
            _this.isAnimationComplete = !0;
          }, 15 * Math.pow(0.5 * _words.length, 1.5) + 1e3 + mainDelay);
      }),
      (this.animateOut = function animateOut() {
        (_this.isVisible = !1),
          $wrapper.tween({ opacity: 0 }, 400, "easeOutSine", (_) => {
            $this.hide(), _this.destroy();
          });
      });
  }),
  Class(function UISectionTitle(_text, _type) {
    function initHTML() {
      $this.css({ left: "50%", top: "50%" }).mouseEnabled(!1),
        ($fade = $this.create("Fade")),
        ($text = $fade.create("Text")).text(_text),
        $fade.css({ opacity: 0.3 }),
        $text.css({
          fontFamily: "bebas",
          right: Device.mobile ? 0.6 * _size : 0.7 * _size,
          whiteSpace: "nowrap",
          textTransform: "uppercase",
          fontSize: Device.mobile ? 16 : 20,
          letterSpacing: "0.15em",
          lineHeight: 0,
        }),
        $this.hide();
    }
    function initGLIcon() {
      _icon = _this.initClass(GLSectionTitle, _type);
    }
    function addHandlers() {
      $this.interact(hover, click),
        $this.hit.css({ padding: "22px 80px", margin: "-22px -140px" }),
        _this.events.sub(Car.DRIVING, toggleDriving),
        _this.events.sub(UI.FADE, fade);
    }
    function toggleDriving({ driving: driving }) {
      CarCamera.instance().fading || _icon.toggleDriving(driving);
    }
    function fade({ hide: hide }) {
      Car.instance().isDriving || _icon.toggleDriving(hide);
    }
    function hover(e) {
      if (!_this.state.disabled && !_this.state.active)
        switch (e.action) {
          case "over":
            $fade.tween({ opacity: 0.7 }, 400, "easeOutCubic"),
              _icon.hoverOver();
            break;
          case "out":
            $fade.tween({ opacity: 0.3 }, 600, "easeOutCubic"),
              _icon.hoverOut();
        }
    }
    function click() {
      _this.onClick && _this.onClick();
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    let $fade, $text;
    var _icon,
      _size = 50;
    (_this.state = { hidden: 1, active: 0, disabled: 0 }),
      initHTML(),
      initGLIcon(),
      addHandlers(),
      (this.animateIn = function animateIn(delay = 0) {
        (_this.state.hidden = 0),
          $this.show(),
          $text.css({ opacity: 0 }),
          $text.transform({ x: Device.mobile ? 5 : 10 }),
          $text.tween(
            { opacity: 1, x: _this.state.active ? -10 : 0 },
            2e3,
            "easeOutCubic",
            200 + delay
          ),
          _icon.animateIn(delay);
      }),
      (this.animateOut = function animateOut(delay = 0) {
        (_this.state.hidden = 1),
          $text.tween({ opacity: 0, x: -10 }, 1e3, "easeOutCubic", delay),
          _this.delayedCall(() => {
            _this.state.hidden && $this.hide();
          }, 1e3 + delay),
          _icon.animateOut(delay);
      }),
      (this.changeColor = function (color) {
        _icon.changeColor(color);
      }),
      (this.disable = function () {
        (_this.state.disabled = 1),
          $fade.tween({ opacity: 0.05 }, 400, "easeOutQuint"),
          $this.hit.hide(),
          _icon.disable();
      }),
      (this.enable = function () {
        (_this.state.disabled = 0),
          $fade.tween({ opacity: 1 }, 1e3, "easeInOutCubic", (_) => {
            $fade.tween({ opacity: 0.3 }, 1e3, "easeInOutCubic");
          }),
          $this.hit.show(),
          _icon.enable();
      }),
      (this.activate = function () {
        (_this.state.active = 1),
          _this.state.disabled || _this.enable(),
          $fade.tween({ opacity: 1 }, 1e3, "easeOutQuint"),
          $text.tween({ x: -10 }, 1e3, "easeOutQuint"),
          _icon.activate();
      }),
      (this.deactivate = function () {
        (_this.state.active = 0),
          _this.state.disabled || _this.enable(),
          $fade.tween({ opacity: 0.3 }, 800, "easeOutQuint"),
          $text.tween({ x: 0 }, 1e3, "easeOutQuint"),
          _icon.deactivate();
      }),
      (this.changeIcon = function (perma) {
        _icon.changeIcon(perma);
      }),
      (this.layout = function (x, y) {
        _icon.layout(x, y);
      });
  }),
  Class(function UIUnsupportedRotateView() {
    function initHTML() {
      ($title = $this.create("Title")).text(Data.copy("ROTATE_DEVICE")),
        (($icon = $title.create("Icon")).multiTween = !0);
    }
    function style() {
      $this
        .size("100%", "100%")
        .css({
          position: "absolute",
          top: 0,
          left: 0,
          backgroundRepeat: "no-repeat",
          backgroundSize: "cover",
          overflow: "hidden",
          zIndex: 9999,
          opacity: 1e-4,
        })
        .bg(
          "assets/images/ui/unsupported/car-background.jpg",
          "center",
          "center"
        ),
        $this.hide(),
        $title
          .size("80%", "auto")
          .css({
            width: 320,
            height: "auto",
            position: "absolute",
            bottom: "63%",
            left: "calc(50% - 320px / 2)",
            fontFamily: "bebas",
            textTransform: "uppercase",
            fontSize: 40,
            letterSpacing: "0.18em",
            lineHeight: "1.4em",
            textAlign: "center",
          }),
        $title.transform({ y: 30 }).css({ opacity: 1e-4 }),
        $icon
          .css({
            position: "absolute",
            bottom: "120%",
            left: "calc(50% - 30px)",
            width: 60,
            height: 60,
            opacity: 0,
            backgroundRepeat: "no-repeat",
            backgroundSize: "contain",
          })
          .bg("assets/images/ui/unsupported/rotate.svg", "center", "center");
    }
    function spin() {
      $icon
        .transform({ rotation: 0 })
        .tween({ rotation: -180 }, 1e3, "easeInOutExpo")
        .onComplete(async () => {
          await _this.wait(1e3), spin();
        });
    }
    function addHandlers() {
      _this.events.sub(Events.RESIZE, resize);
    }
    function resize() {
      Stage.height < Stage.width
        ? $this.tween({ opacity: 0 }, 500, "easeInOutQuint").onComplete(() => {
            $this.hide(),
              $title.transform({ y: 30 }).css({ opacity: 1e-4 }),
              $icon.css({ opacity: 0 }),
              _opAnimation && _opAnimation.stop();
          })
        : ($this.show().tween({ opacity: 1 }, 500, "easeOutQuint"),
          $title.tween({ y: 0, opacity: 1 }, 2e3, "easeOutQuint", 500),
          (_opAnimation = $icon.tween(
            { opacity: 1 },
            1e3,
            "easeInOutQuint",
            1200
          )));
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    var $title, $icon, _opAnimation;
    !(async function () {
      initHTML(), style(), addHandlers(), resize(), spin();
    })();
  }),
  Class(function UIUnsupportedView() {
    function initHTML() {
      ($logo = $this.create("Logo")),
        ($tag = $logo.create("copy")).html(
          Data.copy("LOADER_TAG").toUpperCase()
        ),
        ($text = $this.create("Text")).text(Data.copy("UNSUPPORTED_TEXT")),
        (_words = SplitTextfield.split($text, "word"));
    }
    function style() {
      $this
        .size("100%", "100%")
        .css({
          position: "static",
          opacity: 1e-4,
          overflow: "hidden",
          pointerEvents: "none",
        }),
        $logo
          .size(140, 140)
          .bg("assets/images/ui/logo.svg", "cover")
          .css({ top: "calc(5% - 50px)", left: "calc(50% - 140px / 2)" }),
        $tag
          .fontStyle(Config.FONT_BODY, 10, "rgba(255, 255, 255, 0.3)")
          .css({
            letterSpacing: "0.4em",
            paddingLeft: "0.25em",
            whiteSpace: "nowrap",
            textAlign: "center",
            top: 85,
          }),
        $text.css({
          width: 250,
          position: "absolute",
          bottom: "7%",
          display: "block",
          fontSize: 12,
          lineHeight: "1.8em",
          letterSpacing: "0.18em",
          textTransform: "uppercase",
          opacity: 0.7,
          left: "calc(50% - 125px)",
          textAlign: "center",
        });
    }
    function animateIn() {
      $this.tween({ opacity: 1 }, 1e3, "easeInOutCubic"),
        $logo
          .css({ opacity: 1e-4 })
          .tween({ opacity: 1 }, 2e3, "easeOutQuint", 750),
        _words.forEach((word, i) => {
          word.css({ opacity: 1e-4 }),
            word.transform({
              y: 20,
              rotation: Math.range(i, 0, _words.length - 1, 8, 2),
            });
          const delay =
            Math.pow(0.5 * i, 1.5) *
            Math.range(_words.length, 10, 40, 20, 3, !0);
          word.tween(
            { opacity: 0.7, y: 0, rotation: 0 },
            2e3,
            "easeOutQuint",
            delay + 1e3
          );
        });
    }
    function resize() {
      let vertical = Stage.width < Stage.height;
      $text.css({
        bottom: vertical ? "23%" : "7%",
        textAlign: vertical ? "center" : "left",
        lineHeight: vertical ? "1.8em" : "1.5em",
        left: vertical ? "calc(50% - 125px)" : "5%",
      });
    }
    function addHandlers() {
      _this.events.sub(Events.RESIZE, resize);
    }
    Inherit(this, Element);
    const _this = this,
      $this = this.element;
    var $logo, $tag, $text, _words;
    !(async function () {
      await _this.wait(Data, "dataReady"),
        initHTML(),
        style(),
        addHandlers(),
        resize(),
        animateIn();
    })();
  }),
  Class(function Viewport() {
    async function initFluid() {
      Tests.useFluid() &&
        (((_fluid = await _this.layout.getLayer("Fluid")).mesh.shader.visible =
          !1),
        (_ripple.shader.uniforms.tFluid = _fluid.fbos.velocity.uniform),
        (_ripple.shader.uniforms.tFluidCurl = _fluid.fbos.curl.uniform),
        (_ripple.shader.uniforms.tFluidMask.value = _fluid),
        (_config = InputUIL.create("fluid_config")).setLabel("Fluid Config"),
        _config.addNumber("velocity", 100),
        _config.addNumber("size", 80));
    }
    function loop(time, delta) {
      if (!_this.isPaused) {
        if (Tests.useFluid() && _fluid && _config) {
          let velocity = _config.getNumber("velocity"),
            size = _config.getNumber("size") * (_faded ? 2.75 : 1);
          if (Mouse.delta.length() !== _prevDelta.length()) {
            let x = _faded
                ? 0.909 * (Mouse.x - Stage.width / 2) + Stage.width / 2
                : Mouse.x,
              y = _faded
                ? 0.909 * (Mouse.y - Stage.height / 2) + Stage.height / 2
                : Mouse.y;
            _fluid.drawInput(
              x,
              y,
              Mouse.delta.x * velocity,
              Mouse.delta.y * velocity,
              _white,
              size
            );
          }
          _prevDelta.copy(Mouse.delta);
        }
        Background.instance().loop(time, delta),
          Car.instance().loop(time, delta),
          _this.render(),
          Tests.isPhone() || updateCircleRadius();
      }
    }
    function updateCircleRadius() {
      const stateDiff =
        Config.RADIUS[`${Config.RADIUS.state}Value`] - Config.RADIUS.stateValue;
      (Config.RADIUS.stateValue += 0.1 * stateDiff),
        Math.abs(stateDiff) < 0.01 &&
          (Config.RADIUS.stateValue =
            Config.RADIUS[`${Config.RADIUS.state}Value`]);
      const target = Config.RADIUS.stateValue * Config.RADIUS.scale,
        diff = target - Config.RADIUS.value;
      Math.abs(diff) < 0.01
        ? (Config.RADIUS.value = target)
        : (Config.RADIUS.value += 0.1 * diff),
        Math.abs(diff) > 0 && _this.events.fire(Config.RADIUS_UPDATE);
    }
    function fade({ hide: hide }) {
      _faded = hide;
    }
    function addHandlers() {
      !Global.PLAYGROUND && Container.instance().isLoaded && animateIn(),
        _this.events.sub(Container.LOADED, animateIn),
        _this.onResize(resize),
        Tests.isPhone() ||
          (_this.events.sub(UI.FADE, fade),
          _this.events.sub(Car.DRIVING, toggleDriving),
          _this.events.sub(UISection.OPEN_CUSTOMISE, openCustomise),
          _this.events.sub(UISection.CLOSE_CUSTOMISE, closeCustomise),
          _this.events.sub(UISection.CHOICE_CHANGE, choiceChange),
          _this.events.sub(UISection.SECTION_CHANGE, choiceChange));
    }
    function resize() {
      Config.RADIUS.scale = _this.getCircleScale();
    }
    function choiceChange() {
      tween(
        _circleNav.shader.uniforms.uGlowStrength,
        { value: 1 },
        500,
        "easeOutCubic",
        (_) => {
          tween(
            _circleNav.shader.uniforms.uGlowStrength,
            { value: 0.5 },
            1500,
            "easeInOutCubic"
          );
        }
      );
    }
    async function animateIn({ deeplink: deeplink }) {
      Background.instance().animateIn(),
        tween(
          _ripple.shader.uniforms.uStrength,
          { value: 0.07 },
          5e3,
          "easeInOutCubic",
          2e3
        ),
        tween(
          _ripple.shader.uniforms.uHole,
          { value: 1 },
          6500,
          "easeInOutExpo",
          3e3
        ),
        tween(
          _circleNav.shader.uniforms.uMaskLeft,
          { value: 1 },
          3e3,
          "easeOutCubic",
          3500
        ),
        tween(
          _circleNav.shader.uniforms.uMaskRight,
          { value: 1 },
          3e3,
          "easeOutCubic",
          3500
        ),
        tween(
          _circleNav.shader.uniforms.uRotation,
          { value: 4 * -Math.PI },
          6e3,
          "easeOutQuart",
          3e3
        ),
        tween(
          _circleNav.shader.uniforms.uHaloAlpha,
          { value: 1 },
          2e3,
          "easeInOutCubic",
          5e3
        ),
        await _this.wait(deeplink ? 5e3 : 5600),
        (Config.RADIUS.state = deeplink || "main"),
        tween(
          _ripple.shader.uniforms.uStrength,
          { value: 0.01 },
          3e3,
          "easeInOutQuint"
        );
    }
    function toggleDriving({ driving: driving }) {
      driving
        ? ((_this.previousState = Config.RADIUS.state),
          (Config.RADIUS.state = "driving"))
        : (Config.RADIUS.state = _this.previousState);
    }
    function openCustomise() {
      _this.delayedCall((_) => {
        _this.isPaused = !0;
      }, 1e3);
    }
    function closeCustomise() {
      _this.clearTimers(), (_this.isPaused = !1);
    }
    function playgroundSkip() {
      (_ripple.shader.uniforms.uHole.value = 1),
        (_ripple.shader.uniforms.uStrength.value = 0.5),
        (_ripple.shader.uniforms.uSize.value = 250),
        (_circleNav.shader.uniforms.uSize.value = 250),
        (_circleNav.shader.uniforms.uMaskLeft.value = 1),
        (_circleNav.shader.uniforms.uMaskRight.value = 1),
        (_circleNav.shader.uniforms.uRotation.value = 0),
        (_circleNav.shader.uniforms.uHaloAlpha.value = 1);
    }
    Inherit(this, FXScene);
    const _this = this;
    let _ripple, _circleNav, _fluid, _config;
    var _white = new Color("#ffffff"),
      _prevDelta = new Vector2(),
      _faded = !1;
    (this.ready = Promise.create()),
      (async function () {
        _this.create(),
          (_this.layout = _this.initClass(SceneLayout, "ViewportLayout")),
          _this.scene.add(_this.layout.group),
          ([_ripple, _circleNav] = await _this.layout.getLayers(
            "Ripple",
            "CircleNav"
          )),
          initFluid(),
          Tests.isPhone() &&
            ((_circleNav.visible = !1),
            (Config.RADIUS.value = 2e3),
            _this.events.fire(Config.RADIUS_UPDATE)),
          addHandlers(),
          _this.startRender(loop),
          Global.PLAYGROUND && playgroundSkip(),
          _this.ready.resolve();
      })(),
      (this.getCircleScale = function () {
        const sizeH = Math.range(Stage.height, 0, 500, 0, 350),
          sizeW = Stage.width / 2 - 240;
        return (
          Math.min(sizeH, sizeW) /
          (Tests.smallTablet() ? 225 : Tests.bigTablet() ? 240 : 250)
        );
      });
  }, "singleton"),
  Class(function Background(_input, _group) {
    function initBackground() {
      (_shader = _this.initClass(Shader, "Background", {
        uNoiseScale: { value: 1 },
        uNoiseSpeed: { value: 1 },
        uBaseColor: { value: new Color("#10151A") },
        uColor1: Colors.instance().SHADER[0],
        uColor2: Colors.instance().SHADER[1],
        uColor3: Colors.instance().SHADER[2],
        uVisible: { value: 0 },
        depthWrite: !1,
      })),
        ShaderUIL.add(_shader, _group);
      const mesh = new Mesh(World.QUAD, _shader);
      _this.scene.add(mesh);
    }
    function initParticles() {
      const geometry = new Geometry(),
        position = [],
        random = [];
      for (let i = 0; i < 50; i++)
        position.push(Math.random(), Math.random(), Math.random()),
          random.push(
            Math.random(),
            Math.random(),
            Math.random(),
            Math.random()
          );
      geometry.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(position), 3)
      ),
        geometry.addAttribute(
          "random",
          new GeometryAttribute(new Float32Array(random), 4)
        );
      const shader = _this.initClass(Shader, "BackgroundParticles", {
        tParticle: { value: null },
        transparent: !0,
        blending: Shader.ADDITIVE_BLENDING,
        depthWrite: !1,
      });
      ShaderUIL.add(shader, _group);
      const points = new Points(geometry, shader);
      _this.scene.add(points);
    }
    Inherit(this, FXScene);
    const _this = this;
    var _shader;
    const camera = new PerspectiveCamera(
      30,
      Stage.width / Stage.height,
      0.1,
      100
    );
    (camera.position.z = 10),
      _this.create(),
      _this.useCamera(camera),
      initBackground(),
      initParticles(),
      (this.animateIn = function () {
        _shader.tween("uVisible", 1, 4e3, "easeInOutCubic", 5e3);
      }),
      (this.loop = function loop() {
        _this.render();
      });
  }, "singleton"),
  Class(
    function Car() {
      function initSection() {
        _engines.hide(), _products.hide();
      }
      function addHandlers() {
        _this.events.sub(UISection.SECTION_CHANGE, changeSection),
          _this.events.sub(UISection.CHOICE_CHANGE, changeChoice),
          _this.events.sub(Container.LOADED, checkDeeplink);
      }
      function slalom(t) {
        CarControls.input.intro.x =
          0.8 * Math.clamp(2 * Math.cos(0.0015 * t + 3.2), -1, 1);
      }
      async function showProductsMobile() {
        await _products.ready.then(() => {
          _products.show();
        });
      }
      async function checkDeeplink({ deeplink: deeplink }) {
        if (!deeplink || Tests.isPhone())
          return (
            (_this.isIntro = !0),
            Tests.isPhone() && showProductsMobile(),
            await _this.wait(3500),
            _this.startRender(slalom),
            (CarControls.input.intro.y = 0.8),
            await _this.wait(8e3),
            _this.stopRender(slalom),
            await tween(
              CarControls.input.intro,
              { x: 0, y: 0 },
              1e3,
              "linear"
            ).promise(),
            tween(_controls.speedMultiplier, { val: 1 }, 1e3, "easeOutCubic"),
            (CarControls.input.intro.y = 0),
            (CarControls.input.intro.x = 0),
            await _this.wait(1e3),
            (_this.isIntro = !1),
            void (
              Tests.isPhone() ||
              _this.events.fire(Car.SHOW_ROTATE, {
                time: 2e3,
                ease: "easeOutCubic",
              })
            )
          );
        changeSection({ data: { perma: deeplink } });
      }
      async function changeSection({ index: index, data: data }) {
        switch (((_this._currentSectionPerma = data.perma), data.perma)) {
          case "body":
            _bodies.show(),
              _engines.hide(),
              _products.hide(),
              CarCamera.instance().sectionChange();
            break;
          case "engine":
            _bodies.show(), _engines.show(), _products.hide();
            break;
          case "presets":
            (_this.changingPresetsSection = !0),
              _bodies.show(),
              _engines.hide(),
              _products.toPresets(),
              await defer(),
              await defer(),
              CarCamera.instance().sectionChange(),
              (_this.changingPresetsSection = !1);
            break;
          case "customise":
            _bodies.show(), _engines.hide(), _products.toCustomise();
            break;
          case "report":
            _engines.hide(), _products.hide();
        }
        "engine" !== data.perma &&
          CarCamera.instance().isTargetEngine &&
          CarCamera.instance().resetTarget();
      }
      async function changeChoice({ index: index, data: data }) {
        switch (_this._currentSectionPerma) {
          case "body":
            (_this.changingBody = !0),
              _bodies.change(index),
              transformEnginesProducts(data.perma),
              _this.delayedCall(() => {
                _this.changingBody = !1;
              }, 1800);
            break;
          case "engine":
            _engines.change(index),
              await defer(),
              await defer(),
              CarCamera.instance().toEngine(data.perma);
            break;
          case "presets":
            _this.changingPresetsSection || _bodies.moveLines(),
              _products.changePreset(index),
              CarCamera.instance().changePreset(data.perma);
            break;
          case "customise":
            _products.changeActive(index),
              CarCamera.instance().toProduct(data.perma);
        }
      }
      function transformEnginesProducts(perma) {
        switch (perma) {
          case "hatchback":
            (_positionOffset.y = 0),
              (_positionOffset.z = 0),
              _scaleOffset.setScalar(1);
            break;
          case "suv":
            (_positionOffset.y = 0.08),
              (_positionOffset.z = 0.065),
              _scaleOffset.setScalar(1.05);
        }
      }
      Inherit(this, FXScene);
      const _this = this;
      let _bodies,
        _camera,
        _controls,
        _engines,
        _floor,
        _rotate,
        _flowSurroundings,
        _products,
        _carGroup,
        _carBodyPass;
      (this.ready = Promise.create()),
        (Car.POSITION = new Vector3()),
        (Car.ROTATION = new Euler()),
        (Car.ROLL = { value: 0, ignoreUIL: !0 }),
        (Car.SPEED = { value: 0, ignoreUIL: !0 }),
        (Car.TURN = { value: 0, ignoreUIL: !0 }),
        (Car.CONTROLS_ROTATION = 0),
        (Car.ENGINE_OFFSET = 0);
      var _scaleOffset = new Vector3(1, 1, 1),
        _positionOffset = new Vector3();
      (_this.isDriving = !1),
        (_this._currentSectionPerma = "body"),
        (_this.changingBody = !1),
        (_this.changingPresetsSection = !1),
        (async function () {
          _this.create(),
            (_this.layout = _this.initClass(SceneLayout, "CarLayout")),
            (Car.LAYOUT = _this.layout),
            ([_bodies, _controls, _engines, _floor, _rotate, _products] =
              await _this.layout.getLayers(
                "Bodies",
                "Controls",
                "Engines",
                "Floor",
                "Rotate",
                "Products"
              )),
            (_this.isReady = !0),
            (_camera = CarCamera.instance()),
            _this.useCamera(_camera.camera),
            _products.useCamera(_camera.camera),
            _this.scene.add(_this.layout.group),
            (_carGroup = new Group()),
            _this.layout.group.add(_carGroup),
            (_carBodyPass = _this.initClass(NukePass, "CarCopyBody", {
              tDiffuse: { value: null },
              tCarLines: {
                value: CarBodyScene.instance().nuke.rttBuffer.texture,
              },
              blending: Shader.ADDITIVE_BLENDING,
            })),
            _this.addPass(_carBodyPass),
            Tests.useSurroundingLines() &&
              ((_flowSurroundings = _this.initClass(CarFlowSurroundings)),
              _bodies.group.add(_flowSurroundings.group)),
            CarBodyScene.instance().carGroup.add(_bodies.group),
            _carGroup.add(_engines.group),
            _carGroup.add(_products.group),
            addHandlers(),
            initSection(),
            _this.ready.resolve();
        })(),
        (this.loop = function loop(time, delta) {
          if (_this.isReady) {
            if (!_this.isIntro) {
              const driving = Math.abs(_controls.speed.value) > 0.25;
              _this.isDriving !== driving &&
                _this.events.fire(Car.DRIVING, { driving: driving }),
                (_this.isDriving = driving);
            }
            (Car.ROLL.value += 0.003 * delta * _controls.speed.value),
              (Car.SPEED.value = _controls.speed.value),
              (Car.TURN.value +=
                0.15 *
                (_controls.turn.value *
                  _controls.speed.value *
                  Math.sign(_controls.speed.value) -
                  Car.TURN.value)),
              (_this.layout.group.rotation.y = _controls.rotation),
              (CarBodyScene.instance().carLayoutGroup.rotation.y =
                _controls.rotation),
              (Car.CONTROLS = _controls),
              (Car.CONTROLS_ROTATION = _controls.rotation),
              (_carGroup.position.z +=
                0.05 *
                (10 * _controls.velocity.speed +
                  Car.ENGINE_OFFSET -
                  _carGroup.position.z)),
              (CarBodyScene.instance().carGroup.position.z +=
                0.05 *
                (10 * _controls.velocity.speed +
                  Car.ENGINE_OFFSET -
                  _carGroup.position.z)),
              (Car.ROTATION.x = -2 * _controls.velocity.speed),
              (Car.ROTATION.z = 3 * _controls.velocity.turn),
              (Car.POSITION.z = -1 * _controls.velocity.speed),
              (Car.POSITION.x = -3 * _controls.velocity.turn),
              [_engines, _products].forEach((node) => {
                node.group.position.copy(Car.POSITION).add(_positionOffset),
                  node.group.rotation.copy(Car.ROTATION),
                  node.group.scale.copy(_scaleOffset);
              }),
              CarBodyScene.instance().render(),
              (_carBodyPass.pass.uniforms.tCarLines.value = Tests.useBloom()
                ? CarBodyScene.instance().nuke.rttBuffer.texture
                : CarBodyScene.instance().rt),
              _this.render();
          }
        }),
        (this.changePresetMobile = function (index) {
          _products.changePreset(index);
        });
    },
    "singleton",
    () => {
      (Car.DRIVING = "event_driving"),
        (Car.PRODUCT_CLICK = "event_product_click"),
        (Car.COLOR_CHANGE = "event_carcolor_change"),
        (Car.SHOW_ROTATE = "event_car_show_rotate"),
        (Car.HIDE_ROTATE = "event_car_hide_rotate");
    }
  ),
  Class(function CarBackground(_input, _group) {
    function initBackground() {
      const shader = _this.initClass(Shader, "CarBackground", {
        tBackground: { value: Background.instance().rt.texture },
        depthWrite: !1,
      });
      ShaderUIL.add(shader, _group);
      const mesh = new Mesh(World.QUAD, shader);
      _this.add(mesh);
    }
    function initParticles() {
      const geometry = new Geometry(),
        position = [],
        random = [];
      for (let i = 0; i < 100; i++)
        position.push(Math.random(), Math.random(), Math.random()),
          random.push(
            Math.random(),
            Math.random(),
            Math.random(),
            Math.random()
          );
      geometry.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(position), 3)
      ),
        geometry.addAttribute(
          "random",
          new GeometryAttribute(new Float32Array(random), 4)
        );
      const shader = _this.initClass(Shader, "CarBackgroundParticles", {
        tParticle: {
          value: Utils3D.getTexture("assets/images/background/particle.jpg"),
        },
        uCenterPosition: { type: "v3", value: _center, ignoreUIL: !0 },
        uMaxRange: { type: "f", value: SPREAD, ignoreUIL: !0 },
        uMaxHeight: { type: "f", value: 0.8 * SPREAD, ignoreUIL: !0 },
        transparent: !0,
        blending: Shader.ADDITIVE_BLENDING,
        depthWrite: !1,
      });
      ((_particles = new Points(geometry, shader)).frustumCulled = !1),
        (_particlesGroup = new Group()).add(_particles),
        _this.add(_particlesGroup),
        (_particles.onBeforeRender = loop);
    }
    function loop() {
      Car.CONTROLS &&
        ((_particlesGroup.rotation.y = -Car.CONTROLS.rotation),
        _center.set(-Car.CONTROLS.position.x, 0, -Car.CONTROLS.position.y));
    }
    Inherit(this, Object3D);
    const _this = this;
    let _particles, _particlesGroup;
    const _center = new Vector3(),
      SPREAD = 8;
    initBackground(), initParticles();
  }, "singleton"),
  Class(function CarBodies(_input, _group) {
    function initBody(data, i) {
      if (!data.enabled) return;
      const body = _this.initClass(CarBody, data.perma, _input, _group);
      data.default
        ? ((_currentIndex = i), body.show(), body.toggleLines(1))
        : (body.hide(), body.toggleLines(0)),
        (_bodies[i] = body);
    }
    Inherit(this, Object3D);
    const _this = this,
      _bodies = [];
    let _currentIndex = 0;
    Data.BODY_STYLES.forEach(initBody),
      (this.change = function (index) {
        (index = Data.BODY_STYLES.indexOf(Meta.BODY_STYLES[index])),
          _currentIndex !== index &&
            (_bodies[_currentIndex].animateOut(),
            _bodies[(_currentIndex = index)].animateIn(),
            CarCamera.instance().bodyChange());
      }),
      (this.moveLines = function () {
        _bodies.forEach((b) => {
          b.moveLines(1.75, 900, "easeInOutQuad");
        });
      }),
      (this.show = function () {
        _this.group.visible = !0;
      }),
      (this.hide = function () {
        _this.group.visible = !1;
      });
  }),
  Class(function CarBody(_type, _input, _group) {
    function initViews() {
      (_wheels = _this.initClass(CarWheels, _type, _input, _group)),
        (_form = _this.initClass(CarForm, _type, _input, _group)),
        (_flowGround = _this.initClass(CarFlowGround, _type, _input, _group)),
        (_flowBody = _this.initClass(CarFlowBody, _type, _input, _group)),
        (_reflection = _this.initClass(CarReflection, _type, _input, _group)),
        (_mask = _this.initClass(CarMask, _type, _input, _group));
    }
    function loop() {
      [_form, _flowBody, _reflection, _mask].forEach((node) => {
        node.group.position.copy(Car.POSITION),
          node.group.rotation.copy(Car.ROTATION);
      });
    }
    Inherit(this, Object3D);
    const _this = this;
    let _wheels, _form, _flowGround, _flowBody, _reflection, _mask;
    initViews(),
      _this.startRender(loop),
      (this.show = function () {
        _this.group.visible = !0;
      }),
      (this.hide = function () {
        _this.group.visible = !1;
      }),
      (this.toggleLines = function (value) {
        [_wheels, _form, _flowGround, _flowBody, _reflection].forEach((el) => {
          el._shader.uniforms.uTransition.value = value;
        });
      }),
      (this.animateOut = function () {
        [_wheels, _form, _flowGround, _flowBody, _reflection].forEach((el) => {
          el._shader.set("uSide", 1),
            el._shader.tween("uTransition", 0, 600, "linear", 0, () => {
              _this.hide();
            });
        });
      }),
      (this.animateIn = function () {
        _this.clearTimers(),
          _this.delayedCall(() => {
            _this.show();
          }, 600),
          [_wheels, _form, _flowGround, _flowBody, _reflection].forEach(
            (el, i) => {
              el._shader.set("uSide", 0),
                el._shader.tween("uTransition", 1, 2400, "easeOutQuart", 600);
            }
          );
      }),
      (this.moveLines = function (amount, time, ease) {
        [_flowBody, _form, _flowGround, _wheels].forEach((el) => {
          el === _wheels && (amount *= 7),
            el === _flowGround && (amount /= 4),
            el._shader.tween(
              "uAddedTime",
              el._shader.uniforms.uAddedTime.value + amount,
              time,
              ease
            );
        });
      });
  }),
  Class(function CarBodyScene() {
    function finalRender() {
      _this.bloom.renderBloom(),
        (_this.bloom.renderMesh.shader = _this.bloom.pass.pass),
        (_this.bloom.renderMesh.shader.uniforms.tDiffuse.value =
          _this.rt.texture),
        _this.nuke.renderer.renderSingle(
          _this.bloom.renderMesh,
          World.NUKE.camera,
          _this.nuke.rttBuffer
        ),
        _this.afterImage &&
          _this.afterImage.enabled &&
          (_this.afterImage.renderAfterImage(),
          (_this.bloom.renderMesh.shader = _this.afterImage.pass.pass),
          _this.nuke.renderer.renderSingle(
            _this.bloom.renderMesh,
            World.NUKE.camera,
            _this.nuke.rttBuffer
          ));
    }
    function openCustomise() {
      _this.delayedCall((_) => {
        _this.bloom.enabled = !1;
      }, 1e3);
    }
    function closeCustomise() {
      _this.clearTimers(), (_this.bloom.enabled = !0);
    }
    function animateAfterImage({ hide: hide }) {
      _this.afterImage &&
        ((_this.afterImage.enabled = !0),
        tween(_dampAnimation, { value: hide ? 0.65 : 0 }, 1e3, "easeOutSine")
          .onUpdate(() => {
            _this.afterImage.damp = _dampAnimation.value;
          })
          .onComplete(() => {
            hide || (_this.afterImage.enabled = !1);
          }));
    }
    function addHandlers() {
      Tests.useBloom() &&
        (_this.events.sub(UISection.OPEN_CUSTOMISE, openCustomise),
        _this.events.sub(UISection.CLOSE_CUSTOMISE, closeCustomise),
        _this.events.sub(UI.FADE, animateAfterImage));
    }
    Inherit(this, FXScene);
    const _this = this;
    var _camera, _dampAnimation;
    (this.bloom = null),
      _this.create(),
      (_this.carLayoutGroup = new Group()),
      (_this.carGroup = new Group()),
      _this.carLayoutGroup.add(_this.carGroup),
      _this.scene.add(_this.carLayoutGroup),
      (_camera = CarCamera.instance()),
      _this.useCamera(_camera.camera),
      (_dampAnimation = { value: 0 }),
      Tests.useBloom() &&
        ((_this.bloom = new FX.UnrealBloom(_this.nuke, {
          kernelSizeArray: [3, 3, 3, 3, 3],
        })),
        (_this.bloom.texture = _this.rt.texture),
        (_this.afterImage = new FX.AfterImage(_this.nuke)),
        (_this.afterImage.damp = 0),
        (_this.afterImage.enabled = !1),
        _this.bloom.events.unsub(RenderManager.RENDER, _this.bloom.renderBloom),
        _this.afterImage &&
          _this.afterImage.events.unsub(
            RenderManager.RENDER,
            _this.afterImage.renderAfterImage
          ),
        (_this.nuke.postRender = finalRender)),
      addHandlers();
  }, "singleton"),
  Class(function CarFlowBody(_type, _input, _group) {
    function initShader() {
      (_this._shader = _this.initClass(Shader, "CarFlowBody", {
        uColor1: Colors.instance().SHADER[0],
        uColor2: Colors.instance().SHADER[1],
        uColor3: Colors.instance().SHADER[2],
        uColorIsolate: { value: new Vector3(), ignoreUIL: !0 },
        uOpacity: { value: 1 },
        tMask: { value: null, getTexture: Utils3D.getRepeatTexture },
        uRoll: Car.ROLL,
        uTurn: Car.TURN,
        uSpeed: Car.SPEED,
        uTransition: { value: 0 },
        uSide: { value: 1 },
        uDisable: { value: 0 },
        uAddedTime: { value: 0 },
        uDisabledColor: { value: Colors.instance().disabledCarColor },
        transparent: !0,
        blending: Shader.ADDITIVE_BLENDING,
        depthWrite: !1,
      })),
        ShaderUIL.add(_this._shader, _group);
    }
    function addHandlers() {
      _this.events.sub(Car.COLOR_CHANGE, changeColor);
    }
    function changeColor(action) {
      let val = "disable" === action ? 1 : 0,
        del = "disable" === action ? 0 : 400;
      tween(
        _this._shader.uniforms.uDisable,
        { value: val },
        800,
        "easeOutCubic",
        del
      );
    }
    function initCurves() {
      Assets.JSON[`data/curves/${_type}/flow-body`].curves.forEach(addCurve);
    }
    function addCurve(d) {
      const vectors = [];
      for (let j = 0; j < d.length; j += 3)
        vectors.push(new Vector3(d[j + 0], d[j + 1], d[j + 2]));
      const catmull = new CatmullRomCurve(vectors);
      catmull.length = catmull.getLength();
      const points = catmull.getPoints(Math.round(25 * catmull.length)),
        lineGeometry = new LineGeometry({
          points: points,
          index: ++index,
          taperFunction: (perc, i, total) =>
            Math.min(
              Math.smoothStep(0, 0.2, perc),
              Math.smoothStep(1, 0.8, perc)
            ),
        }),
        line = new Mesh(lineGeometry.geometry, _this._shader),
        lineReflection = new Mesh(lineGeometry.geometry, _this._shader);
      (line.renderOrder = 100),
        (lineReflection.renderOrder = 100),
        (line.onBeforeRender = () => {
          _this._shader.uniforms.uOpacity.value = 1;
        }),
        (lineReflection.scale.y = -1),
        (lineReflection.onBeforeRender = () => {
          _this._shader.uniforms.uOpacity.value = 0.02;
        }),
        _this.add(line),
        _this.add(lineReflection);
    }
    Inherit(this, Object3D);
    const _this = this;
    let index = 0;
    !(async function () {
      initShader(), initCurves(), addHandlers();
    })(),
      (this.updateColor = function (index) {
        tween(
          _this._shader.uniforms.uColorIsolate.value,
          {
            x: 1 === index ? 1 : 0,
            y: 2 === index ? 1 : 0,
            z: 3 === index ? 1 : 0,
          },
          1e3,
          "easeOutCubic"
        );
      });
  }),
  Class(function CarFlowGround(_type, _input, _group) {
    function initShader() {
      (_this._shader = _this.initClass(Shader, "CarFlowGround", {
        uColor1: Colors.instance().SHADER[0],
        uColor2: Colors.instance().SHADER[1],
        uColor3: Colors.instance().SHADER[2],
        uColorIsolate: { value: new Vector3(), ignoreUIL: !0 },
        uOpacity: { value: 1 },
        tMask: { value: null, getTexture: Utils3D.getRepeatTexture },
        uRoll: Car.ROLL,
        uTurn: Car.TURN,
        uTransition: { value: 0 },
        uSide: { value: 1 },
        uDisable: { value: 0 },
        uDisabledColor: { value: Colors.instance().disabledCarColor },
        uAddedTime: { value: 0 },
        transparent: !0,
        blending: Shader.ADDITIVE_BLENDING,
        depthWrite: !1,
      })),
        ShaderUIL.add(_this._shader, _group);
    }
    function addHandlers() {
      _this.events.sub(Car.COLOR_CHANGE, changeColor);
    }
    function changeColor(action) {
      let val = "disable" === action ? 1 : 0,
        del = "disable" === action ? 0 : 400;
      tween(
        _this._shader.uniforms.uDisable,
        { value: val },
        800,
        "easeOutCubic",
        del
      );
    }
    function initCurves(group) {
      Assets.JSON[`data/curves/${_type}/flow-ground`].curves.forEach(addCurve);
    }
    function addCurve(d) {
      const vectors = [];
      for (let j = 0; j < d.length; j += 3)
        vectors.push(new Vector3(d[j + 0], d[j + 1], d[j + 2]));
      const catmull = new CatmullRomCurve(vectors);
      catmull.length = catmull.getLength();
      const points = catmull.getPoints(Math.round(25 * catmull.length)),
        lineGeometry = new LineGeometry({
          points: points,
          index: ++index,
          taperFunction: (perc, i, total) =>
            Math.min(
              Math.smoothStep(0, 0.1, perc),
              Math.smoothStep(1, 0.9, perc)
            ),
        }),
        line = new Mesh(lineGeometry.geometry, _this._shader),
        lineReflection = new Mesh(lineGeometry.geometry, _this._shader);
      (line.renderOrder = 100),
        (lineReflection.renderOrder = 100),
        (line.onBeforeRender = () => {
          _this._shader.uniforms.uOpacity.value = 1;
        }),
        (lineReflection.scale.y = -1),
        (lineReflection.onBeforeRender = () => {
          _this._shader.uniforms.uOpacity.value = 0.2;
        }),
        _this.add(line),
        _this.add(lineReflection);
    }
    Inherit(this, Object3D);
    const _this = this;
    let index = 0;
    !(async function () {
      initShader(), initCurves(), addHandlers();
    })(),
      (this.updateColor = function (index) {
        tween(
          _this._shader.uniforms.uColorIsolate.value,
          {
            x: 1 === index ? 1 : 0,
            y: 2 === index ? 1 : 0,
            z: 3 === index ? 1 : 0,
          },
          1e3,
          "easeOutCubic"
        );
      });
  }),
  Class(function CarFlowSurroundings() {
    function initShader() {
      (_this._shader = _this.initClass(Shader, "CarFlowSurroundings", {
        uColor1: Colors.instance().SHADER[0],
        uColor2: Colors.instance().SHADER[1],
        uColor3: Colors.instance().SHADER[2],
        uColorIsolate: { value: new Vector3(), ignoreUIL: !0 },
        uOpacity: { value: 1, ignoreUIL: !0 },
        tMask: { value: null, getTexture: Utils3D.getRepeatTexture },
        uRoll: Car.ROLL,
        uTurn: Car.TURN,
        uSpeed: Car.SPEED,
        uDisable: { value: 0, ignoreUIL: !0 },
        uDisabledColor: {
          value: Colors.instance().disabledCarColor,
          ignoreUIL: !0,
        },
        transparent: !0,
        blending: Shader.ADDITIVE_BLENDING,
        depthWrite: !1,
      })),
        ShaderUIL.add(_this._shader).setLabel("Surrounding Lines");
    }
    function addHandlers() {
      _this.events.sub(Car.COLOR_CHANGE, changeColor);
    }
    function changeColor(action) {
      let val = "disable" === action ? 1 : 0,
        del = "disable" === action ? 0 : 400;
      tween(
        _this._shader.uniforms.uDisable,
        { value: val },
        800,
        "easeOutCubic",
        del
      );
    }
    function initCurves() {
      addCurve([0, 0, 10, 0, 0, -10]);
    }
    function addCurve(d) {
      const vectors = [];
      for (let j = 0; j < d.length; j += 3)
        vectors.push(new Vector3(d[j + 0], d[j + 1], d[j + 2]));
      const catmull = new CatmullRomCurve(vectors);
      catmull.length = catmull.getLength();
      const points = catmull.getPoints(Math.round(10 * catmull.length)),
        lineGeometry = new LineGeometry({
          points: points,
          index: ++index,
          taperFunction: (perc, i, total) =>
            Math.min(
              Math.smoothStep(0, 0.4, perc),
              Math.smoothStep(1, 0.6, perc)
            ),
        }),
        instancedLineGeometry = new Geometry();
      for (let key in lineGeometry.geometry.attributes)
        instancedLineGeometry.addAttribute(
          key,
          lineGeometry.geometry.attributes[key]
        );
      (instancedLineGeometry.index = lineGeometry.geometry.index),
        instancedLineGeometry.toNonIndexed();
      let offset = new Float32Array(60),
        indexNum = new Float32Array(20);
      for (let i = 0; i < 20; i++) {
        const off = getOffset([-5, 5, 2], [0, 3.5, 1.75], [-10, 5, 0]);
        (offset[3 * i + 0] = off.x),
          (offset[3 * i + 1] = off.y),
          (offset[3 * i + 2] = off.z),
          (indexNum[i] = i + 1);
      }
      instancedLineGeometry.addAttribute(
        "offset",
        new GeometryAttribute(offset, 3, 1)
      ),
        instancedLineGeometry.addAttribute(
          "indexNum",
          new GeometryAttribute(indexNum, 1, 1)
        ),
        ((_mesh = new Mesh(
          instancedLineGeometry,
          _this._shader
        )).frustumCulled = !1),
        (_mesh.renderOrder = 99999),
        (_mesh.onBeforeRender = () => {
          _this._shader.uniforms.uOpacity.value = 0.05;
        }),
        _this.add(_mesh),
        ((_meshReflection = _mesh.clone()).scale.y = -1),
        (_meshReflection.onBeforeRender = () => {
          _this._shader.uniforms.uOpacity.value = 0.05;
        }),
        _this.add(_meshReflection);
    }
    function getOffset(xOpts, yOpts, zOpts) {
      let v = new Vector3(
        Math.random(xOpts[0], xOpts[1], 5),
        Math.random(yOpts[0], yOpts[1], 5),
        Math.random(zOpts[0], zOpts[1], 5)
      );
      for (; Math.abs(v.x) < xOpts[2] && Math.abs(v.y) < yOpts[2]; )
        (v.x = Math.random(xOpts[0], xOpts[1], 5)),
          (v.y = Math.random(yOpts[0], yOpts[1], 5)),
          (v.z = Math.random(zOpts[0], zOpts[1], 5));
      return v;
    }
    function checkVisibility() {
      Math.abs(Car.SPEED.value) > 0.001
        ? ((_meshReflection.visible = !0), (_mesh.visible = !0))
        : ((_meshReflection.visible = !1), (_mesh.visible = !1));
    }
    Inherit(this, Object3D);
    const _this = this;
    let index = 0;
    var _mesh, _meshReflection;
    initShader(),
      initCurves(),
      addHandlers(),
      _this.startRender(checkVisibility);
  }),
  Class(function CarForm(_type, _input, _group) {
    function initShader() {
      (_this._shader = _this.initClass(Shader, "CarForm", {
        uColor1: Colors.instance().SHADER[0],
        uColor2: Colors.instance().SHADER[1],
        uColor3: Colors.instance().SHADER[2],
        uColorIsolate: { value: new Vector3(), ignoreUIL: !0 },
        uOpacity: { value: 1 },
        tMask: { value: null, getTexture: Utils3D.getRepeatTexture },
        uRoll: Car.ROLL,
        uTurn: Car.TURN,
        uTransition: { value: 0 },
        uSide: { value: 1 },
        uDisable: { value: 0 },
        uDisabledColor: { value: Colors.instance().disabledCarColor },
        uAddedTime: { value: 0 },
        transparent: !0,
        blending: Shader.ADDITIVE_BLENDING,
        depthWrite: !1,
      })),
        ShaderUIL.add(_this._shader, _group);
    }
    function addHandlers() {
      _this.events.sub(Car.COLOR_CHANGE, changeColor);
    }
    function changeColor(action) {
      let val = "disable" === action ? 1 : 0,
        del = "disable" === action ? 0 : 400;
      tween(
        _this._shader.uniforms.uDisable,
        { value: val },
        800,
        "easeOutCubic",
        del
      );
    }
    function initCurves(group) {
      Assets.JSON[`data/curves/${_type}/form`].curves.forEach(addCurve);
    }
    function addCurve(d) {
      const vectors = [];
      for (let j = 0; j < d.length; j += 3)
        vectors.push(new Vector3(d[j + 0], d[j + 1], d[j + 2]));
      const catmull = new CatmullRomCurve(vectors);
      catmull.length = catmull.getLength();
      const points = catmull.getPoints(Math.round(25 * catmull.length)),
        lineGeometry = new LineGeometry({
          points: points,
          index: ++index,
          taperFunction: (perc, i, total) =>
            Math.min(
              Math.smoothStep(0, 0.1, perc),
              Math.smoothStep(1, 0.9, perc)
            ),
        }),
        line = new Mesh(lineGeometry.geometry, _this._shader),
        lineReflection = new Mesh(lineGeometry.geometry, _this._shader);
      (line.renderOrder = 100),
        (lineReflection.renderOrder = 100),
        (line.onBeforeRender = () => {
          _this._shader.uniforms.uOpacity.value = 1;
        }),
        (lineReflection.scale.y = -1),
        (lineReflection.onBeforeRender = () => {
          _this._shader.uniforms.uOpacity.value = 0.05;
        }),
        _this.add(line),
        _this.add(lineReflection);
    }
    Inherit(this, Object3D);
    const _this = this;
    let index = 0;
    !(async function () {
      initShader(), initCurves(), addHandlers();
    })(),
      (this.updateColor = function (index) {
        tween(
          _this._shader.uniforms.uColorIsolate.value,
          {
            x: 1 === index ? 1 : 0,
            y: 2 === index ? 1 : 0,
            z: 3 === index ? 1 : 0,
          },
          1e3,
          "easeOutCubic"
        );
      });
  }),
  Class(function CarMask(_type, _input, _group) {
    function initShader() {
      _shader = _this.initClass(Shader, "CarMask", {
        colorMask: Shader.COLOR_MASK_RGBA,
        transparent: !0,
      });
    }
    async function initMesh() {
      const geometry = await GeomThread.loadGeometry(`car/${_type}/mask`),
        mesh = new Mesh(geometry, _shader);
      (mesh.renderOrder = 99),
        _this.add(mesh),
        (mesh.onBeforeRender = () => {});
    }
    Inherit(this, Object3D);
    const _this = this;
    let _shader;
    !(async function () {
      initShader(), initMesh();
    })();
  }),
  Class(function CarReflection(_type, _input, _group) {
    function initShader() {
      (_this._shader = _this.initClass(Shader, "CarReflection", {
        tMap: { value: null, getTexture: Utils3D.getRepeatTexture },
        uMapOpacity: { value: 1 },
        uScale: { value: 1 },
        uSpeed: { value: 1 },
        uColor: Colors.instance().SHADER[0],
        tEnv: { value: null },
        uEnvOpacity: { value: 1 },
        uGlobalOpacity: { value: 1 },
        uTransition: { value: 0 },
        uSide: { value: 1 },
        uCarSpeed: { value: 0, ignoreUIL: !0 },
        uCarRoll: { value: 0, ignoreUIL: !0 },
        transparent: !0,
        blending: Shader.ADDITIVE_BLENDING,
        depthWrite: !1,
      })),
        ShaderUIL.add(_this._shader, _group);
    }
    async function initMesh() {
      const geometry = await GeomThread.loadGeometry(`car/${_type}/reflection`),
        mesh = new Mesh(geometry, _this._shader);
      (mesh.renderOrder = 1), _this.add(mesh), (mesh.onBeforeRender = () => {});
    }
    Inherit(this, Object3D);
    const _this = this;
    !(async function () {
      initShader(), initMesh();
    })();
  }),
  Class(function CarWheels(_type, _input, _group) {
    function initShader() {
      (_this._shader = _this.initClass(Shader, "CarWheels", {
        uColor1: Colors.instance().SHADER[0],
        uColor2: Colors.instance().SHADER[1],
        uColor3: Colors.instance().SHADER[2],
        uColorIsolate: { value: new Vector3(), ignoreUIL: !0 },
        uOpacity: { value: 1 },
        tMask: { value: null, getTexture: Utils3D.getRepeatTexture },
        uRoll: Car.ROLL,
        uTurn: Car.TURN,
        uDisable: { value: 0 },
        uDisabledColor: { value: Colors.instance().disabledCarColor },
        uAddedTime: { value: 0 },
        transparent: !0,
        blending: Shader.ADDITIVE_BLENDING,
        depthWrite: !1,
        uTransition: { value: 0 },
        uSide: { value: 1 },
      })),
        ShaderUIL.add(_this._shader, _group);
    }
    function addHandlers() {
      _this.events.sub(Car.COLOR_CHANGE, changeColor);
    }
    function changeColor(action) {
      tween(
        _this._shader.uniforms.uDisable,
        { value: "disable" === action ? 1 : 0 },
        800,
        "easeOutCubic",
        600
      );
    }
    function initCurves(group) {
      Assets.JSON[`data/curves/${_type}/wheels`].curves.forEach(addCurve);
    }
    function addCurve(d) {
      const vectors = [];
      for (let j = 0; j < d.length; j += 3)
        vectors.push(new Vector3(d[j + 0], d[j + 1], d[j + 2]));
      const catmull = new CatmullRomCurve(vectors);
      (catmull.closed = !0), (catmull.length = catmull.getLength());
      const points = catmull.getPoints(Math.round(40 * catmull.length)),
        lineGeometry = new LineGeometry({ points: points, index: ++index });
      for (
        let i = 0,
          l = lineGeometry.geometry.attributes.previous.array.length - 1;
        i < 6;
        i++
      )
        (lineGeometry.geometry.attributes.previous.array[i] =
          lineGeometry.geometry.attributes.position.array[l - 11 + i]),
          (lineGeometry.geometry.attributes.next.array[l - 5 + i] =
            lineGeometry.geometry.attributes.position.array[6 + i]);
      const pointNum = lineGeometry.points.length / 3,
        fixedUV = new Float32Array(2 * pointNum * 2),
        step = 1 / (pointNum - 1);
      for (let i = 0; i < pointNum; i++) {
        let index = 2 * i * 2;
        (fixedUV[index] = i * step),
          (fixedUV[index + 1] = 0),
          (fixedUV[index + 2] = i * step),
          (fixedUV[index + 3] = 1);
      }
      lineGeometry.geometry.attributes.uv.array = fixedUV;
      const line = new Mesh(lineGeometry.geometry, _this._shader),
        lineReflection = new Mesh(lineGeometry.geometry, _this._shader);
      (line.renderOrder = 100),
        (lineReflection.renderOrder = 100),
        (line.onBeforeRender = () => {
          _this._shader.uniforms.uOpacity.value = 1;
        }),
        (lineReflection.scale.y = -1),
        (lineReflection.onBeforeRender = () => {
          _this._shader.uniforms.uOpacity.value = 0.1;
        }),
        _this.add(line),
        _this.add(lineReflection);
    }
    Inherit(this, Object3D);
    const _this = this;
    let index = 0;
    !(async function () {
      initShader(), initCurves(), addHandlers();
    })(),
      (this.updateColor = function (index) {
        tween(
          _this._shader.uniforms.uColorIsolate.value,
          {
            x: 1 === index ? 1 : 0,
            y: 2 === index ? 1 : 0,
            z: 3 === index ? 1 : 0,
          },
          1e3,
          "easeOutCubic"
        );
      });
  }),
  Class(function CarCamera(_input, _group) {
    function zoom(e) {
      if (
        (3 !== UI.instance().UISectionActive() && (_hoveringHotspot = !1),
        (_hoveringHotspot && "down" === e.action) ||
          !Customise.instance().isPaused ||
          !_controls.enabled)
      )
        return;
      _this.clearTimers();
      const scale = Viewport.instance().getCircleScale();
      switch (e.action) {
        case "down":
          _this.delayedCall(() => {
            (_this.fading = !0),
              (Config.RADIUS.scale = 0.86 * scale),
              _this.events.fire(UI.FADE, { hide: !0 }),
              _this.events.fire(Car.HIDE_ROTATE);
          }, 120);
          break;
        case "up":
          (_this.fading = !1),
            (Config.RADIUS.scale = scale),
            _this.events.fire(UI.FADE, { hide: !1 }),
            _this.events.fire(Car.SHOW_ROTATE);
      }
    }
    function loop() {
      _controls.enabled && _controls.update();
    }
    function resize() {
      (_controls.maxDistance = Stage.height > Stage.width ? 16 : 11),
        _controls.dollyOut(5);
    }
    function hoverHotspot(e) {
      _hoveringHotspot = "over" === e.action;
    }
    function lookAtTarget() {
      _this.group.lookAt(_this.group.target);
    }
    function p2In(v) {
      return v * v;
    }
    function calcTime(v1, v2, time) {
      return (
        _temp4.copy(v1).normalize(),
        _temp5.copy(v2).normalize(),
        0.85 * time + 700 * p2In(Math.range(_temp4.dot(_temp5), -1, 1, 1, 0))
      );
    }
    function updateCamera() {
      _this.group.position.set(0, 0, _animationObj.distance),
        _currentQuaternion
          .copy(_initialQuaternion)
          .slerp(_finalQuaternion, _animationObj.angle),
        _this.group.position.applyQuaternion(_currentQuaternion),
        lookAtTarget();
    }
    Inherit(this, BaseCamera);
    const _this = this;
    let _controls;
    var _hoveringHotspot = !1;
    _this.group.position.multiTween = !0;
    var _initialQuaternion = new Quaternion(),
      _currentQuaternion = new Quaternion(),
      _finalQuaternion = new Quaternion(),
      _animationObj = { distance: 0, angle: 0, multiTween: !0 };
    this.fading = !1;
    const _anim = { rotate: 0 },
      _front = new Vector3(0, 0, 1),
      _temp1 = new Vector3(),
      _temp2 = new Vector3(),
      _temp3 = new Vector3(),
      _temp4 = new Vector3(),
      _temp5 = new Vector3();
    (_anim.multiTween = !0),
      _this.lock(),
      _this.camera.rotation.reorder("YZX"),
      (_controls = new Orbit(_this.group, World.ELEMENT.div)),
      Tests.isPhone() ||
        (World.ELEMENT.bind("touchstart", (e) => {
          (e.action = "down"), zoom(e);
        }),
        $(document).bind("touchend", (e) => {
          (e.action = "up"), zoom(e);
        })),
      (_controls.minPolarAngle = 0.15 * Math.PI),
      (_controls.maxPolarAngle = Math.PI - _controls.minPolarAngle),
      (_controls.enablePan = !1),
      (_controls.minDistance = 3.5),
      (_controls.maxDistance = 12),
      _this.group.position.set(-6.8312, 2.3189, 9.7402),
      (_this.group.initialTarget = new Vector3(0, 0.75, 0)),
      (_this.group.target = new Vector3()),
      _this.group.target.copy(_this.group.initialTarget),
      _this.group.lookAt(_this.group.target),
      (_controls.target = _this.group.target),
      (_this.camera.rotation.y = Math.PI),
      (_controls.onUpdate = function () {}),
      Tests.isPhone() && (resize(), _this.events.sub(Events.RESIZE, resize)),
      _this.events.sub(CarProductHotspots.HOVER, hoverHotspot),
      _this.startRender(loop),
      (this.pause = function () {
        (_this.isPaused = !0), _this.stopRender(loop), (_controls.enabled = !1);
      }),
      (this.resume = function () {
        (_this.isPaused = !1),
          _this.startRender(loop),
          (_controls.enabled = !0);
      }),
      (this.toProduct = async function (perma) {
        (_controls.enabled = !1),
          (_hoveringHotspot = !1),
          _temp1.copy(_this.group.position).normalize(),
          _temp2.fromArray(Config.PRODUCT_DATA[perma].camera),
          Car.instance().layout.group.localToWorld(_temp2),
          _temp3.copy(_temp2).normalize(),
          _currentQuaternion.setFromUnitVectors(_temp1, _temp3),
          _initialQuaternion.setFromUnitVectors(_front, _temp1),
          _finalQuaternion
            .copy(_initialQuaternion)
            .premultiply(_currentQuaternion),
          (_animationObj.angle = 0),
          tween(
            _animationObj,
            { angle: 1 },
            calcTime(_this.group.position, _temp2, 1700),
            "easeInOutQuart"
          ).onUpdate(updateCamera),
          (_animationObj.distance = _this.group.position.length()),
          await tween(
            _animationObj,
            { distance: _temp2.length() },
            calcTime(_this.group.position, _temp2, 2500),
            "easeInOutQuart",
            0
          )
            .onUpdate(updateCamera)
            .promise(),
          _this.isPaused || (_controls.enabled = !0);
      }),
      (this.toEngine = async function (perma) {
        (_this.isTargetEngine = !0), (_controls.enabled = !1);
        const target = Config.ENGINE_DATA[perma].target;
        _temp1.copy(_this.group.position).normalize(),
          _temp2.fromArray(Config.ENGINE_DATA[perma].camera),
          Car.instance().layout.group.localToWorld(_temp2),
          _temp3.copy(_temp2).normalize(),
          _currentQuaternion.setFromUnitVectors(_temp1, _temp3),
          _initialQuaternion.setFromUnitVectors(_front, _temp1),
          _finalQuaternion
            .copy(_initialQuaternion)
            .premultiply(_currentQuaternion),
          (Car.ENGINE_OFFSET = -target[2]),
          tween(_this.group.target, { y: target[1] }, 1800, "easeInOutCubic"),
          (_animationObj.angle = 0),
          tween(
            _animationObj,
            { angle: 1 },
            calcTime(_this.group.position, _temp2, 1700),
            "easeInOutQuart"
          ).onUpdate(updateCamera),
          (_animationObj.distance = _this.group.position.length()),
          await tween(
            _animationObj,
            { distance: _temp2.length() },
            calcTime(_this.group.position, _temp2, 2500),
            "easeInOutQuart",
            0
          )
            .onUpdate(updateCamera)
            .promise(),
          _this.isPaused || (_controls.enabled = !0);
      }),
      (this.changePreset = async function () {
        await tween(_anim, { rotate: 1 }, 400, "easeOutQuint")
          .onUpdate(() => {
            _controls.rotateLeft(0.005 * _anim.rotate);
          })
          .promise();
      }),
      (this.print = function () {
        const p = _this.group.position;
        console.log(
          JSON.stringify([
            Math.round(p.x, 3),
            Math.round(p.y, 3),
            Math.round(p.z, 3),
          ])
        );
      }),
      (this.sectionChange = async function () {
        await tween(_anim, { rotate: 1 }, 600, "easeOutCubic")
          .onUpdate(() => {
            _controls.rotateLeft(0.008 * _anim.rotate),
              _controls.dollyIn(1 - 0.01 * _anim.rotate);
            let upRotation =
              _this.group.position.y < 0
                ? Math.max(0.012, -0.002 * _this.group.position.y)
                : 0.005;
            _controls.rotateUp(
              Math.mix(1, 0, 2 * Math.abs(_anim.rotate - 0.5)) * upRotation
            );
          })
          .promise(),
          await tween(_anim, { rotate: 0 }, 1e3, "easeOutCubic")
            .onUpdate(() => {
              _controls.rotateLeft(0.008 * _anim.rotate),
                _controls.dollyIn(1 - 0.01 * _anim.rotate),
                _controls.rotateUp(
                  -0.0025 * Math.mix(1, 0, 2 * Math.abs(_anim.rotate - 0.5))
                );
            })
            .promise();
      }),
      (this.bodyChange = async function () {
        await tween(_anim, { rotate: 1 }, 500, "easeOutCubic")
          .onUpdate(() => {
            _controls.rotateLeft(0.012 * _anim.rotate);
            let upRotation =
              _this.group.position.y < 0
                ? Math.max(0.012, -0.002 * _this.group.position.y)
                : 0.005;
            _controls.rotateUp(
              Math.mix(1, 0, 2 * Math.abs(_anim.rotate - 0.5)) * upRotation
            );
          })
          .promise(),
          await tween(_anim, { rotate: 0 }, 1e3, "easeOutCubic")
            .onUpdate(() => {
              _controls.rotateLeft(0.012 * _anim.rotate),
                _controls.rotateUp(
                  -0.00225 * Math.mix(1, 0, 2 * Math.abs(_anim.rotate - 0.5))
                );
            })
            .promise();
      }),
      (this.resetTarget = function () {
        _this.isTargetEngine = !1;
        const target = _this.group.initialTarget;
        (Car.ENGINE_OFFSET = 0),
          tween(_this.group.target, { y: target.y }, 1500, "easeInOutCubic");
      }),
      (this.rotateLeft = function (angle) {
        _controls.enabled && _controls.rotateLeft(angle);
      }),
      (this.stopRotateLeft = function () {
        _controls.stopRotation();
      });
  }, "singleton"),
  (window.Orbit = function (object, domElement) {
    function getAutoRotationAngle() {
      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    function dollyIn(dollyScale) {
      scale /= dollyScale;
    }
    function dollyOut(dollyScale) {
      scale *= dollyScale;
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY),
        rotateDelta.subVectors(rotateEnd, rotateStart);
      var element =
        scope.domElement === document
          ? scope.domElement.body
          : scope.domElement;
      rotateLeft(
        ((2 * Math.PI * rotateDelta.x) / element.clientWidth) *
          scope.rotateSpeed
      ),
        rotateUp(
          ((2 * Math.PI * rotateDelta.y) / element.clientHeight) *
            scope.rotateSpeed
        ),
        rotateStart.copy(rotateEnd),
        scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY),
        dollyDelta.subVectors(dollyEnd, dollyStart),
        dollyDelta.y > 0
          ? dollyIn(getZoomScale())
          : dollyDelta.y < 0 && dollyOut(getZoomScale()),
        dollyStart.copy(dollyEnd),
        scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY),
        panDelta.subVectors(panEnd, panStart),
        pan(panDelta.x, panDelta.y),
        panStart.copy(panEnd),
        scope.update(),
        scope.onChange && scope.onChange();
    }
    function handleMouseUp(event) {}
    function handleMouseWheel(event) {
      var delta = 0;
      void 0 !== event.wheelDelta
        ? (delta = event.wheelDelta)
        : void 0 !== event.detail && (delta = -event.detail),
        delta > 0
          ? dollyOut(getZoomScale())
          : delta < 0 && dollyIn(getZoomScale()),
        scope.update();
    }
    function handleKeyDown(event) {
      switch (event.keyCode) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed), scope.update();
          break;
        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed), scope.update();
          break;
        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0), scope.update();
          break;
        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0), scope.update();
      }
    }
    function handleTouchStartRotate(event) {
      rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    }
    function handleTouchStartDolly(event) {
      var dx = event.touches[0].pageX - event.touches[1].pageX,
        dy = event.touches[0].pageY - event.touches[1].pageY,
        distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartPan(event) {
      panStart.set(event.touches[0].pageX, event.touches[0].pageY);
    }
    function handleTouchMoveRotate(event) {
      rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY),
        rotateDelta.subVectors(rotateEnd, rotateStart);
      var element =
        scope.domElement === document
          ? scope.domElement.body
          : scope.domElement;
      rotateLeft(
        ((2 * Math.PI * rotateDelta.x) / element.clientWidth) *
          scope.rotateSpeed
      ),
        rotateUp(
          ((2 * Math.PI * rotateDelta.y) / element.clientHeight) *
            scope.rotateSpeed
        ),
        rotateStart.copy(rotateEnd),
        scope.update();
    }
    function handleTouchMoveDolly(event) {
      var dx = event.touches[0].pageX - event.touches[1].pageX,
        dy = event.touches[0].pageY - event.touches[1].pageY,
        distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance),
        dollyDelta.subVectors(dollyEnd, dollyStart),
        dollyDelta.y > 0
          ? dollyOut(getZoomScale())
          : dollyDelta.y < 0 && dollyIn(getZoomScale()),
        dollyStart.copy(dollyEnd),
        scope.update();
    }
    function handleTouchMovePan(event) {
      panEnd.set(event.touches[0].pageX, event.touches[0].pageY),
        panDelta.subVectors(panEnd, panStart),
        pan(panDelta.x, panDelta.y),
        panStart.copy(panEnd),
        scope.update();
    }
    function handleTouchEnd(event) {}
    function onMouseDown(event) {
      if (!1 !== scope.enabled) {
        if (
          (event.preventDefault(), event.button === scope.mouseButtons.ORBIT)
        ) {
          if (!1 === scope.enableRotate) return;
          handleMouseDownRotate(event), (state = STATE.ROTATE);
        } else if (event.button === scope.mouseButtons.ZOOM) {
          if (!1 === scope.enableZoom) return;
          handleMouseDownDolly(event), (state = STATE.DOLLY);
        } else if (event.button === scope.mouseButtons.PAN) {
          if (!1 === scope.enablePan) return;
          handleMouseDownPan(event), (state = STATE.PAN);
        }
        state !== STATE.NONE &&
          (document.addEventListener("mousemove", onMouseMove, !1),
          document.addEventListener("mouseup", onMouseUp, !1));
      }
    }
    function onMouseMove(event) {
      if (!1 !== scope.enabled)
        if ((event.preventDefault(), state === STATE.ROTATE)) {
          if (!1 === scope.enableRotate) return;
          handleMouseMoveRotate(event);
        } else if (state === STATE.DOLLY) {
          if (!1 === scope.enableZoom) return;
          handleMouseMoveDolly(event);
        } else if (state === STATE.PAN) {
          if (!1 === scope.enablePan) return;
          handleMouseMovePan(event);
        }
    }
    function onMouseUp(event) {
      (state = STATE.NONE),
        !1 !== scope.enabled &&
          (handleMouseUp(event),
          document.removeEventListener("mousemove", onMouseMove, !1),
          document.removeEventListener("mouseup", onMouseUp, !1),
          scope.onChange && scope.onChange());
    }
    function onMouseWheel(event) {
      !1 === scope.enabled ||
        !1 === scope.enableZoom ||
        (state !== STATE.NONE && state !== STATE.ROTATE) ||
        (event.preventDefault(),
        event.stopPropagation(),
        handleMouseWheel(event),
        scope.onChange && scope.onChange());
    }
    function onKeyDown(event) {
      !1 !== scope.enabled &&
        !1 !== scope.enableKeys &&
        !1 !== scope.enablePan &&
        handleKeyDown(event);
    }
    function onTouchStart(event) {
      if (!1 !== scope.enabled) {
        switch (
          (Tests.isPhone() && (scope.timeTochStart = performance.now()),
          event.touches.length)
        ) {
          case 1:
            if (!1 === scope.enableRotate) return;
            handleTouchStartRotate(event), (state = STATE.TOUCH_ROTATE);
            break;
          case 2:
            if (!1 === scope.enableZoom) return;
            handleTouchStartDolly(event), (state = STATE.TOUCH_DOLLY);
            break;
          case 3:
            if (!1 === scope.enablePan) return;
            handleTouchStartPan(event), (state = STATE.TOUCH_PAN);
            break;
          default:
            state = STATE.NONE;
        }
        STATE.NONE;
      }
    }
    function onTouchMove(event) {
      if (!1 !== scope.enabled)
        switch (
          (event.preventDefault(),
          event.stopPropagation(),
          event.touches.length)
        ) {
          case 1:
            if (!1 === scope.enableRotate) return;
            if (state !== STATE.TOUCH_ROTATE) return;
            handleTouchMoveRotate(event);
            break;
          case 2:
            if (!1 === scope.enableZoom) return;
            if (state !== STATE.TOUCH_DOLLY) return;
            handleTouchMoveDolly(event);
            break;
          case 3:
            if (!1 === scope.enablePan) return;
            if (state !== STATE.TOUCH_PAN) return;
            handleTouchMovePan(event);
            break;
          default:
            state = STATE.NONE;
        }
    }
    function onTouchEnd(event) {
      (state = STATE.NONE),
        !1 !== scope.enabled &&
          (Tests.isPhone() &&
            performance.now() - scope.timeTochStart < 250 &&
            Car.instance().changePresetMobile(
              (Config.CURRENT_PRESET + 1) % Config.NUM_COLOR_PRESETS
            ),
          handleTouchEnd(event),
          scope.onChange && scope.onChange());
    }
    function onContextMenu(event) {}
    const _this = this;
    (this.object = object),
      (this.domElement = void 0 !== domElement ? domElement : document),
      (this.enabled = !0),
      (this.target = new Vector3()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !0),
      (this.dampingFactor = 0.1),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 0.1),
      (this.enablePan = !0),
      (this.keyPanSpeed = 7),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.enableKeys = !1),
      (this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }),
      (this.mouseButtons = { ORBIT: 0, ZOOM: 2, PAN: 1 }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.timeTochStart = 0),
      (this.getPolarAngle = function () {
        return spherical.phi;
      }),
      (this.getAzimuthalAngle = function () {
        return spherical.theta;
      }),
      (this.reset = function () {
        scope.target.copy(scope.target0),
          scope.object.position.copy(scope.position0),
          (scope.object.zoom = scope.zoom0),
          scope.object.updateProjectionMatrix(),
          scope.update(),
          (state = STATE.NONE);
      }),
      (this.update = (function () {
        var offset = new Vector3(),
          quat = new Quaternion().setFromUnitVectors(
            object.up,
            new Vector3(0, 1, 0)
          ),
          quatInverse = quat.clone().inverse(),
          lastPosition = new Vector3(),
          lastQuaternion = new Quaternion();
        return function update() {
          var position = scope.object.position;
          return (
            offset.copy(position).sub(scope.target),
            offset.applyQuaternion(quat),
            spherical.setFromVector3(offset),
            scope.autoRotate &&
              state === STATE.NONE &&
              rotateLeft(getAutoRotationAngle()),
            (spherical.theta += sphericalDelta.theta),
            (spherical.phi += sphericalDelta.phi),
            (spherical.theta = Math.max(
              scope.minAzimuthAngle,
              Math.min(scope.maxAzimuthAngle, spherical.theta)
            )),
            (spherical.phi = Math.max(
              scope.minPolarAngle,
              Math.min(scope.maxPolarAngle, spherical.phi)
            )),
            spherical.makeSafe(),
            (spherical.radius *= scale),
            (spherical.radius = Math.max(
              scope.minDistance,
              Math.min(scope.maxDistance, spherical.radius)
            )),
            scope.target.add(panOffset),
            offset.setFromSpherical(spherical),
            offset.applyQuaternion(quatInverse),
            position.copy(scope.target).add(offset),
            scope.object.lookAt(scope.target),
            !0 === scope.enableDamping
              ? ((sphericalDelta.theta *= 1 - scope.dampingFactor),
                (sphericalDelta.phi *= 1 - scope.dampingFactor))
              : sphericalDelta.set(0, 0, 0),
            (scale = 1),
            panOffset.set(0, 0, 0),
            _this.onUpdate && _this.onUpdate(),
            !!(
              zoomChanged ||
              lastPosition.distanceToSquared(scope.object.position) > EPS ||
              8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS
            ) &&
              (lastPosition.copy(scope.object.position),
              lastQuaternion.copy(scope.object.quaternion),
              (zoomChanged = !1),
              !0)
          );
        };
      })()),
      (this.dispose = function () {
        scope.domElement.removeEventListener("contextmenu", onContextMenu, !1),
          scope.domElement.removeEventListener("mousedown", onMouseDown, !1),
          scope.domElement.removeEventListener("mousewheel", onMouseWheel, !1),
          scope.domElement.removeEventListener(
            "MozMousePixelScroll",
            onMouseWheel,
            !1
          ),
          scope.domElement.removeEventListener("touchstart", onTouchStart, !1),
          scope.domElement.removeEventListener("touchend", onTouchEnd, !1),
          scope.domElement.removeEventListener("touchmove", onTouchMove, !1),
          document.removeEventListener("mousemove", onMouseMove, !1),
          document.removeEventListener("mouseup", onMouseUp, !1),
          window.removeEventListener("keydown", onKeyDown, !1);
      });
    var scope = this,
      STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_DOLLY: 4,
        TOUCH_PAN: 5,
      },
      state = STATE.NONE,
      EPS = 1e-6,
      spherical = new Spherical(),
      sphericalDelta = new Spherical(),
      scale = 1,
      panOffset = new Vector3(),
      zoomChanged = !1,
      rotateStart = new Vector2(),
      rotateEnd = new Vector2(),
      rotateDelta = new Vector2(),
      panStart = new Vector2(),
      panEnd = new Vector2(),
      panDelta = new Vector2(),
      dollyStart = new Vector2(),
      dollyEnd = new Vector2(),
      dollyDelta = new Vector2();
    (this.rotateLeft = rotateLeft),
      (this.stopRotation = function stopRotation() {
        (sphericalDelta.theta = 0), (sphericalDelta.phi = 0);
      }),
      (this.rotateUp = rotateUp);
    var panLeft = (function () {
        var v = new Vector3();
        return function panLeft(distance, objectMatrix) {
          v.setFromMatrixColumn(objectMatrix, 0),
            v.multiplyScalar(-distance),
            panOffset.add(v);
        };
      })(),
      panUp = (function () {
        var v = new Vector3();
        return function panUp(distance, objectMatrix) {
          v.setFromMatrixColumn(objectMatrix, 1),
            v.multiplyScalar(distance),
            panOffset.add(v);
        };
      })(),
      pan = (function () {
        var offset = new Vector3();
        return function pan(deltaX, deltaY) {
          var element =
              scope.domElement === document
                ? scope.domElement.body
                : scope.domElement,
            position = scope.object.position;
          offset.copy(position).sub(scope.target);
          var targetDistance = offset.length();
          (targetDistance *= Math.tan(
            ((scope.object.fov / 2) * Math.PI) / 180
          )),
            panLeft(
              (2 * deltaX * targetDistance) / element.clientHeight,
              scope.object.matrix
            ),
            panUp(
              (2 * deltaY * targetDistance) / element.clientHeight,
              scope.object.matrix
            );
        };
      })();
    (this.dollyIn = dollyIn),
      (this.dollyOut = dollyOut),
      scope.domElement.addEventListener("contextmenu", onContextMenu, !1),
      scope.domElement.addEventListener("mousedown", onMouseDown, !1),
      scope.domElement.addEventListener("mousewheel", onMouseWheel, !1),
      scope.domElement.addEventListener(
        "MozMousePixelScroll",
        onMouseWheel,
        !1
      ),
      scope.domElement.addEventListener("touchstart", onTouchStart, !1),
      scope.domElement.addEventListener("touchend", onTouchEnd, !1),
      scope.domElement.addEventListener("touchmove", onTouchMove, !1),
      window.addEventListener("keydown", onKeyDown, !1),
      (this.reattach = function (domElement) {
        (scope.domElement = domElement),
          scope.domElement.addEventListener("contextmenu", onContextMenu, !1),
          scope.domElement.addEventListener("mousedown", onMouseDown, !1),
          scope.domElement.addEventListener("mousewheel", onMouseWheel, !1),
          scope.domElement.addEventListener(
            "MozMousePixelScroll",
            onMouseWheel,
            !1
          ),
          scope.domElement.addEventListener("touchstart", onTouchStart, !1),
          scope.domElement.addEventListener("touchend", onTouchEnd, !1),
          scope.domElement.addEventListener("touchmove", onTouchMove, !1),
          window.addEventListener("keydown", onKeyDown, !1);
      }),
      this.update();
  }),
  Class(function CarControls(_input, _group) {
    function initInput() {
      _this.initClass(CarControlsKeys), _this.initClass(CarControlsGamepad);
    }
    function update() {
      updateInput(),
        updateSpeed(),
        updateTurn(),
        updateEase(),
        updatePosition(),
        updateVelocity();
    }
    function updateInput() {
      _this.input.master.copy(_this.input.keys),
        _this.input.master.add(_this.input.gamepad),
        _this.input.master.add(_this.input.joystick),
        _this.input.master.add(_this.input.intro),
        _this.input.master.divideScalar(
          Math.max(1, _this.input.master.length())
        );
    }
    function updateSpeed() {
      _this.speed.target = _this.input.master.y;
      let dir = Math.sign(_this.input.master.y) < 0 ? -1 : 1;
      _this.speed.target =
        dir > 0
          ? Math.max(
              _this.speed.target,
              0.5 * Math.abs(_this.input.master.x) * dir
            )
          : Math.min(
              _this.speed.target,
              0.5 * Math.abs(_this.input.master.x) * dir
            );
    }
    function updateTurn() {
      _this.turn.target = -_this.input.master.x;
    }
    function updateEase() {
      (_this.speed.ease += 0.05 * (_this.speed.target - _this.speed.ease)),
        (_this.speed.value += 0.05 * (_this.speed.ease - _this.speed.value)),
        (_this.turn.ease += 0.2 * (_this.turn.target - _this.turn.ease)),
        (_this.turn.value += 0.2 * (_this.turn.ease - _this.turn.value));
    }
    function updatePosition() {
      (_this.rotation += _this.turn.value * TURN * _this.speed.value),
        (_this.position.x +=
          Math.sin(_this.rotation) * _this.speed.value * SPEED),
        (_this.position.y +=
          Math.cos(_this.rotation) * _this.speed.value * SPEED);
    }
    function updateVelocity() {
      (_this.velocity.turn = _this.rotation - _this.turn.last),
        (_this.velocity.speed = _this.speed.value - _this.speed.last),
        (_this.turn.last = _this.rotation),
        (_this.speed.last = _this.speed.value);
    }
    Inherit(this, Component);
    const _this = this,
      TURN = 0.032,
      SPEED = 0.11;
    (_this.input = {
      keys: new Vector2(),
      gamepad: new Vector2(),
      joystick: new Vector2(),
      intro: new Vector2(),
      master: new Vector2(),
    }),
      (CarControls.input = _this.input),
      (_this.speed = { target: 0, ease: 0, value: 0, last: 0 }),
      (_this.turn = { target: 0, ease: 0, value: 0, last: 0 }),
      (_this.velocity = { speed: 0, turn: 0 }),
      (_this.rotation = 0),
      (_this.position = new Vector2()),
      initInput(),
      _this.startRender(update);
  }),
  Class(function CarControlsGamepad() {
    function update() {
      const gamepads = navigator.getGamepads();
      if (!gamepads[0]) return;
      const gamepad = gamepads[0],
        x =
          gamepad.axes[0] *
          Math.smoothStep(0.15, 0.25, Math.abs(gamepad.axes[0])),
        y =
          -gamepad.axes[1] *
          Math.smoothStep(0.15, 0.25, Math.abs(gamepad.axes[1]));
      _this.parent.input.gamepad.set(x, y);
    }
    Inherit(this, Component);
    const _this = this;
    navigator.getGamepads && _this.startRender(update);
  }),
  Class(function CarControlsKeys() {
    function update() {
      const x = _keys.right - _keys.left,
        y = _keys.up - _keys.down;
      _this.parent.input.keys.set(x, y);
    }
    function addHandlers() {
      _this.events.sub(KeyboardUtil.DOWN, keydown),
        _this.events.sub(KeyboardUtil.UP, keyup),
        _this.events.sub(Events.VISIBILITY, browserVisibility);
    }
    function keydown(e) {
      ("ArrowUp" !== e.key && "Up" !== e.key && "w" !== e.key) ||
        (_keys.up = 1),
        ("ArrowRight" !== e.key && "Right" !== e.key && "d" !== e.key) ||
          (_keys.right = 1),
        ("ArrowDown" !== e.key && "Down" !== e.key && "s" !== e.key) ||
          (_keys.down = 1),
        ("ArrowLeft" !== e.key && "Left" !== e.key && "a" !== e.key) ||
          (_keys.left = 1);
    }
    function keyup(e) {
      ("ArrowUp" !== e.key && "Up" !== e.key && "w" !== e.key) ||
        (_keys.up = 0),
        ("ArrowRight" !== e.key && "Right" !== e.key && "d" !== e.key) ||
          (_keys.right = 0),
        ("ArrowDown" !== e.key && "Down" !== e.key && "s" !== e.key) ||
          (_keys.down = 0),
        ("ArrowLeft" !== e.key && "Left" !== e.key && "a" !== e.key) ||
          (_keys.left = 0);
    }
    function browserVisibility() {
      (_keys.right = 0), (_keys.left = 0), (_keys.up = 0), (_keys.down = 0);
    }
    Inherit(this, Component);
    const _this = this;
    let _keys = { right: 0, left: 0, up: 0, down: 0 };
    _this.startRender(update), addHandlers();
  }),
  Class(function CarEngines(_input, _group) {
    function initShader() {
      (_shader = _this.initClass(Shader, "CarEngine", {
        tAO: { value: null, ignoreUIL: !0 },
        tMatCap: { value: null },
        tEnv: { value: null },
        uColor1: { value: new Color() },
        uColor2: { value: new Color() },
        uColor3: Colors.instance().SHADER[0],
        uColor4: Colors.instance().SHADER[1],
        uColor5: Colors.instance().SHADER[2],
        uVisible: { value: 0 },
        transparent: !0,
        side: Shader.DOUBLE_SIDE,
      })),
        ShaderUIL.add(_shader, _group);
    }
    async function initEngines() {
      await Promise.all(Data.POWERTRAINS.map(addEngine));
    }
    async function addEngine(data, i) {
      if (!data.enabled) return;
      const geometry = await GeomThread.loadGeometry(`engines/${data.perma}`),
        mesh = new Mesh(geometry, _shader);
      (mesh.visibleValue = 0),
        _this.add(mesh),
        data.default && (_currentIndex = i),
        hideEngine(mesh),
        (_engines[i] = mesh);
      const aoTexture = Utils3D.getTexture(
        `assets/images/engines/ao/${data.perma}.jpg`
      );
      mesh.onBeforeRender = () => {
        _shader.uniforms.tAO.value = aoTexture;
        const diff = (mesh.isVisible ? 1 : 0) - mesh.visibleValue;
        (mesh.visibleValue += diff * (diff > 0 ? 0.01 : 0.03)),
          mesh.visibleValue < 0.01
            ? ((mesh.visibleValue = 0), (mesh.visible = !1))
            : (mesh.visible = !0),
          (_shader.uniforms.uVisible.value = mesh.visibleValue);
      };
    }
    function showEngine(mesh) {
      mesh.isVisible = !0;
    }
    async function hideEngine(mesh) {
      mesh.isVisible = !1;
    }
    Inherit(this, Object3D);
    const _this = this;
    let _shader;
    const _engines = [];
    let _currentIndex = 0;
    !(async function () {
      initShader(), await initEngines();
    })(),
      (this.change = function (index) {
        (index = Data.POWERTRAINS.indexOf(Meta.POWERTRAINS[index])),
          _currentIndex !== index &&
            (hideEngine(_engines[_currentIndex]),
            showEngine(_engines[(_currentIndex = index)]));
      }),
      (this.show = function () {
        let selectedValue = Configuration.powertrain,
          choiceIndex = 0;
        Meta.POWERTRAINS.forEach((data, i) => {
          selectedValue && selectedValue === data.code
            ? (choiceIndex = i)
            : !selectedValue &&
              data.presets &&
              data.presets.includes(Configuration.preset) &&
              (choiceIndex = i);
        }),
          showEngine(
            _engines[Data.POWERTRAINS.indexOf(Meta.POWERTRAINS[choiceIndex])]
          ),
          (_this.group.visible = !0);
      }),
      (this.hide = async function () {
        _engines.forEach((mesh) => hideEngine(mesh)),
          await _this.wait(1e3),
          (_this.group.visible = !1);
      });
  }),
  Class(function CarFloor(_mesh, _shader, _input, _group) {
    function loop() {
      Car.CONTROLS &&
        ((_mesh.rotation.z = -Car.CONTROLS.rotation),
        _center.set(Car.CONTROLS.position.x, 0, -Car.CONTROLS.position.y));
    }
    Inherit(this, Component);
    const _this = this;
    var _center = new Vector3(),
      TIME = { value: 0, ignoreUIl: !0 };
    _shader.addUniforms({
      uCenterPosition: { type: "v3", value: _center, ignoreUIL: !0 },
      uGrid: { value: 60 },
      uDispAmount: { value: 1 },
      tMap: { value: null, getTexture: Utils3D.getRepeatTexture },
      uSpeed: Car.SPEED,
      uTime: TIME,
      uColor: Colors.instance().SHADER[0],
    }),
      (_mesh.onBeforeRender = loop),
      _this.startRender((t, delta) => {
        Car.SPEED &&
          (TIME.value +=
            0.001 * delta * (0.4 + 0.8 * Math.abs(Car.SPEED.value)));
      });
  }),
  Class(
    function CarProductHotspots() {
      function initShader() {
        _shader = _this.initClass(Shader, "CarProductHotspot", {
          uActive: { value: 0 },
          uAlpha: { value: 0 },
          depthTest: !1,
          depthWrite: !1,
          transparent: !0,
          blending: Shader.ADDITIVE_BLENDING,
          side: Shader.DOUBLE_SIDE,
        });
      }
      function initHotspots() {
        Data.PRODUCTS.forEach(addHotspot);
      }
      function addHotspot(d) {
        const config = Config.PRODUCT_DATA[d.perma],
          mesh = new Mesh(World.PLANE, _shader);
        (mesh.frustumCulled = !1),
          (mesh.renderOrder = 110),
          (mesh.visible = !1),
          _this.add(mesh),
          _meshes.push(mesh),
          (_hotspots[d.perma] = mesh),
          (mesh.perma = d.perma),
          mesh.position.copy(config.position),
          mesh.scale.setScalar(0.3),
          (mesh.uActiveTarget = 0),
          (mesh.uActive = 0),
          (mesh.onBeforeRender = () => {
            (mesh.uActive += 0.1 * (mesh.uActiveTarget - mesh.uActive)),
              (_shader.uniforms.uActive.value = mesh.uActive);
          });
      }
      function animateIn() {
        Meta.PRODUCTS.forEach((data) => {
          _hotspots[data.perma].visible = !0;
        }),
          _shader.tween("uAlpha", 1, 1e3, "easeOutCubic");
      }
      async function animateOut() {
        await _shader.tween("uAlpha", 0, 1e3, "easeOutCubic").promise(),
          _meshes.forEach((mesh) => {
            (mesh.visible = !1), (mesh.uActiveTarget = 0), (mesh.uActive = 0);
          });
      }
      function loop() {
        _this.isActive &&
          _camera &&
          (_quat.copy(_camera._parent.quaternion),
          _quat2.setFromAxisAngle(_vec3, -Car.CONTROLS_ROTATION),
          _quat2.multiply(_quat),
          _meshes.forEach((mesh) => {
            mesh.quaternion.copy(_quat2);
          }));
      }
      function addHandlers() {
        _this.events.sub(UISection.CHOICE_CHANGE, choiceChange),
          _this.events.sub(UISection.SECTION_CHANGE, sectionChange),
          _this.events.sub(Car.DRIVING, carDriving),
          _this.events.sub(UI.FADE, fade),
          _this.events.sub(CarProductHotspots.HOVER, performHover);
      }
      function carDriving({ driving: driving }) {
        _this.isActive &&
          (_this.flag("driving", driving),
          _shader.tween("uAlpha", driving ? 0 : 1, 500, "easeOutSine"));
      }
      function fade({ hide: hide }) {
        _this.isActive &&
          (_this.flag("driving", hide),
          _shader.tween("uAlpha", hide ? 0 : 1, 600, "easeOutSine"));
      }
      async function choiceChange({ index: index, data: data, total: total }) {
        _this.isActive &&
          (_activeHotspot && (_activeHotspot.uActiveTarget = 0),
          ((_activeHotspot = _hotspots[data.perma]).uActiveTarget = 1));
      }
      function sectionChange({ index: index, data: data }) {
        "customise" === data.perma
          ? (_this.isActive || animateIn(), (_this.isActive = !0))
          : (_this.isActive && animateOut(), (_this.isActive = !1));
      }
      function hover(e) {
        Customise.instance().isPaused &&
          3 === UI.instance().UISectionActive() &&
          e.mesh !== _activeHotspot &&
          (CarCamera.instance().fading ||
            _this.events.fire(CarProductHotspots.HOVER, {
              action: e.action,
              perma: e.mesh.perma,
            }));
      }
      function performHover(e) {
        if (!Customise.instance().isPaused) return;
        if (3 !== UI.instance().UISectionActive()) return;
        const mesh = _hotspots[e.perma];
        switch (e.action) {
          case "over":
            mesh.uActiveTarget = 0.3;
            break;
          case "out":
            mesh.uActiveTarget = 0;
        }
      }
      function click(e) {
        Customise.instance().isPaused &&
          (_this.flag("driving") ||
            _this.events.fire(Car.PRODUCT_CLICK, { perma: e.mesh.perma }));
      }
      Inherit(this, Object3D);
      const _this = this;
      let _shader, _camera, _interaction;
      const _hotspots = {},
        _meshes = [];
      let _activeHotspot;
      const _quat = new Quaternion(),
        _quat2 = new Quaternion(),
        _vec3 = new Vector3(0, 1, 0);
      initShader(),
        initHotspots(),
        addHandlers(),
        _this.startRender(loop),
        (this.useCamera = function (camera) {
          (_camera = camera),
            (_interaction = Interaction3D.find(camera)).add(
              _meshes,
              hover,
              click
            );
        });
    },
    () => {
      CarProductHotspots.HOVER = "event_hotspot_hover";
    }
  ),
  Class(function CarProductLine() {
    function initMesh() {
      (_lineGeometry = _this.initClass(LineGeometry, { points: _points })),
        (_shader = _this.initClass(Shader, "CarProductLine", {
          uColor: Colors.instance().SHADER[0],
          uAlpha: { value: 0 },
          uAlpha2: { value: 1 },
          transparent: !0,
          depthTest: !1,
          depthWrite: !1,
          blending: Shader.ADDITIVE_BLENDING,
        })),
        (_mesh = new Mesh(_lineGeometry.geometry, _shader)),
        (_lineGeometry.geometry.attributes.position.dynamic = !0),
        (_mesh.renderOrder = 102),
        (_mesh.visible = !1),
        (_mesh.frustumCulled = !1),
        _this.add(_mesh),
        (_mesh.onBeforeRender = loop);
    }
    function updateTarget() {
      const size = Config.RADIUS.value,
        angle = (_productIndex - 0.5 * (_productTotal - 1)) * (35 / size),
        x = size * Math.cos(angle),
        y = size * Math.sin(angle);
      _point2D.set(Stage.width / 2 + x, Stage.height / 2 + y);
    }
    function loop() {
      _projection &&
        (_this.group.worldToLocal(
          _pointB.copy(_projection.unproject(_point2D, 10))
        ),
        (_points[0] = 1 * _pointA.x + 0 * _pointB.x),
        (_points[1] = 1 * _pointA.y + 0 * _pointB.y),
        (_points[2] = 1 * _pointA.z + 0 * _pointB.z),
        (_points[3] = 0.9 * _pointA.x + 0.1 * _pointB.x),
        (_points[4] = 0.9 * _pointA.y + 0.1 * _pointB.y),
        (_points[5] = 0.9 * _pointA.z + 0.1 * _pointB.z),
        (_points[6] = (_pointA.x + _pointB.x) / 2),
        (_points[7] = (_pointA.y + _pointB.y) / 2),
        (_points[8] = (_pointA.z + _pointB.z) / 2),
        (_points[9] = 0.1 * _pointA.x + 0.9 * _pointB.x),
        (_points[10] = 0.1 * _pointA.y + 0.9 * _pointB.y),
        (_points[11] = 0.1 * _pointA.z + 0.9 * _pointB.z),
        (_points[12] = 0 * _pointA.x + 1 * _pointB.x),
        (_points[13] = 0 * _pointA.y + 1 * _pointB.y),
        (_points[14] = 0 * _pointA.z + 1 * _pointB.z),
        _lineGeometry.update(!0));
    }
    function addHandlers() {
      _this.events.sub(UISection.CHOICE_CHANGE, choiceChange),
        _this.events.sub(UISection.SECTION_CHANGE, sectionChange),
        _this.events.sub(Config.RADIUS_UPDATE, radiusUpdate),
        _this.events.sub(Car.DRIVING, carDriving),
        _this.events.sub(UI.FADE, fade);
    }
    function carDriving({ driving: driving }) {
      _this.isActive &&
        _shader.tween("uAlpha", driving ? 0 : 1, 500, "easeOutSine");
    }
    function fade({ hide: hide }) {
      _this.isActive &&
        _shader.tween(
          "uAlpha2",
          hide ? 0 : 1,
          400,
          hide ? "easeOutQuint" : "easeInOutCubic",
          hide ? 0 : 150
        );
    }
    async function choiceChange({
      index: index,
      data: data,
      total: total,
      initial: initial,
    }) {
      _this.isActive &&
        (initial ||
          (await _shader.tween("uAlpha", 0, 300, "easeOutSine").promise()),
        (_productTotal = total),
        (_productIndex = index),
        updateTarget(),
        _pointA.copy(Config.PRODUCT_DATA[data.perma].position),
        _shader.tween("uAlpha", 1, 1e3, "easeInOutSine", initial ? 1e3 : 0));
    }
    function sectionChange({ index: index, data: data }) {
      "customise" === data.perma
        ? (_this.isActive || animateIn(), (_this.isActive = !0))
        : (_this.isActive && animateOut(), (_this.isActive = !1));
    }
    function animateIn() {
      (_mesh.visible = !0),
        _shader.tween("uAlpha", 1, 1e3, "easeInOutSine", 1e3);
    }
    function animateOut() {
      _shader.tween("uAlpha", 0, 500, "easeOutSine", (_) => {
        _mesh.visible = !1;
      });
    }
    function radiusUpdate() {
      updateTarget();
    }
    Inherit(this, Object3D);
    const _this = this;
    let _shader,
      _mesh,
      _projection,
      _productIndex = 0,
      _productTotal = 11;
    const _point2D = new Vector2(),
      _pointA = new Vector3(),
      _pointB = new Vector3(),
      _points = [0, 0, 0, 0, 0, 0, 0.5, 0.5, 0.5, 1, 1, 1, 1, 1, 1];
    let _lineGeometry;
    initMesh(),
      addHandlers(),
      (this.useCamera = function (camera) {
        _projection = ScreenProjection.find(camera);
      });
  }),
  Class(function CarProductLineButton() {
    function initMesh() {
      (_lineGeometry = _this.initClass(LineGeometry, { points: _points })),
        (_shader = _this.initClass(Shader, "CarProductLineButton", {
          uColor: Colors.instance().SHADER[0],
          uAlpha: { value: 0 },
          uAlpha2: { value: 1 },
          transparent: !0,
          depthTest: !1,
          depthWrite: !1,
          blending: Shader.ADDITIVE_BLENDING,
        })),
        (_mesh = new Mesh(_lineGeometry.geometry, _shader)),
        (_lineGeometry.geometry.attributes.position.dynamic = !0),
        (_mesh.renderOrder = 102),
        (_mesh.visible = !1),
        (_mesh.frustumCulled = !1),
        _this.add(_mesh),
        (_mesh.onBeforeRender = loop);
    }
    function updateTarget() {
      _point2D.set(Stage.width / 2, 0.82 * Stage.height - 1);
    }
    function loop() {
      _projection &&
        (_this.group.worldToLocal(
          _pointB.copy(_projection.unproject(_point2D, 10))
        ),
        (_points[0] = 1 * _pointA.x + 0 * _pointB.x),
        (_points[1] = 1 * _pointA.y + 0 * _pointB.y),
        (_points[2] = 1 * _pointA.z + 0 * _pointB.z),
        (_points[3] = 0.75 * _pointA.x + 0.25 * _pointB.x),
        (_points[4] = 0.75 * _pointA.y + 0.25 * _pointB.y),
        (_points[5] = 0.75 * _pointA.z + 0.25 * _pointB.z),
        (_points[6] = (_pointA.x + _pointB.x) / 2),
        (_points[7] = (_pointA.y + _pointB.y) / 2),
        (_points[8] = (_pointA.z + _pointB.z) / 2),
        (_points[9] = 0.25 * _pointA.x + 0.75 * _pointB.x),
        (_points[10] = 0.25 * _pointA.y + 0.75 * _pointB.y),
        (_points[11] = 0.25 * _pointA.z + 0.75 * _pointB.z),
        (_points[12] = 0 * _pointA.x + 1 * _pointB.x),
        (_points[13] = 0 * _pointA.y + 1 * _pointB.y),
        (_points[14] = 0 * _pointA.z + 1 * _pointB.z),
        _lineGeometry.update(!0));
    }
    function addHandlers() {
      _this.events.sub(UISection.CHOICE_CHANGE, choiceChange),
        _this.events.sub(UISection.SECTION_CHANGE, sectionChange),
        _this.events.sub(Config.RADIUS_UPDATE, radiusUpdate),
        _this.events.sub(Car.DRIVING, carDriving),
        _this.events.sub(UI.FADE, fade),
        _this.events.sub(UISection.OPEN_CUSTOMISE, animateOut),
        _this.events.sub(UISection.CLOSE_CUSTOMISE, animateIn);
    }
    function carDriving({ driving: driving }) {
      _this.isActive &&
        _shader.tween("uAlpha", driving ? 0 : 1, 500, "easeOutSine");
    }
    function fade({ hide: hide }) {
      _this.isActive &&
        _shader.tween(
          "uAlpha2",
          hide ? 0 : 1,
          400,
          hide ? "easeOutQuint" : "easeInOutCubic",
          hide ? 0 : 150
        );
    }
    async function choiceChange({ index: index, data: data, total: total }) {
      _this.isActive &&
        (await _shader.tween("uAlpha", 0, 300, "easeOutSine").promise(),
        (_productTotal = total),
        (_productIndex = index),
        updateTarget(),
        _pointA.copy(Config.PRODUCT_DATA[data.perma].position),
        await _shader.tween("uAlpha", 1, 1e3, "easeInOutSine", 500).promise());
    }
    function sectionChange({ index: index, data: data }) {
      "customise" === data.perma
        ? (_this.isActive || animateIn(), (_this.isActive = !0))
        : (_this.isActive && animateOut(), (_this.isActive = !1));
    }
    function animateIn() {
      (_mesh.visible = !0),
        _shader.tween("uAlpha", 1, 1e3, "easeInOutSine", 1e3);
    }
    function animateOut() {
      _shader.tween("uAlpha", 0, 500, "easeOutSine", (_) => {
        _mesh.visible = !1;
      });
    }
    function radiusUpdate() {
      updateTarget();
    }
    Inherit(this, Object3D);
    const _this = this;
    let _shader,
      _mesh,
      _projection,
      _productIndex = 0,
      _productTotal = 11;
    const _point2D = new Vector2(),
      _pointA = new Vector3(),
      _pointB = new Vector3(),
      _points = [0, 0, 0, 0, 0, 0, 0.5, 0.5, 0.5, 1, 1, 1, 1, 1, 1];
    let _lineGeometry;
    initMesh(),
      addHandlers(),
      (this.useCamera = function (camera) {
        _projection = ScreenProjection.find(camera);
      });
  }),
  Class(function CarProducts(_input, _group) {
    function initLines() {
      (_line = _this.initClass(CarProductLine)),
        (_lineButton = _this.initClass(CarProductLineButton));
    }
    function initHotpoints() {
      _hotspots = _this.initClass(CarProductHotspots);
    }
    function initShader() {
      (_shader = _this.initClass(Shader, "CarProductShader", {
        tAO: { value: null, ignoreUIL: !0 },
        tMatCap: { value: null },
        tEnv: { value: null },
        uVisible: { value: 0 },
        uColor1: { value: new Color(), ignoreUIL: !0 },
        uSelected: { value: 1 },
        transparent: !0,
        side: Shader.DOUBLE_SIDE,
      })),
        ShaderUIL.add(_shader, _group);
      for (let i = 0; i < Config.NUM_COLOR_PRESETS; i++)
        for (let j = 0; j < 3; j++)
          _input.addColor(`Preset${i + 1}color${j + 1}a`, new Color()),
            Config.PRESET_COLORS[i] || (Config.PRESET_COLORS[i] = []),
            (Config.PRESET_COLORS[i][j] = [
              _input.get(`Preset${i + 1}color${j + 1}a`),
            ]);
    }
    async function initProducts() {
      await Promise.all(Data.PRODUCTS.map(addMesh));
      let p = [],
        alternativeIndex = _products.length;
      for (let powertrain of Object.keys(Config.ALTERNATIVE_MODELS))
        for (let perma of Object.keys(Config.ALTERNATIVE_MODELS[powertrain]))
          Data.PRODUCTS.forEach((item, index) => {
            item.perma === perma &&
              p.push(
                addalternativeMesh(
                  item.perma,
                  Config.ALTERNATIVE_MODELS[powertrain][perma],
                  index,
                  alternativeIndex++,
                  powertrain
                )
              );
          });
      await Promise.all(p);
    }
    async function addalternativeMesh(
      perma,
      alternativePerma,
      productIndex,
      alternativeIndex,
      pt
    ) {
      const geometry = await GeomThread.loadGeometry(
          `products/${alternativePerma}`
        ),
        mesh = new Mesh(geometry, _shader);
      _this.add(mesh),
        (_products[alternativeIndex] = mesh),
        (_products[productIndex].alternative = { powertrain: pt, model: mesh }),
        (mesh.isSelected = 1),
        (mesh.color = new Color()),
        (mesh.color2 = new Color()),
        (mesh.renderOrder = Config.PRODUCT_DATA[perma].renderOrder || 0);
      const aoTexture = Utils3D.getTexture(
        `assets/images/products/ao/${alternativePerma}.jpg`
      );
      (mesh.onBeforeRender = () => {
        _shader.uniforms.tAO.value = aoTexture;
        const color1 =
          Config.PRESET_COLORS[_presetIndex][
            Config.PRODUCT_DATA[perma].colorIndex || 0
          ][0];
        mesh.color.set(color1),
          mesh.color2.lerp(mesh.color, 0.05),
          _shader.uniforms.uColor1.value.copy(mesh.color2);
        let selectedTarget;
        (selectedTarget = _this.isCustomise
          ? productIndex === _selectedIndex
            ? 1
            : productIndex === _hoveredIndex
            ? 0.75
            : 0
          : 1),
          (mesh.isSelected += 0.1 * (selectedTarget - mesh.isSelected)),
          (_shader.uniforms.uSelected.value = mesh.isSelected);
      }),
        _this.events.sub(CarProductHotspots.HOVER, function hoverProduct(e) {
          if (3 === UI.instance().UISectionActive() && e.perma === perma)
            switch (e.action) {
              case "over":
                _hoveredIndex = productIndex;
                break;
              case "out":
                _hoveredIndex = -1;
            }
        });
    }
    async function addMesh({ perma: perma }, i) {
      const geometry = await GeomThread.loadGeometry(`products/${perma}`),
        mesh = new Mesh(geometry, _shader);
      _this.add(mesh),
        (_products[i] = mesh),
        (mesh.isSelected = 1),
        (mesh.color = new Color()),
        (mesh.color2 = new Color()),
        (mesh.renderOrder = Config.PRODUCT_DATA[perma].renderOrder || 0);
      const aoTexture = Utils3D.getTexture(
        `assets/images/products/ao/${perma}.jpg`
      );
      (mesh.onBeforeRender = () => {
        _shader.uniforms.tAO.value = aoTexture;
        const color1 =
          Config.PRESET_COLORS[_presetIndex][
            Config.PRODUCT_DATA[perma].colorIndex || 0
          ][0];
        mesh.color.set(color1),
          mesh.color2.lerp(mesh.color, 0.05),
          _shader.uniforms.uColor1.value.copy(mesh.color2);
        let selectedTarget;
        (selectedTarget = _this.isCustomise
          ? i === _selectedIndex
            ? 1
            : i === _hoveredIndex
            ? 0.75
            : 0
          : 1),
          (mesh.isSelected += 0.1 * (selectedTarget - mesh.isSelected)),
          (_shader.uniforms.uSelected.value = mesh.isSelected);
      }),
        _this.events.sub(CarProductHotspots.HOVER, function hoverProduct(e) {
          if (3 === UI.instance().UISectionActive() && e.perma === perma)
            switch (e.action) {
              case "over":
                _hoveredIndex = i;
                break;
              case "out":
                _hoveredIndex = -1;
            }
        });
    }
    Inherit(this, Object3D);
    const _this = this;
    let _line,
      _lineButton,
      _hotspots,
      _shader,
      _presetIndex = 0,
      _hoveredIndex = 0,
      _selectedIndex = 0;
    const _products = [];
    (this.ready = Promise.create()),
      (async function () {
        await Data.ready(),
          initLines(),
          initHotpoints(),
          initShader(),
          await initProducts(),
          _this.ready.resolve();
      })(),
      (this.changePreset = function (index) {
        (_presetIndex = index),
          (Config.CURRENT_PRESET = index),
          Colors.instance().setShaderColors(!0);
      }),
      (this.changeActive = function (index) {
        (index = Data.PRODUCTS.indexOf(Meta.PRODUCTS[index])),
          (_selectedIndex = index);
      }),
      (this.useCamera = function (camera) {
        _line.useCamera(camera),
          _lineButton.useCamera(camera),
          _hotspots.useCamera(camera);
      }),
      (this.hide = async function () {
        (_this.isCustomise = !1),
          await _shader.tween("uVisible", 0, 1500, "easeOutCubic").promise(),
          (_this.group.visible = !1),
          _products.forEach((mesh) => (mesh.visible = !1));
      }),
      (this.show = function (delay = 0) {
        (_this.group.visible = !0),
          Meta.PRODUCTS.forEach((data) => {
            const index = Data.PRODUCTS.indexOf(data);
            index >= 0 &&
              (_products[index].alternative &&
              Configuration.powertrain ===
                _products[index].alternative.powertrain
                ? (_products[index].alternative.model.visible = !0)
                : (_products[index].visible = !0));
          }),
          _shader.tween("uVisible", 1, 2200, "easeOutSine", delay);
      }),
      (this.toPresets = function () {
        (_this.isCustomise = !1), _this.show();
      }),
      (this.toCustomise = function () {
        (_this.isCustomise = !0), _this.show();
      });
  }),
  Class(function CarRotate(_mesh, _shader, _input, _group) {
    function loop() {
      Car.CONTROLS && (_mesh.rotation.z = -Car.CONTROLS.rotation);
    }
    function show({ time: time = 1100, ease: ease = "easeOutQuint" }) {
      Car.instance().isIntro ||
        _this.drivingCar ||
        CarCamera.instance().fading ||
        _this.hidden ||
        (_shader.tween("uAlpha", 1, time, "easeOutQuad", 200),
        _shader.tween("uScale", 1, time, ease, 200));
    }
    function hide() {
      Car.instance().isIntro ||
        _this.hidden ||
        ((_this.hidden = !0),
        _shader.tween("uAlpha", 0, 300, "easeOutQuad", 50),
        _shader.tween("uScale", 0.85, 650, "easeOutQuad", 50));
    }
    function addHandlers() {
      _this.events.sub(Car.SHOW_ROTATE, show),
        _this.events.sub(Car.HIDE_ROTATE, hide);
    }
    Inherit(this, Component);
    const _this = this;
    (this.drivingCar = !1),
      (this.hidden = !1),
      _shader.addUniforms({
        tMap: { value: null },
        uScale: { value: 0.85, ignoreUIL: !0 },
        uRotateSpeed: { value: 1 },
        uFadeDist: { value: 5 },
        uAlpha: { value: 0, ignoreUIL: !0 },
        transparent: !0,
        blending: Shader.ADDITIVE_BLENDING,
      }),
      (_mesh.onBeforeRender = loop),
      addHandlers();
  }),
  Class(function CircleNav(_mesh, _shader, _input, _group) {
    function addHandlers() {
      _this.events.sub(Car.DRIVING, toggleDriving),
        _this.events.sub(UI.FADE, fade);
    }
    function toggleDriving(e) {
      _shader.tween("uGlowStrength", e.driving ? 1 : 0.5, 1e3, "easeOutCubic"),
        _shader.tween("uDriving", e.driving ? 1 : 0, 1e3, "easeOutCubic");
    }
    function fade({ hide: hide }) {
      hide || (_mesh.visible = !0),
        _shader.tween("uHaloAlphaFade", hide ? 0 : 1, 600, "easeOutSine"),
        _shader
          .tween(
            "uHaloAlphaFade2",
            hide ? 0 : 1,
            hide ? 500 : 400,
            "easeOutSine",
            hide ? 250 : 100
          )
          .onComplete(() => {
            hide && (_mesh.visible = !1);
          });
    }
    function loop() {
      (_shader.uniforms.uDrivingTurn.value +=
        0.2 * (0.6 * Car.TURN.value - _shader.uniforms.uDrivingTurn.value)),
        (_shader.uniforms.uDrivingSpeed.value = Car.SPEED.value);
    }
    Inherit(this, Component);
    const _this = this;
    (_shader.uniforms.uSize = Config.RADIUS),
      (_shader.uniforms.uDPR = { value: World.DPR, ignoreUIL: !0 }),
      (_shader.uniforms.uColor = Colors.instance().SHADER[0]),
      (_shader.uniforms.uRotation = { value: 0 }),
      (_shader.uniforms.uMaskLeft = { value: 0 }),
      (_shader.uniforms.uMaskRight = { value: 0 }),
      (_shader.uniforms.uHaloAlpha = { value: 0 }),
      (_shader.uniforms.uHaloAlphaFade = { value: 1 }),
      (_shader.uniforms.uHaloAlphaFade2 = { value: 1 }),
      (_shader.uniforms.uDriving = { value: 0 }),
      (_shader.uniforms.uDrivingSpeed = { value: 0 }),
      (_shader.uniforms.uDrivingTurn = { value: 0 }),
      (_shader.uniforms.uGlowStrength = { value: 0.5 }),
      addHandlers(),
      _this.startRender(loop);
  }),
  Class(function GLSectionChoice() {
    function init() {
      _shader = _this.initClass(Shader, "GLSectionChoice", {
        tBg: { value: Background.instance().rt.texture },
        uDPR: { value: World.DPR },
        uSize: { value: 35 },
        uOffset: { value: new Vector2() },
        uColor: { value: new Color("#ffffff") },
        uCircleColor: { value: new Color("#ffffff") },
        uScale: { value: 1 },
        uBg: { value: 1 },
        uCircle: { value: 1 },
        uGlow: { value: 0 },
        uAlpha: { value: 0 },
        uFade: { value: 0.3 },
        uDriving: { value: 1 },
        transparent: !0,
        depthTest: !1,
        depthWrite: !1,
      });
      const mesh = new Mesh(World.PLANE, _shader);
      (mesh.renderOrder = 1e3), _this.group.add(mesh);
    }
    Inherit(this, Object3D);
    const _this = this;
    let _shader;
    Viewport.instance().scene.add(_this.group),
      init(),
      (this.layout = function (x, y) {
        _shader.uniforms.uOffset.value.set(x, y);
      }),
      (this.onDestroy = function () {
        Viewport.instance().scene.remove(_this.group);
      }),
      (this.animateIn = function (delay = 0) {
        _shader.set("uAlpha", 0),
          _shader.set("uBg", 0),
          _shader.set("uScale", 0.8),
          _shader.tween("uAlpha", 1, 2e3, "easeOutCubic", delay),
          _shader.tween("uScale", 1, 2e3, "easeOutCubic", delay),
          _shader.tween("uBg", 1, 2e3, "easeOutCubic", delay);
      }),
      (this.animateOut = function (delay = 0) {
        _shader.tween("uAlpha", 0, 1e3, "easeOutCubic", delay),
          _shader.tween("uScale", 0.8, 1e3, "easeOutCubic", delay),
          _shader.tween("uBg", 0, 1e3, "easeOutCubic", delay);
      }),
      (this.changeColor = function (color) {
        _shader.uniforms.uColor.value.set(color);
      }),
      (this.activate = function (_activeColor) {
        _shader.tween("uFade", 1, 1e3, "easeOutQuint"),
          _shader.tween("uGlow", 1, 1e3, "easeOutQuint"),
          _shader.tween("uScale", 1.2, 1e3, "easeOutQuint"),
          _activeColor &&
            _this.delayedCall((_) => {
              _shader.uniforms.uColor.value.set(_activeColor),
                _shader.uniforms.uCircleColor.value.set(_activeColor);
            }, 200);
      }),
      (this.deactivate = function (_activeColor) {
        _shader.tween("uFade", 0.4, 800, "easeOutQuint"),
          _shader.tween("uGlow", 0, 800, "easeOutQuint"),
          _shader.tween("uScale", 1, 800, "easeOutQuint"),
          _activeColor &&
            (_shader.uniforms.uColor.value.set("#ffffff"),
            _shader.uniforms.uCircleColor.value.set("#ffffff"));
      }),
      (this.hoverOver = function () {
        _shader.tween("uFade", 0.75, 400, "easeOutCubic");
      }),
      (this.hoverOut = function () {
        _shader.tween("uFade", 0.4, 600, "easeOutCubic");
      }),
      (this.enable = function () {
        _shader.tween("uFade", 0.4, 600, "easeOutCubic");
      }),
      (this.disable = function () {
        _shader.tween("uFade", 0.4, 600, "easeOutCubic");
      }),
      (this.toggleDriving = function (isDriving) {
        _shader.tween(
          "uDriving",
          isDriving ? 0 : 1,
          isDriving ? 500 : 1500,
          "easeOutCubic"
        );
      });
  }),
  Class(function GLSectionTitle(_type) {
    function init() {
      _shader = _this.initClass(Shader, "GLSectionTitle", {
        tBg: { value: Background.instance().rt.texture },
        tIcon: {
          value: Utils3D.getTexture(`assets/images/ui/main/${_type}.png`),
        },
        uDPR: { value: World.DPR },
        uSize: { value: 110 },
        uOffset: { value: new Vector2() },
        uColor: { value: new Color("#ffffff") },
        uScale: { value: 1 },
        uBg: { value: 0 },
        uCircle: { value: 1 },
        uIcon: { value: 1 },
        uIconFade: { value: 1 },
        uGlow: { value: 0 },
        uAlpha: { value: 0 },
        uFade: { value: 0.3 },
        uDriving: { value: 1 },
        transparent: !0,
        depthTest: !1,
        depthWrite: !1,
      });
      const mesh = new Mesh(World.PLANE, _shader);
      (mesh.renderOrder = 1e3), _this.group.add(mesh);
    }
    Inherit(this, Object3D);
    const _this = this;
    let _shader;
    var _texture;
    Viewport.instance().scene.add(_this.group),
      init(),
      (this.layout = function (x, y) {
        _shader.uniforms.uOffset.value.set(x, y);
      }),
      (this.changeIcon = function (perma) {
        (_texture = Utils3D.getTexture(`assets/images/ui/main/${perma}.png`)),
          _shader.tween("uIconFade", 0, 400, "easeInOutCubic", (_) => {
            _shader.set("tIcon", _texture),
              _shader.tween("uIconFade", 1, 400, "easeInOutCubic");
          });
      }),
      (this.animateIn = function (delay = 0) {
        _shader.set("uAlpha", 1),
          _shader.set("uBg", 1),
          _shader.set("uScale", 0.001),
          _shader.tween("uAlpha", 1, 2e3, "easeOutCubic", delay),
          _shader.tween(
            "uScale",
            _this.parent.state.active ? 1 : 0.85,
            2e3,
            "easeOutExpo",
            delay
          ),
          _shader.tween("uBg", 1, 2e3, "easeOutCubic", delay),
          _this.parent.state.active &&
            (_shader.tween("uFade", 1, 1e3, "easeOutQuint"),
            _shader.tween("uGlow", 1, 1e3, "easeOutQuint"));
      }),
      (this.animateOut = function (delay = 0) {
        _shader.tween("uAlpha", 0, 700, "easeOutCubic", delay),
          _shader.tween("uScale", 1.1, 700, "easeOutCubic", delay),
          _shader.tween("uBg", 0, 700, "easeOutCubic", delay);
      }),
      (this.changeColor = function (color) {
        _shader.uniforms.uColor.value.set(color);
      }),
      (this.disable = function () {
        _shader.tween("uIcon", 0, 400, "easeOutQuint"),
          _shader.tween("uFade", 0.05, 400, "easeOutQuint");
      }),
      (this.enable = async function () {
        _shader.tween("uIcon", 1, 100, "easeOutQuint"),
          _shader.tween("uFade", 0.8, 1e3, "easeInOutCubic", () => {
            _shader.tween("uFade", 0.3, 1e3, "easeInOutCubic");
          });
      }),
      (this.activate = function () {
        _shader.tween("uFade", 1, 1e3, "easeOutQuint"),
          _shader.tween("uScale", 1, 1e3, "easeOutQuint"),
          _shader.tween("uGlow", 1, 1e3, "easeOutQuint");
      }),
      (this.deactivate = function () {
        _shader.tween("uFade", 0.3, 800, "easeOutQuint"),
          _shader.tween("uScale", 0.85, 800, "easeOutQuint"),
          _shader.tween("uGlow", 0, 800, "easeOutQuint");
      }),
      (this.hoverOver = function () {
        _shader.tween("uFade", 0.7, 400, "easeOutCubic");
      }),
      (this.hoverOut = function () {
        _shader.tween("uFade", 0.3, 600, "easeOutCubic");
      }),
      (this.toggleDriving = function (isDriving) {
        _shader.tween(
          "uDriving",
          isDriving ? 0 : 1,
          isDriving ? 500 : 1e3,
          "easeOutCubic"
        );
      });
  }),
  Class(function Ripple(_mesh, _shader, _input, _group) {
    function addHandlers() {
      _this.events.sub(Car.DRIVING, toggleDriving),
        _this.events.sub(UISection.SECTION_CHANGE, changeSection),
        _this.events.sub(UI.INITIAL_REPORT_RIPPLE, animateReport),
        _this.events.sub(UI.FADE, fade);
    }
    function toggleDriving(e) {
      _shader.tween("uStrength", e.driving ? 0.03 : 0.015, 1e3, "easeOutCubic");
    }
    function fade({ hide: hide }) {
      _shader.tween("uFade", hide ? 0 : 1, 600, "easeOutSine");
    }
    function loop() {
      _shader.uniforms.uTime.value += 0.02 + 0.02 * Car.SPEED.value;
    }
    function changeSection({ index: index, data: data }) {
      _shader.tween(
        "uReport",
        "report" === data.perma ? 1 : 0,
        2e3,
        "easeOutCubic"
      );
    }
    function animateReport({ index: index, data: data }) {
      _shader.tween("uReport", 1, 2e3, "easeOutCubic");
    }
    Inherit(this, Component);
    const _this = this;
    (_shader.uniforms.uSize = Config.RADIUS),
      (_shader.uniforms.tBackground = {
        value: Background.instance().rt.texture,
        ignoreUIL: !0,
      }),
      (_shader.uniforms.tCar = {
        value: Car.instance().rt.texture,
        ignoreUIL: !0,
      }),
      (_shader.uniforms.tMatcap = { value: null }),
      (_shader.uniforms.uDPR = { value: World.DPR, ignoreUIL: !0 }),
      (_shader.uniforms.uHole = { value: 0 }),
      (_shader.uniforms.uStrength = { value: 0 }),
      (_shader.uniforms.uTime = { value: 0 }),
      (_shader.uniforms.uColor = Colors.instance().SHADER[0]),
      (_shader.uniforms.uReport = { value: 0, ignoreUIL: !0 }),
      (_shader.uniforms.uFade = { value: 1 }),
      (_shader.uniforms.uFluidMax = { value: Device.mobile ? 0.15 : 0.12 }),
      Tests.useFluid() &&
        ((_shader.uniforms.tFluid = { value: null }),
        (_shader.uniforms.tFluidMask = { value: null })),
      addHandlers(),
      _this.startRender(loop);
  }),
  Class(function Main() {
    function init() {
      if ((GLUI.init(), window.location.search.includes("p=")))
        return AssetLoader.loadAssets(
          Assets.list().filter(["data", "shaders"])
        ).then(Playground.instance);
      Container.instance();
    }
    !(function () {
      if (Utils.query("performance")) return Performance.displayResults();
      init();
    })();
  });
window._MINIFIED_ = true;
window._BUILT_ = true;
